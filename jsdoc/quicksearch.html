<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"server_lib_query-modules_inserter.js.html":{"id":"server_lib_query-modules_inserter.js.html","title":"Source: server/lib/query-modules/inserter.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/query-modules/inserter.js const authenticator = require(\"../authenticator.js\"); const actionLogger = require(\"../action-logger\"); const databaseController = require(\"../db_controller/db-controller.js\"); const mysql = require(\"mysql\"); /** * Add new user to the database * @param {JSON} - user * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property username {String} * @property hashed_password {String} * @property email {String} * @property isAdmin {string} \"yes\" | \"no\" * @return {JSON} result of the query - {success:Boolean} **/ async function addUser(json, actionUsername) { const iterations = authenticator.produceIterations(); const salt = authenticator.produceSalt(); //Hash password to store it in database (password should be previously hashed with another algorithm on client side) const hash = authenticator.produceHash(json.hashed_password, iterations, salt); const user = { username: json.username, isAdmin: (json.isAdmin) ? json.isAdmin : \"no\", salt: salt, iterations: iterations, hashed_password: hash, recovery_email: json.recovery_email } const sql = prepareInsertSQL(\"User\",user) return await insertQueryDatabase(sql, \"User\", actionUsername, json.username); } /** * Add new test to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property patient_no * @property due_date * @return {JSON} result of the query - {success:Boolean} **/ async function addTest(json, actionUsername) { const sql = prepareInsertSQL(\"Test\", json); return await insertQueryDatabase(sql, \"Test\", actionUsername); } /** * Add new patient to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property patient_no * @property patient_name * @property patient_surname * @property hospital_id * @property carer_id * @return {JSON} result of the query - {success:Boolean} **/ async function addPatient(json, actionUsername) { const sql = prepareInsertSQL(\"Patient\", json); return await insertQueryDatabase( sql, \"Patient\", actionUsername, json.patient_no ); } /** * Add new Hospital to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property hospital_email * @return {JSON} result of the query - {success:Boolean} **/ async function addHospital(json, actionUsername) { const sql = prepareInsertSQL(\"Hospital\", json); return await insertQueryDatabase(sql, \"Hospital\", actionUsername); } /** * Add new carer to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property carer_email * @return {JSON} result of the query - {success:Boolean} **/ async function addCarer(json, actionUsername) { const sql = prepareInsertSQL(\"Carer\", json); return await insertQueryDatabase(sql, \"Carer\", actionUsername); } /** * Run INSERT query on the database * @param {String} sql - SQL query * @param {string} tableName Name of the table which we are inserting into. * @param {string} id Specify new entry's ID, unless the ID is auto generated. * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean} **/ async function insertQueryDatabase(sql, tableName, actionUsername, id = undefined) { const response = await databaseController.insertQuery(sql); if (response.status == \"OK\") { id = id === undefined ? response.response.insertId : id; actionLogger.logInsert(actionUsername, tableName, id, \"Successful.\"); return { success: true, response: { insertId: id } }; }else if (response.err.type === \"SQL Error\") { actionLogger.logInsert(actionUsername,tableName,\"-1\",\"Unsuccessfully tried to execute query: &gt;&gt;\" +sql +\"&lt;&lt;. SQL Error message: &gt;&gt;\" +response.err.sqlMessage +\"&lt;&lt;.\"); } else { actionLogger.logInsert(actionUsername,tableName,\"-1\",\"Unsuccessfully tried to execute query: &gt;&gt;\" +sql +\"&lt;&lt;. Invalid request error message: &gt;&gt;\" +response.err.cause +\"&lt;&lt;.\"); } return { success: false }; } /** * Prepare INSERT query on the database * @param {String} table - Table in which to insert an entry * @param {JSON} object - JSON, which is being entered * @return {String} SQL query **/ function prepareInsertSQL(table, object) { let sql = `INSERT INTO ${table}(`; const properties = Object.keys(object); for (let i = 0; i &lt; properties.length - 1; i++) { sql += `${properties[i]},`; } sql += `${properties[properties.length - 1]}) Values(`; const values = Object.values(object); for (let i = 0; i &lt; values.length - 1; i++) { if (values[i] === undefined || values[i] === null || values[i].length === 0 || values[i] === \"null\" || values[i] === \"NULL\"){ sql += \"NULL,\"; } else { sql += `${mysql.escape(values[i])},`; } } if (values[values.length - 1] === undefined || values[values.length - 1] === null || values[values.length - 1].length === 0 || values[values.length - 1] === \"null\" || values[values.length - 1] === \"NULL\") { sql += `NULL);`; } else { sql += `${mysql.escape(values[values.length - 1])});`; } return sql; } module.exports = { //INSERTS addTest, addUser, addPatient, addHospital, addCarer, //Helper functions - just for testing prepareInsertSQL, insertQueryDatabase, } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_test_unit_lib_calendar_controller_test.js.html":{"id":"client_test_unit_lib_calendar_controller_test.js.html","title":"Source: client/test/unit/lib/calendar_controller_test.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/test/unit/lib/calendar_controller_test.js const chai = require('chai'); const should = chai.should(); const calendar_controller = require('../../../src/lib/calendar-controller'); /** * Test if the getNextDates works when given strings with the right format */ describe(\"Test working frequency formats\", function () { it('should return 13 dates, each 1 day apart.', function () { const expected = [ new Date(2018, 0, 2), new Date(2018, 0, 3), new Date(2018, 0, 4), new Date(2018, 0, 5), new Date(2018, 0, 6), new Date(2018, 0, 7), new Date(2018, 0, 8), new Date(2018, 0, 9), new Date(2018, 0, 10), new Date(2018, 0, 11), new Date(2018, 0, 12), new Date(2018, 0, 13), new Date(2018, 0, 14), new Date(2018, 0, 15), new Date(2018, 0, 16) ] const result = calendar_controller.getNextDates('1-D:15', new Date(2018, 0, 1)); arraysOfDatesEqual(result, expected).should.be.true; }); it('should return 15 dates, each 1 year apart. Starting from 1st Jan 2018', function () { const expected = [ new Date(2019, 0, 1), new Date(2020, 0, 1), new Date(2021, 0, 1), new Date(2022, 0, 1), new Date(2023, 0, 1), new Date(2024, 0, 1), new Date(2025, 0, 1), new Date(2026, 0, 1), new Date(2027, 0, 1), new Date(2028, 0, 1), new Date(2029, 0, 1), new Date(2030, 0, 1), new Date(2031, 0, 1), new Date(2032, 0, 1), new Date(2033, 0, 1) ] const result = calendar_controller.getNextDates('1-Y:15', new Date(2018, 0, 1)); arraysOfDatesEqual(result, expected).should.be.true }); it('should return 15 dates, each 1 week apart. Starting from 30th Dec 2018', function () { const expected = [ new Date(2019, 0, 6), //1 new Date(2019, 0, 13), //2 new Date(2019, 0, 20), //3 new Date(2019, 0, 27), //4 new Date(2019, 1, 3), //5 new Date(2019, 1, 10), //6 new Date(2019, 1, 17), //7 new Date(2019, 1, 24), //8 new Date(2019, 2, 3), //9 new Date(2019, 2, 10), //10 new Date(2019, 2, 17), //11 new Date(2019, 2, 24), //12 new Date(2019, 2, 31), //13 new Date(2019, 3, 7), //14 new Date(2019, 3, 14) //15 ] const result = calendar_controller.getNextDates('1-W:15', new Date(2018, 11, 30)); arraysOfDatesEqual(result, expected).should.be.true }); it('should return 1/1/2020 when inputting \"1-D:1\" on the 31/12/2019', function () { const expected = [ new Date(2020, 0, 1) ] const result = calendar_controller.getNextDates('1-D:1', new Date(2019, 11, 31)); arraysOfDatesEqual(result, expected).should.be.true; }); it('should return 7/1/2020 when inputting \"1-W:1\" on the 31/12/2019', function () { const expected = [ new Date(2020, 0, 7) ] const result = calendar_controller.getNextDates('1-W:1', new Date(2019, 11, 31)); arraysOfDatesEqual(result, expected).should.be.true; }); }); /** * Test if the getNextDates returns null when given strings with the wrong format */ describe(\"Test not frequency formats\", function () { it('should return null on wrong frequency formats', function () { const wrong_formats = [ '', 'a', '-1', 1, null, 0, true, false, [], '-1', 'ÃŸ', '1/0', 0.2, 'Y-4', 'A-Y', '1-R', '/1-D', '0.5-D', 'L-D', '/1-W', '0.5-W', 'L-W', '/1-Y', '0.5-Y', 'L-Y' ] const wrong_n = ['1[', \"s\", 3, '', 'a', '-1', 1, null, 0, true, false, [], '-1', 'ÃŸ', '1/0', 0.2, 'Y-4', 'A-Y', '1-R', '/1-D', '0.5-D', 'L-D', '/1-W', '0.5-W', 'L-W', '/1-W', '0.5-W', 'L-W' ] wrong_formats.forEach(format =&gt; { wrong_n.forEach(frequency =&gt; { const temp = format; format += (\":\" + frequency); const result = calendar_controller.getNextDates(format, new Date(2019, 11, 31)); result.forEach(d =&gt; { should.not.exist(d); }); format = temp; }); }); }); }); describe(\"Test week handling\", function() { const testDays = [ (new Date(2019, 1, 20)), (new Date(2019, 2, 1)), (new Date(2019, 5, 20)), (new Date(2019, 2, 24)), (new Date(2019, 2, 31)), (new Date(2019, 3, 12))]; it (\"Should return the correct monday date given any date\", function(){ let results = []; testDays.forEach( day =&gt; { const monday = calendar_controller.getMondayOfWeek(day); results = results.concat(monday); }); results[0].getDate().should.equal(18); results[0].getMonth().should.equal(1); results[0].getFullYear().should.equal(2019); results[1].getDate().should.equal(25); results[1].getMonth().should.equal(1); results[1].getFullYear().should.equal(2019); results[2].getDate().should.equal(17); results[2].getMonth().should.equal(5); results[2].getFullYear().should.equal(2019); results[3].getDate().should.equal(18); results[3].getMonth().should.equal(2); results[3].getFullYear().should.equal(2019); results[4].getDate().should.equal(25); results[4].getMonth().should.equal(2); results[4].getFullYear().should.equal(2019); results[5].getDate().should.equal(8); results[5].getMonth().should.equal(3); results[5].getFullYear().should.equal(2019); }); it (\"Should return the correct previous week given a well formed week\", function() { const weekTest1 = [(new Date(2019, 1, 25)), (new Date(2019, 1, 26)), (new Date(2019, 1, 27)), (new Date(2019, 1, 28)), (new Date(2019, 2, 1)), (new Date(2019,2,2))]; const weekTest2 = [(new Date(2019, 2, 25)), (new Date(2019, 2, 26)), (new Date(2019, 2, 27)), (new Date(2019, 2, 28)), (new Date(2019, 2, 29)), (new Date(2019, 2, 30))]; let result1 = []; calendar_controller.getPreviousWeek(weekTest1).forEach(day =&gt; { day = new Date(day.getFullYear(), day.getMonth(), day.getDate()); result1 = result1.concat(day); }); result1[0].getDate().should.equal(18); result1[0].getMonth().should.equal(1); result1[0].getFullYear().should.equal(2019); result1[1].getDate().should.equal(19); result1[1].getMonth().should.equal(1); result1[1].getFullYear().should.equal(2019); result1[2].getDate().should.equal(20); result1[2].getMonth().should.equal(1); result1[2].getFullYear().should.equal(2019); result1[3].getDate().should.equal(21); result1[3].getMonth().should.equal(1); result1[3].getFullYear().should.equal(2019); result1[4].getDate().should.equal(22); result1[4].getMonth().should.equal(1); result1[4].getFullYear().should.equal(2019); result1[5].getDate().should.equal(23); result1[5].getMonth().should.equal(1); result1[5].getFullYear().should.equal(2019); let result2 = []; calendar_controller.getPreviousWeek(weekTest2).forEach(day =&gt; { day = new Date(day.getFullYear(), day.getMonth(), day.getDate()); result2 = result2.concat(day); }); result2[0].getDate().should.equal(18); result2[0].getMonth().should.equal(2); result2[0].getFullYear().should.equal(2019); result2[1].getDate().should.equal(19); result2[1].getMonth().should.equal(2); result2[1].getFullYear().should.equal(2019); result2[2].getDate().should.equal(20); result2[2].getMonth().should.equal(2); result2[2].getFullYear().should.equal(2019); result2[3].getDate().should.equal(21); result2[3].getMonth().should.equal(2); result2[3].getFullYear().should.equal(2019); result2[4].getDate().should.equal(22); result2[4].getMonth().should.equal(2); result2[4].getFullYear().should.equal(2019); result2[5].getDate().should.equal(23); result2[5].getMonth().should.equal(2); result2[5].getFullYear().should.equal(2019); }); it (\"Should return the correct next week given a well formed week\", function() { const weekTest3 = [(new Date(2019, 1, 25)), (new Date(2019, 1, 26)), (new Date(2019, 1, 27)), (new Date(2019, 1, 28)), (new Date(2019, 2, 1)), (new Date(2019,2,2))]; let result3 = []; calendar_controller.getNextWeek(weekTest3).forEach(day =&gt; { day = new Date(day.getFullYear(), day.getMonth(), day.getDate()); result3 = result3.concat(day); }); result3[0].getDate().should.equal(4); result3[0].getMonth().should.equal(2); result3[0].getFullYear().should.equal(2019); result3[1].getDate().should.equal(5); result3[1].getMonth().should.equal(2); result3[1].getFullYear().should.equal(2019); result3[2].getDate().should.equal(6); result3[2].getMonth().should.equal(2); result3[2].getFullYear().should.equal(2019); result3[3].getDate().should.equal(7); result3[3].getMonth().should.equal(2); result3[3].getFullYear().should.equal(2019); result3[4].getDate().should.equal(8); result3[4].getMonth().should.equal(2); result3[4].getFullYear().should.equal(2019); result3[5].getDate().should.equal(9); result3[5].getMonth().should.equal(2); result3[5].getFullYear().should.equal(2019); const weekTest4 = [(new Date(2019, 2, 25)), (new Date(2019, 2, 26)), (new Date(2019, 2, 27)), (new Date(2019, 2, 28)), (new Date(2019, 2, 29)), (new Date(2019,2,30))]; let result4 = [] calendar_controller.getNextWeek(weekTest4).forEach(day =&gt; { day = new Date(day.getFullYear(), day.getMonth(), day.getDate()); result4 = result4.concat(day); }); result4[0].getDate().should.equal(1); result4[0].getMonth().should.equal(3); result4[0].getFullYear().should.equal(2019); result4[1].getDate().should.equal(2); result4[1].getMonth().should.equal(3); result4[1].getFullYear().should.equal(2019); result4[2].getDate().should.equal(3); result4[2].getMonth().should.equal(3); result4[2].getFullYear().should.equal(2019); result4[3].getDate().should.equal(4); result4[3].getMonth().should.equal(3); result4[3].getFullYear().should.equal(2019); result4[4].getDate().should.equal(5); result4[4].getMonth().should.equal(3); result4[4].getFullYear().should.equal(2019); result4[5].getDate().should.equal(6); result4[5].getMonth().should.equal(3); result4[5].getFullYear().should.equal(2019); }); }); /** * Check if two arrays containing dates have * the same values * @param {array1} _arr1 * @param {array2} _arr2 */ function arraysOfDatesEqual(_arr1, _arr2) { if (!Array.isArray(_arr1) || !Array.isArray(_arr2) || _arr1.length !== _arr2.length) return false; const arr1 = _arr1.concat().sort(); const arr2 = _arr2.concat().sort(); for (let i = 0; i &lt; arr1.length; i++) { if (arr1[i].getDate() != arr2[i].getDate()) return false; if (arr1[i].getMonth() != arr2[i].getMonth()) return false; if (arr1[i].getFullYear() != arr2[i].getFullYear()) return false; } return true; } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_test_unit_lib_logger_test.js.html":{"id":"server_test_unit_lib_logger_test.js.html","title":"Source: server/test/unit/lib/logger_test.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/test/unit/lib/logger_test.js const chai = require('chai'); const expect = chai.expect; const should = chai.should(); const sinon = require('sinon'); const rewire = require('rewire'); const json_controller = require('./../../../lib/json-parser'); const getJSONStub = sinon.stub(json_controller, \"getJSON\"); const outpath = __dirname.split(\"server\")[0] + \"server/logs\"; getJSONStub.callsFake(function () { return { \"compact\": true, \"timeStamp\": true, \"consoleOutput\": false, \"fileOutput\": true, \"colorize\": true, \"outputFilePath\": outpath }; }) const logger = rewire('./../../../lib/logger', false); logger.__set__(\"writeStream\", null); describe(\"Test logger module functionalities\", () =&gt; { beforeEach(()=&gt;{ logger.__get__(\"initialise\")(); }) const commands = [\"LOG\", \"INFO\", \"WARNING\", \"ERROR\", \"DEBUG\"]; for (const c in commands) { const command = commands[c]; it(`should log ${command} successfully when given a non-existent path`, async () =&gt; { callCommand(command, logger, \"test\"); await sleep(10) let lastLine = \"\"; let done = false; getLastLineOfFile(logger.__get__(\"logPath\"), 1).then((ll) =&gt; { lastLine = ll; done = true; }); while (!done) { await sleep(10); } lastLine.should.contain(\"test\") lastLine.should.contain(command) }); } it('should log with level LOG when createLog is called with null level', async () =&gt; { logger.createLog([\"test\"], null) let lastLine = \"\"; let done = false; getLastLineOfFile(logger.__get__(\"logPath\"), 1).then((ll) =&gt; { lastLine = ll; done = true; }); while (!done) { await sleep(20); } lastLine.should.contain(\"test\") lastLine.should.contain(\"LOG\") }); after(()=&gt;{logger.deleteLogFile()}) }); getJSONStub.restore(); logger.deleteLogFile(); /** |-------------------------------------------------------------------------- | HELPER FUNCTIONS |-------------------------------------------------------------------------- */ /** * Return the last line of a file. * Adapted from https://bit.ly/2Hz2lPO. * @param {string} fileName the path of the file to read */ function getLastLineOfFile(fileName) { const readline = require('readline'); const Stream = require('stream'); const fs = require('fs'); const inStream = fs.createReadStream(fileName); const outStream = new Stream; return new Promise((resolve, reject) =&gt; { const rl = readline.createInterface(inStream, outStream); let lastLine = ''; rl.on('line', function (line) { if (line.length &gt;= 1) lastLine = line; }); rl.on('error', reject) rl.on('close', function () { resolve(lastLine) }); }) } /** * Call a logger command * @param {string} command the command to call * @param {JSON} logger the logger module object */ function callCommand(command, logger, message) { switch (command) { case \"INFO\": logger.info(message); break; case \"ERROR\": logger.error(message); break; case \"WARNING\": logger.warning(message); break; case \"DEBUG\": logger.debug(message); break; default: logger.log(message); break; } } /** * Await for this function to pause execution for a certain time. * * @param {number} ms Time in milliseconds * @returns {Promise} */ function sleep(ms) { return new Promise(resolve =&gt; { setTimeout(resolve, ms); }); } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_query-modules_updater.js.html":{"id":"server_lib_query-modules_updater.js.html","title":"Source: server/lib/query-modules/updater.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/query-modules/updater.js const actionLogger = require(\"../action-logger\"); const databaseController = require(\"../db_controller/db-controller.js\"); const mysql = require(\"mysql\"); const dateformat = require(\"dateformat\"); /** * Edit test query * @param testId The id of the test to be updated * @param {JSON} newInfo All the information of the test (new and old) * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editTest(testId, newInfo, token, actionUsername) { const sql = prepareUpdateSQL(\"Test\", newInfo, \"test_id\"); return await updateQueryDatabase(\"Test\",testId,sql,token,actionUsername); } /** * Edit patient query * @param {JSON} newInfo All the information of the patient to update * Obligatory fields in JSON * @property patient_no {String} * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editPatient(newInfo, token, actionUsername) { const sql = prepareUpdateSQL(\"Patient\", newInfo, \"patient_no\"); return await updateQueryDatabase(\"Patient\",newInfo.patient_no,sql,token,actionUsername); } /** * Edit hospital query * @param {JSON} newInfo All the information of the hospital to update * Obligatory fields in JSON * @property hospital_id {String} * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editHospital(newInfo, token, actionUsername) { const sql = prepareUpdateSQL(\"Hospital\", newInfo, \"hospital_id\"); return await updateQueryDatabase(\"Hospital\",newInfo.hospital_id,sql,token,actionUsername); } /** * Edit carer query * @param {JSON} newInfo All the information of the carer to update * @property carer_id {String} * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editCarer(newInfo, token, actionUsername) { const sql = prepareUpdateSQL(\"Carer\", newInfo, \"carer_id\"); return await updateQueryDatabase(\"Carer\",newInfo.carer_id,sql,token,actionUsername); } async function changeTestDueDate(testId,token, newDate, actionUsername) { newDate = dateformat(newDate, \"yyyymmdd\"); const sql = `UPDATE Test SET due_date=${mysql.escape(newDate)} WHERE test_id = ${mysql.escape(testId)};`; return await updateQueryDatabase(\"Test\",testId,sql,token,actionUsername); } /** * Update User in database * @param {JSON} json - user * @param {string} actionUsername The user who issued the request. * Obligatory properties: * @property username {String}, * One of optional properties * Optional properties: * @property recovery_email {String} * @property hashed_password {String} * @return {JSON} - {success:Boolean response:Array or Error} **/ async function editUser(json, token, actionUsername){ const user = {username: json.username} if(json.hashed_password){ user[\"hashed_password\"] = json.hashed_password } if(json.recovery_email){ user[\"recovery_email\"] = json.recovery_email; } if(json.isAdmin){ user[\"isAdmin\"]=json.isAdmin; } const sql = prepareUpdateSQL(\"User\",user,\"username\"); return await updateQueryDatabase(\"User\", user.username, sql, token, actionUsername); } /** * Change the status of the test in the database * @param {JSON} test * @param {string} actionUsername The user who issued the request. * @property testId {String} - id of a test to change * @property newStatus {enum: \"completed\"/\"late\"/\"inReview\"} - new status of a test * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function changeTestStatus(test,token,actionUsername) { let status; let date; switch (test.newStatus) { case \"completed\": { status = \"yes\"; date = `CURDATE()`; break; } case \"late\": { status = \"no\"; date = `NULL`; break; } case \"inReview\": { status = \"in review\"; date = `CURDATE()`; break; } default: return { success: false, response: \"NO SUCH UPDATE\" }; } const sql = `UPDATE Test SET completed_status=${mysql.escape(status)}, completed_date=${date} WHERE test_id = ${mysql.escape(test.testId)};`; return await updateQueryDatabase(\"Test\",test.testId,sql,token,actionUsername); } /** * Update when the last reminder for this test was sent. * * @param {string} testId - id of a test to change * @param {string} token - The token that grants edit privileges. * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function updateLastReminder(testId, token, actionUsername) { let sql = \"UPDATE Test SET last_reminder = CURDATE(), reminders_sent = reminders_sent + 1 WHERE test_id= ? \"; sql = mysql.format(sql, [testId]); return await updateQueryDatabase(\"Test\", testId, sql, token, actionUsername); } async function changeTestColour(testId, newColour,token, actionUsername) { newColour = newColour == null ? \"NULL\" : mysql.escape(newColour); const sql = `UPDATE Test SET test_colour=${newColour} WHERE test_id = ${mysql.escape(testId)};`; return await updateQueryDatabase(\"Test\",testId,sql,token,actionUsername); } /** * Edit patient colour - quick update. * * @param {String} patientNo Number of the patient to update * @param {string} newColour - New colour to be stored. * @returns result of the query - {success:Boolean response:Array/Error} */ async function changePatientColour(patientNo, newColour,token,actionUsername) { newColour = newColour == null ? \"NULL\" : mysql.escape(newColour); const sql = `UPDATE Patient SET patient_colour=${newColour} WHERE patient_no = ${mysql.escape(patientNo)};`; return await updateQueryDatabase(\"Patient\",patientNo,sql,token,actionUsername); } /** * Prepare UPDATE query on the database * @param {String} table - Table in which to insert an entry * @param {JSON} object - JSON, which is being entered * @param {String} idProperty - property, that the entry can be identified with * @return {String} SQL query **/ function prepareUpdateSQL(table, object, idProperty) { let sql = `Update ${table} SET `; const properties = Object.keys(object); const values = Object.values(object); let pos; for (let i = 0; i &lt; properties.length; i++) { if (properties[i] != idProperty) { if (values[i] === undefined || values[i] === null || values[i].length === 0 || values[i] === \"null\" || values[i] === \"NULL\") { sql += `${properties[i]} = NULL, `; } else { sql += `${properties[i]} = ${mysql.escape(values[i])}, `; } } else { pos = i; } } //delete \", \" from sql query sql = sql.substr(0, sql.length - 2); if (values[pos] === null || values[pos] === undefined || values[pos].length === 0 || values[pos] === \"null\" || values[pos] === \"NULL\") { sql += ` WHERE ${idProperty} = NULL;`; } else { sql += ` WHERE ${idProperty} = ${mysql.escape(values[pos])};`; } //For debug: //logger.debug(sql); return sql; } /** * Run UPDATE query on the database * @param {String} table - Table to edit * @param {String} id - id to edit * @param {String} sql - SQL query * @param {string} token - token to access entry * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:Array/Error} **/ async function updateQueryDatabase(table, id, sql, token, actionUsername) { if (token) { const response = await databaseController.updateQuery(sql,table,id,token); if (response.status === \"OK\") { actionLogger.logUpdate(actionUsername, table, id, \"Successful.\"); return { success: true, response: response.response }; } else if (response.err.type === \"SQL Error\") { actionLogger.logUpdate(actionUsername,table,id,\"Unsuccessfully tried to execute query: &gt;&gt;\" +sql +\"&lt;&lt;. SQL Error message: &gt;&gt;\" +response.err.sqlMessage +\"&lt;&lt;.\"); } else { actionLogger.logUpdate(actionUsername,table,id,\"Unsuccessfully tried to execute query: &gt;&gt;\" +sql +\"&lt;&lt;. Invalid request error message: &gt;&gt;\" +response.err.cause +\"&lt;&lt;.\"); } return { success: false, response: response.err }; } return { success: false, response: { problem: \"Token in use/No token defined\" } }; } module.exports = { //UPDATES editTest, editCarer, editHospital, editPatient, updateLastReminder, changeTestStatus, changeTestDueDate, changeTestColour, changePatientColour, editUser, //Helper functions - for tests only updateQueryDatabase, prepareUpdateSQL, } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_src_lib_inputChecker.js.html":{"id":"client_src_lib_inputChecker.js.html","title":"Source: client/src/lib/inputChecker.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/src/lib/inputChecker.js /** * Purpose of functions below is to verify if given input matches some criteria. * For instance if email has valid type such as \"anystring@anystring.anystring\". * * @author Jakub Cerven */ const intRegex = /^\\+?(0|[1-9]\\d*)$/; const characterRegex = /^[a-zA-Z]+$/; //TODO : maybe add more sophisticated regular expression const emailRegex = /\\S+@\\S+\\.\\S+/; /** * Checks if input is empty or undefined * @param input Some string value * @returns {boolean} */ function emptyCheck(input) { return input === \"\" || input === undefined || input === null; } /** * Checks if input contains only non-negative numbers * @param input String of some value * @returns {boolean} Match with regular expression */ function integerCheck(input) { return intRegex.test(input); } /** * Checks if input contains only characters * @param input String of some value * @returns {boolean} Match with regular expression */ function characterCheck(input) { return characterRegex.test(input); } /** * Checks if input is an email address or empty * This is not a complete check some invalid emails will still return true * @param input String of some value * @returns {boolean} Match with regular expression */ function emailCheck(input) { if (emptyCheck(input)) { return true; } return emailRegex.test(input); } module.exports = {emptyCheck, integerCheck, characterCheck, emailCheck}; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_query-modules_selector.js.html":{"id":"server_lib_query-modules_selector.js.html","title":"Source: server/lib/query-modules/selector.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/query-modules/selector.js const databaseController = require(\"../db_controller/db-controller.js\"); const _ = require(\"lodash\"); const dateformat = require(\"dateformat\"); const mysql = require(\"mysql\"); /** * Get the patient given its patient number * @param {string} patient_no the patient number * @return {JSON} - {success:Boolean response:Array or Error} */ async function getPatient(patient_no) { const sql = `SELECT * FROM Patient WHERE patient_no = ${mysql.escape(patient_no)};`; return await selectQueryDatabase(sql); } /** * Get the info of the patient together with the info of eventual carers and hospitals * @param {string} patient_no the patient number * @return {JSON} - {success:Boolean response:Array or Error} */ async function getFullPatientInfo(patient_no) { const sql = `SELECT * FROM Patient LEFT OUTER JOIN Hospital ON Patient.hospital_id=Hospital.hospital_id LEFT OUTER JOIN Carer ON Patient.carer_id=Carer.carer_id WHERE Patient.patient_no = ${mysql.escape(patient_no)};`; return await selectQueryDatabase(sql); } async function getPatientEditedTests(patientid){ const sql = `Select test_id From Test Where patient_no = ${mysql.escape(patientid)} AND test_id IN (Select table_key From EditTokens Where table_name = \"Test\");`; return await selectQueryDatabase(sql); } /** * Get the carer given its carer id * @param {string} carerID the carer id * @return {JSON} - {success:Boolean response:Array or Error} */ async function getCarer(carerID) { const sql = `SELECT * FROM Carer WHERE carer_id = ${mysql.escape(carerID)};`; return await selectQueryDatabase(sql); } /** * Get the hospital given its hospital id * @param {string} hospital_id the hospital id * @return {JSON} - {success:Boolean response:Array or Error} */ async function getHospital(hospital_id) { const sql = `SELECT * FROM Hospital WHERE hospital_id = ${mysql.escape(hospital_id)};`; return await selectQueryDatabase(sql); } /** * Get all the patients from the database * @param {Boolean} isAdult If the records should be displayed for adult users * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getAllPatients(isAdult) { const adult = isAdult ? \"yes\" : \"no\"; const sql = `Select * From Patient WHERE isAdult='${adult}' ORDER By patient_name,patient_surname`; return await selectQueryDatabase(sql); } /** * Get user from database * @param {String} username - username to retrieve * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getUser(username) { const sql = `Select * From User Where username=${mysql.escape(username)} Limit 1;`; return await selectQueryDatabase(sql); } /** * Get all users from database * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getAllUsers() { const sql = `Select username, isAdmin, recovery_email From User;`; return await selectQueryDatabase(sql); } /** * Get test from the database * @param {String} test_id - id of test * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getTest(test_id) { const sql = `Select * From Test Where test_id=${mysql.escape(test_id)};`; return await selectQueryDatabase(sql); } /** * Get not completed tests from patient * @param {String} patientId - id of patient * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getNextTestsOfPatient(patientId) { const sql = `SELECT * FROM Test WHERE patient_no = ${mysql.escape( patientId )} AND completed_status='no';`; return await selectQueryDatabase(sql); } /** * Get test info with patient info from the database * @param {String} test_id - id of test * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getTestInfo(test_id) { const sql = `SELECT * FROM Test JOIN Patient ON Patient.patient_no = Test.patient_no WHERE test_id=${mysql.escape(test_id)}`; return await selectQueryDatabase(sql); } /** * Get all the overdue tests from the database plus additional info about time difference * @param {Boolean} isAdult If the records should be displayed for adult users * @return {JSON} result of the query - {success:true/false response:Array{SortedWeek}/Error} * @typedef {SortedWeek} * @property class {String} - monday of the week, format: 'Mon Mar 04 2019 00:00:00 GMT+0000 (GMT)' * @property tests {Array[JSON]} - tests within week **/ async function getSortedOverdueWeeks(isAdult) { const adult = isAdult ? \"yes\" : \"no\"; const sql = `Select *, IF(((DAYOFWEEK(due_date)-2) = -1),DATE_ADD(due_date,Interval (-6) Day),DATE_ADD(due_date,Interval (-(DAYOFWEEK(due_date)-2)) Day)) AS Monday From Test NATURAL JOIN Patient where ((completed_date IS NULL AND due_date &lt; CURDATE() AND completed_status='no') OR (completed_date = CURDATE() AND due_date &lt; CURDATE())) AND isAdult='${adult}' ORDER BY due_date,patient_name,patient_surname ASC;`; const response = await selectQueryDatabase(sql); if (response.success == false) { return response; } const groupedTests = _.groupBy(response.response, \"Monday\"); const keys = Object.keys(groupedTests); let classedTests = []; for (let i = 0; i &lt; keys.length; i++) { classedTests = classedTests.concat({ class: keys[i], tests: groupedTests[keys[i]] }); } return { success: true, response: classedTests }; } /** * Get all tests within the week from the database * @param {String} date - any date (from Monday to Friday) within the week to retrieve (format: \"YYYY-MM-DD\") * @param {Boolean} isAdult If the records should be displayed for adult users * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getTestWithinWeek(date, isAdult) { const dateString = dateformat(date, \"yyyy-mm-dd\"); const response = await Promise.all(getTestsDuringTheWeek(dateString, isAdult)) .then(days =&gt; { return checkMultipleQueriesStatus(days); }) .then(data =&gt; { return data; }); return response; } /** * Returns overdue tests that are separated into two groups. One group are the tests that haven't been * sent a reminder. The other group are the tests that have already been sent a reminder. * Response includes some basic info about the test. * * @param {Boolean} isAdult If the records should be displayed for adult users * @returns {JSON} { * success: true|false, * response: { * notReminded: [{ * test_id: * due_date: * patient_no: * patient_name: * patient_surname: * }, ...] * reminded: [{ * test_id: * due_date: * patient_no: * patient_name: * patient_surname: * last_reminder: * reminders_sent: * }, ...] * } * } */ async function getOverdueReminderGroups(isAdult) { const adult = isAdult ? \"yes\" : \"no\"; const sql = `Select test_id, due_date, patient_no, patient_name, patient_surname, last_reminder, reminders_sent, isAdult From Test NATURAL JOIN Patient where completed_date IS NULL AND due_date &lt; CURDATE() AND completed_status='no' AND isAdult='${adult}' ORDER BY last_reminder, due_date,patient_name,patient_surname ASC;`; const res = await selectQueryDatabase(sql); if (!res.success) { return res; } const overdue = res.response; const notReminded = []; const reminded = []; for (let i = 0; i &lt; overdue.length; i++) { if (overdue[i].reminders_sent === 0) { notReminded.push(overdue[i]); } else { reminded.push(overdue[i]); } } return { success: true, response: { notReminded: notReminded, reminded: reminded } }; } /** * Run SELECT query on the database * @param {String} sql - SQL query * @return {JSON} result of the query - {success:Boolean response:Array/Error} **/ async function selectQueryDatabase(sql) { const response = await databaseController .selectQuery(sql) .then(queryResponse =&gt; { if (queryResponse.status === \"OK\") { const data = queryResponse.response.rows; return { success: true, response: data }; } else { return { success: false, response: queryResponse.err }; } }); return response; } /** * Produce multiple queries on the database to retrieve test within the week * @param {String} date - date in the week to retrieve tests (format: \"YYYY-MM-DD\") * @param {Boolean} isAdult If the records should be displayed for adult users * @return {Array} array of queries to run **/ function getTestsDuringTheWeek(date, isAdult) { const adult = isAdult ? \"yes\" : \"no\"; const dateObject = new Date(date); const weekDay = dateObject.getDay(); const daysInWeek = []; let sql; let i = 0; while (i &lt; 5) { const day = -1 * (weekDay - 1) + i; sql = `Select * From Test Join Patient on Test.patient_no=Patient.patient_no Where due_date = DATE_ADD(${mysql.escape( date )}, INTERVAL ${mysql.escape(day)} DAY) AND isAdult='${adult}' ORDER BY patient_name,patient_surname;`; daysInWeek.push(databaseController.selectQuery(sql)); i++; } const day = -1 * (weekDay - 1) + i; sql = `Select * From Test Join Patient on Test.patient_no=Patient.patient_no Where (due_date = DATE_ADD(${mysql.escape( date )}, INTERVAL ${mysql.escape(day)} DAY) OR due_date = DATE_ADD(${mysql.escape( date )}, INTERVAL ${mysql.escape(day + 1)} DAY)) AND isAdult='${adult}' ORDER BY patient_name,patient_surname;`; daysInWeek.push(databaseController.selectQuery(sql)); return daysInWeek; } /** * Run multiple queries on the database * @param {Array} queries - array of queries to run * @return {JSON} result of the query - {success:true/false response:Array/String} **/ function checkMultipleQueriesStatus(queries) { const data = []; let error = false; queries.forEach(query =&gt; { if (query.status === \"OK\") { data.push(query.response.rows); } else { error = true; } }); if (error) { return { success: false, response: \"One query failed\" }; } return { success: true, response: data }; } /** * Get number of test due in month * @param {String} data - date for data to be retrived * @return {JSON} result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} **/ async function getDueTestsInMonth(date=dateformat(new Date(),\"yyyymmdd\")){ const sql = `Select Count(*) as Number From Test Where Month(due_date)=Month(${date});` return await selectQueryDatabase(sql); } /** * Get number of completed tests on time in month * @param {String} data - date for data to be retrived * @return {JSON} result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} **/ async function getCompletedOnTimeInMonth(date=dateformat(new Date(),\"yyyymmdd\")){ const sql = `Select Count(*) as Number From Test Where completed_date&lt;=due_date AND Month(due_date)=Month(${date});` return await selectQueryDatabase(sql); } /** * Get number of completed tests in month * @param {String} data - date for data to be retrived * @return {JSON} result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} **/ async function getCompletedLateInMonth(date=dateformat(new Date(),\"yyyymmdd\")){ const sql = `Select Count(*) as Number From Test Where due_date&lt;completed_date AND Month(completed_date)=Month(${date});` return await selectQueryDatabase(sql); } /** * Get sum of all reminders send in month * @param {String} data - date for data to be retrived * @return {JSON} result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} **/ async function getNumberOfRemindersSent(date=dateformat(new Date(),\"yyyymmdd\")){ const sql = `Select Sum(reminders_sent) as Number From Test Where Month(due_date)=Month(${date});` return await selectQueryDatabase(sql); } /** * Get number of patients in database * @param {Boolean} isAdult - if the number of patients to be retrived should be for adult patients * @return {JSON} result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} **/ async function getPatientsNumber(isAdult=true){ isAdult = (isAdult) ? \"yes\" : \"no\"; const sql = `Select Count(*) as Number From Patient Where isAdult='${isAdult}';` return await selectQueryDatabase(sql); } module.exports = { //SELECTS getPatient, getTest, getHospital, getCarer, getUser, getAllUsers, getAllPatients, getFullPatientInfo, getTestInfo, getNextTestsOfPatient, getTestWithinWeek, getSortedOverdueWeeks, getOverdueReminderGroups, getPatientEditedTests, getDueTestsInMonth, getCompletedOnTimeInMonth, getCompletedLateInMonth, getNumberOfRemindersSent, getPatientsNumber, //Helper functions - for tests only selectQueryDatabase } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_db_controller_Database.js.html":{"id":"server_lib_db_controller_Database.js.html","title":"Source: server/lib/db_controller/Database.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/db_controller/Database.js /** * Promisify mysql. * Adapted from: https://codeburst.io/node-js-mysql-and-promises-4c3be599909b * * @class Database */ const mysql = require(\"mysql\"); module.exports = class Database { constructor(config) { this.connection = mysql.createConnection(config); this.connection.beginTransaction(); } query(sql, args) { return new Promise((resolve, reject) =&gt; { this.connection.query(sql, args, (err, rows) =&gt; { if (err) return reject(err); resolve(rows); }); }); } close() { this.connection.commit(); return new Promise((resolve, reject) =&gt; { this.connection.end((err) =&gt; { if (err) return reject(err); resolve(); }); }); } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_query-modules_deleter.js.html":{"id":"server_lib_query-modules_deleter.js.html","title":"Source: server/lib/query-modules/deleter.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/query-modules/deleter.js const actionLogger = require(\"../action-logger\"); const selector = require(\"./selector\"); const databaseController = require(\"../db_controller/db-controller.js\"); const mysql = require(\"mysql\"); /** * Delete Carer entry from database *@param {String} carerid - id of a carer to be deleted * @param {string} actionUsername The user who issued the request. *@return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deleteCarer(carerid, actionUsername) { const sql = prepareDeleteSQL(\"Carer\", \"carer_id\", carerid); return await deleteQueryDatabase(\"Carer\", carerid, sql, actionUsername); } /** * Delete hospital entry from database * @param {String} hospitalid - id of a hospital to be deleted * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deleteHospital(hospitalid, actionUsername) { const sql = prepareDeleteSQL(\"Hospital\", \"hospital_id\", hospitalid); return await deleteQueryDatabase(\"Hospital\", hospitalid, sql, actionUsername); } /** * Delete Patient from database * @param {String} patientid - patient_no of a patient * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deletePatient(patientid,actionUsername){ const sql = prepareDeleteSQL(\"Patient\", \"patient_no\", patientid); return await deleteQueryDatabase(\"Patient\", patientid, sql, actionUsername); } /** * Delete test entry from database * @param {String} testid - id of a test to be deleted * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deleteTest(testid, actionUsername) { const sql = prepareDeleteSQL(\"Test\", \"test_id\", testid); return await deleteQueryDatabase(\"Test\", testid, sql, actionUsername); } /** * Run DELETE query on the database * @param {String} table - Table to edit * @param {String} id - id to edit * @param {String} sql - SQL query * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deleteQueryDatabase(table, id, sql, actionUsername) { let deletedInfo; switch (table) { case \"Test\": deletedInfo = (await selector.getTest(id)).response[0]; break; case \"Patient\": deletedInfo = (await selector.getFullPatientInfo(id)).response[0]; break; case \"Hospital\": deletedInfo = (await selector.getHospital(id)).response[0]; break; case \"Carer\": deletedInfo = (await selector.getCarer(id)).response[0]; break; } const response = await databaseController.deleteQuery(sql, table, id); if (response.status === \"OK\") { actionLogger.logDelete(actionUsername,table,id,\"Successful. Deleted data: &gt;&gt;\" + JSON.stringify(deletedInfo) + \"&lt;&lt;.\"); return { success: true, response: \"Entry deleted\" }; } else if (response.err.type === \"SQL Error\") { actionLogger.logDelete(actionUsername,table,id,\"Unsuccessfully tried to execute query: &gt;&gt;\" +sql +\"&lt;&lt;. SQL Error message: &gt;&gt;\" +response.err.sqlMessage +\"&lt;&lt;.\"); } else { actionLogger.logDelete(actionUsername,table,id,\"Unsuccessfully tried to execute query: &gt;&gt;\" +sql +\"&lt;&lt;. Invalid request error message: &gt;&gt;\" +response.err.cause +\"&lt;&lt;.\"); } return { success: false, response: response.err }; } /** * Prepare DELETE query on the database * @param {String} table - Table in which to insert an entry * @param {String} idProperty - property, that the entry can be identified with * @param {String} id - value of idProperty * @return {String} SQL query **/ function prepareDeleteSQL(table, idProperty, id) { const sql = `DELETE FROM ${table} WHERE ${idProperty}=${mysql.escape(id)} LIMIT 1;`; return sql; } module.exports = { //DELETE deleteHospital, deletePatient, deleteCarer, deleteTest, //Helper functions - for tests only deleteQueryDatabase, prepareDeleteSQL }; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_src_components_calendarComponents_CalendarHeader.js.html":{"id":"client_src_components_calendarComponents_CalendarHeader.js.html","title":"Source: client/src/components/calendarComponents/CalendarHeader.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/src/components/calendarComponents/CalendarHeader.js import React from 'react'; import styled from \"styled-components\"; const Arrow = styled.button` font-size: 100%; padding: 0; border: none; margin: 0; color: white; background-color: #0b989d; &amp;:hover { width: 100%; color: #0b989d; background-color: white; border-radius: 10px } `; const Header = styled.tr` text-align: center; color: white; font-size: 120%; font-weight: bold; `; const monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ]; const arrowColSpan = 1; const monthColSpan = 5; /** * Return the full name of the month from the received date * @param {Date} date: date * @return {string} The name of date's month */ function getMonthName(date){ return monthNames[date.getMonth()]; } /** * Return month and year from the received date as string. * (Mon Mar 04 2019 ... = March 2019) * @param {Date} date: date * @return {string} Month and Year as string */ function getMonthAndYear(date){ return getMonthName(date) + \" \" + date.getFullYear(); } const CalendarHeader = props =&gt; { return( &lt;Header className={'header'}&gt; &lt;td colSpan={arrowColSpan}&gt; &lt;Arrow onClick={() =&gt; props.prevMonth()}&gt;&amp;lt;&lt;/Arrow&gt; &lt;/td&gt; &lt;td colSpan={monthColSpan}&gt;{getMonthAndYear(props.currentDate)}&lt;/td&gt; &lt;td colSpan={arrowColSpan}&gt; &lt;Arrow onClick={() =&gt; props.nextMonth()}&gt;&amp;gt;&lt;/Arrow&gt; &lt;/td&gt; &lt;/Header&gt; ) } export default CalendarHeader; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_action-logger.js.html":{"id":"server_lib_action-logger.js.html","title":"Source: server/lib/action-logger.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/action-logger.js /** * This module provides some functions for faster * logging of different actions on the DB. * * @author Luka Kralj * @version 1.0 * * @module action-logger */ module.exports = { logInsert, logUpdate, logDelete, logOther, enableConsoleOutput, disableConsoleOutput }; const mysql = require('mysql'); const db_controller = require('./db_controller/db-controller'); const dateFormat = require('dateformat'); const logger = require('./logger'); /** * If true, it will output to the console, otherwise it will not output anything. * It's good to turn it off in testing to increase readability. Leave on for debugging. */ let showConsoleOutput = true; function enableConsoleOutput() { showConsoleOutput = true; } function disableConsoleOutput() { showConsoleOutput = false; } /** * Call this to log an insert action. * * @param {string} username User that has done that action. * @param {string} tableName The table that was involved in the action. * @param {string} entryID The key of the entry from the previous table that was involved in the action. * @param {string} message Optional message that can provide more details about the action. * @param {function} Optional action, called with the result of insertQuery. */ function logInsert(username, tableName, entryID, message = undefined, callback = undefined) { log(\"insert\", username, tableName, entryID, message, callback); } /** * Call this to log an update action. * * @param {string} username User that has done that action. * @param {string} tableName The table that was involved in the action. * @param {string} entryID The key of the entry from the previous table that was involved in the action. * @param {string} message Optional message that can provide more details about the action. * @param {function} Optional action, called with the result of insertQuery. */ function logUpdate(username, tableName, entryID, message = undefined, callback = undefined) { log(\"update\", username, tableName, entryID, message, callback); } /** * Call this to log a delete action. * * @param {string} username User that has done that action. * @param {string} tableName The table that was involved in the action. * @param {string} entryID The key of the entry from the previous table that was involved in the action. * @param {string} message Optional message that can provide more details about the action. * @param {function} Optional action, called with the result of insertQuery. */ function logDelete(username, tableName, entryID, message = undefined, callback = undefined) { log(\"delete\", username, tableName, entryID, message, callback); } /** * Call this to log any other action. Say, requested editing, or attempted an invalid login etc. * * @param {string} username User that has done that action. * @param {string} tableName The table that was involved in the action. * @param {string} entryID The key of the entry from the previous table that was involved in the action. * @param {string} message Message that provides details about the action. In this case the message is compulsory * as it needs to explain what happened. * @param {function} Optional action, called with the result of insertQuery. */ function logOther(username, tableName, entryID, message, callback = undefined) { if (message === undefined) { throw new Error(\"Invalid use of a logger function.\"); } log(\"other\", username, tableName, entryID, message, callback); } /** * Helper function to reduce duplication. * * @param {string} type Type of action taken: insert, update or delete. * @param {string} username User that has done that action. * @param {string} tableName The table that was involved in the action. * @param {string} entryID The key of the entry from the previous table that was involved in the action. * @param {string} message Optional message that can provide more details about the action. * @param {function} Optional action, called with the result of insertQuery. */ function log(type, username, tableName, entryID, message = undefined, callback = undefined) { if (username === undefined || tableName === undefined || entryID === undefined) { throw new Error(\"Invalid use of a logger function.\"); } message = (message === undefined) ? \"NULL\" : message; let date = new Date(); date = dateFormat(date, \"yyyymmddHHMMss.lll\"); let sql = \"INSERT INTO ActionLog \" + \"(username, action_timestamp, action_type, table_affected, entry_affected, additional_info)\" + \"VALUES (?, ?, ?, ?, ?, ?)\"; sql = mysql.format(sql, [username, date, type, tableName, entryID, message]); let s = \"\"; switch (type) { case \"insert\": s = \"inserted\"; break; case \"update\": s = \"updated\"; break; case \"delete\": s = \"deleted\"; break; case \"other\": break; default: throw new Error(\"Invalid type.\"); } db_controller.insertQuery(sql) .then((result) =&gt; { if (showConsoleOutput) { message = (message === \"NULL\") ? \"No message.\" : message; if (s.length &gt; 0 &amp;&amp; result.status === \"OK\") { logger.info(\"Log: user \" + username + \" \" + s + \" \" + tableName + \"(\" + entryID + \"): \" + message); } else if (s.length &gt; 0) { logger.error(\"ERROR logging: user \" + username + \" \" + s + \" \" + tableName + \"(\" + entryID + \"): \" + message + \". Error: \" + JSON.stringify(result.err)); } else if (result.status === \"OK\") { logger.info(\"Log: user \" + username + \" committed other action: \" + message); } else { logger.error(\"ERROR logging: user \" + username + \" committed other action: \" + message + \". Error: \" + JSON.stringify(result.err)); } } if (callback) callback(result); }); } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_test_integration_lib_action-logger-test.js.html":{"id":"server_test_integration_lib_action-logger-test.js.html","title":"Source: server/test/integration/lib/action-logger-test.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/test/integration/lib/action-logger-test.js /** * This file contains tests that test the behaviour of action-logger.js * * @author Luka Kralj * @version 1.0 * * @module action-logger-test * @see module:action-logger */ const chai = require(\"chai\") const expect = chai.expect; const rewire = require('rewire'); const action_logger = rewire(\"../../../lib/action-logger\"); const sinonChai = require('sinon-chai') const Database = require(\"../../../lib/db_controller/Database\"); const databaseConfig = require(\"../../../config/database\"); const sinon = require('sinon'); chai.use(sinonChai); before(() =&gt; { action_logger.disableConsoleOutput(); }); after(() =&gt; { action_logger.enableConsoleOutput(); }); describe(\"Test action logger:\", () =&gt; { before(() =&gt; { const database = new Database(databaseConfig); database.query(\"INSERT INTO User VALUES ('logger_test','password','no','','1','logger_test@gmail')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); afterEach(() =&gt; { const database = new Database(databaseConfig); database.query(\"DELETE FROM ActionLog WHERE username = 'logger_test'\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); after(() =&gt; { const database = new Database(databaseConfig); database.query(\"DELETE FROM User WHERE username = 'logger_test'\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); describe(\"&gt; Test logging insert actions:\", () =&gt; { it(\"Should throw an error for invalid arguments.\", async () =&gt; { let error = undefined; try { await action_logger.logInsert(\"\", \"\"); } catch(err) { error = err; } expect(error).to.not.be.undefined; }); it(\"Should add a new entry to the database.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logInsert(\"logger_test\", \"Patient\", \"P123\", undefined, (res) =&gt; { try { expect(res.status).to.equal(\"OK\"); expect(res.response.insertId).to.not.equal(0); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); it(\"Should reject the log.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logInsert(\"invalid_user\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"ERR\"); expect(res.err.type).to.equal(\"SQL Error\"); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); }); describe(\"&gt; Test logging update actions:\", () =&gt; { it(\"Should throw an error for invalid arguments.\", async () =&gt; { let error = undefined; try { await action_logger.logUpdate(\"\", \"\"); } catch(err) { error = err; } expect(error).to.not.be.undefined; }); it(\"Should add a new entry to the database.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logUpdate(\"logger_test\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"OK\"); expect(res.response.insertId).to.not.equal(0); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); it(\"Should reject the log.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logUpdate(\"invalid_user\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"ERR\"); expect(res.err.type).to.equal(\"SQL Error\"); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); }); describe(\"&gt; Test logging delete actions:\", () =&gt; { it(\"Should throw an error for invalid arguments.\", async () =&gt; { let error = undefined; try { await action_logger.logDelete(\"\", \"\"); } catch(err) { error = err; } expect(error).to.not.be.undefined; }); it(\"Should add a new entry to the database.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logDelete(\"logger_test\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"OK\"); expect(res.response.insertId).to.not.equal(0); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); it(\"Should reject the log.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logDelete(\"invalid_user\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"ERR\"); expect(res.err.type).to.equal(\"SQL Error\"); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); }); describe(\"&gt; Test logging other actions:\", () =&gt; { it(\"Should throw an error for invalid arguments.\", async () =&gt; { let error = undefined; try { await action_logger.logOther(\"logger_test\", \"Patient\", \"P123\"); // message is compulsory } catch(err) { error = err; } expect(error).to.not.be.undefined; }); it(\"Should add a new entry to the database.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logOther(\"logger_test\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"OK\"); expect(res.response.insertId).to.not.equal(0); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); it(\"Should reject the log.\", async () =&gt; { let error = undefined; let finished = false; action_logger.logOther(\"invalid_user\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"ERR\"); expect(res.err.type).to.equal(\"SQL Error\"); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } if (error) throw error; }); }); describe(\"&gt; Test console output:\", () =&gt; { let infoCalls = 0; let errorCalls = 0; const stub_logger = { info: function() { infoCalls++; }, error: function() { errorCalls++; } } action_logger.__set__(\"logger\", stub_logger); beforeEach(() =&gt; { infoCalls = 0; errorCalls = 0; action_logger.enableConsoleOutput(); }); afterEach(function() { action_logger.disableConsoleOutput(); }); it(\"Should reject the log (other + invalid username).\", async () =&gt; { let error = undefined; let finished = false; action_logger.logOther(\"invalid_user\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"ERR\"); expect(res.err.type).to.equal(\"SQL Error\"); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } expect(infoCalls).to.equal(0); expect(errorCalls).to.equal(1); if (error) throw error; }); it(\"Should accept the log (other + valid username).\", async () =&gt; { let error = undefined; let finished = false; action_logger.logOther(\"logger_test\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"OK\"); expect(res.response.insertId).to.not.equal(0); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } expect(infoCalls).to.equal(1); expect(errorCalls).to.equal(0); if (error) throw error; }); it(\"Should reject the log (insert + invalid username).\", async () =&gt; { let error = undefined; let finished = false; action_logger.logInsert(\"invalid_user\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"ERR\"); expect(res.err.type).to.equal(\"SQL Error\"); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } expect(infoCalls).to.equal(0); expect(errorCalls).to.equal(1); if (error) throw error; }); it(\"Should accept the log (insert + valid username).\", async () =&gt; { let error = undefined; let finished = false; action_logger.logInsert(\"logger_test\", \"Patient\", \"P123\", \"message\", (res) =&gt; { try { expect(res.status).to.equal(\"OK\"); expect(res.response.insertId).to.not.equal(0); } catch(err) { error = err; } finished = true; }); while (!finished) { await sleep(1); } expect(infoCalls).to.equal(1); expect(errorCalls).to.equal(0); if (error) throw error; }); }); }); /** * Prints an error that occurred during setting up the testing * environment in a nice format. * * @param {Error} err Error that occurred. */ function printSetupError(err) { console.log(\"=======================================\"); console.log(\"Error setting up testing environment:\\n\" + err); console.log(\"=======================================\"); } /** * Await for this function to pause execution for a certain time. * * @param {number} ms Time in milliseconds * @returns {Promise} */ function sleep(ms){ return new Promise((resolve) =&gt; { setTimeout(resolve,ms); }); } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_authenticator.js.html":{"id":"server_lib_authenticator.js.html","title":"Source: server/lib/authenticator.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/authenticator.js /** * This module contains functions for user authentication and verification. * * @author Mateusz Nowak, Luka Kralj * @version 1.0 * @module authenicator */ const crypto = require(\"crypto\"); const tokenGenerator = require('./db_controller/token-generator'); const db_controller = require('./db_controller/db-controller'); const mysql = require('mysql'); const logger = require('./logger') module.exports = { canLogin, produceIterations, produceSalt, produceHash, verifyToken, registerNewUsername, logoutUser }; const accessTokens = {}; const ACCESS_TOKEN_VALIDITY_DAYS = 10; initTokens(); /** *Function tha naively checks if user *provided right credentials */ function canLogin(user, userInDatabase) { if (userInDatabase == undefined || userInDatabase.length !== 1 || user.username == null || user.password == null) { return false; } if (user.username === userInDatabase[0].username) { const hash = crypto.pbkdf2Sync(user.password, userInDatabase[0].salt, userInDatabase[0].iterations, 64, 'sha256').toString('hex'); if (hash == userInDatabase[0].hashed_password) { return true; } } return false; } function produceIterations() { const min = 1000; const max = 2000; const random = Math.floor(Math.random() * (+max - +min)) + +min; return random; } function produceSalt() { return crypto.randomBytes(16).toString('hex'); } function produceHash(password, iterations, salt) { return crypto.pbkdf2Sync(password, salt, iterations, 64, 'sha256').toString('hex'); } /** * Retrieves all access tokens (if any) from the database and creates a lookup table for * faster access. */ async function initTokens() { const res = await db_controller.selectQuery(\"SELECT * FROM AccessTokens\"); if (res.status !== \"OK\") { logger.error(\"Could not initialise tokens from the DB. Response: \" + JSON.stringify(res)); return; } const rows = res.response.rows; for (let i = 0; i &lt; rows.length; i++) { accessTokens[rows[i].token] = { username: rows[i].username, expires: rows[i].expiration } } logger.info(\"Successfully loaded \" + rows.length + \" token(s) from the DB.\"); } /** * Verifies user using the accessToken. * * @param {string} accessToken Token used for identification. * @returns Username of the user or undefined if token is invalid. */ async function verifyToken(accessToken) { if (!(accessToken in accessTokens)) { return undefined; } const expires = new Date(accessTokens[accessToken].expires); if ((expires - new Date()) &lt;= 0) { delete accessTokens[accessToken]; db_controller.deleteAccessToken(accessToken) .then((res) =&gt; { if (res.status === \"OK\") { logger.info(\"Access token successfully deleted.\") } else { logger.error(\"Error deleting access token. Response: \" + JSON.stringify(res)); } }); return undefined; } const newExpiry = new Date(); newExpiry.setDate(newExpiry.getDate() + ACCESS_TOKEN_VALIDITY_DAYS); accessTokens[accessToken].expires = newExpiry; db_controller.updateAccessToken(accessToken, newExpiry) .then((res) =&gt; { if (res.status !== \"OK\") { logger.error(\"Error updating access token. Response: \" + JSON.stringify(res)); } }); return accessTokens[accessToken].username; } /** * Register the given username with a login token that is * used in authorisation of the requests. * * @param {string} username A valid username. * @returns {string} A login token for this user. */ async function registerNewUsername(username) { const token = tokenGenerator.generateLoginToken(); const expires = new Date(); expires.setDate(expires.getDate() + ACCESS_TOKEN_VALIDITY_DAYS); accessTokens[token] = { username: username, expires: expires }; let sql = \"INSERT INTO AccessTokens VALUES (?, ?, ?)\"; sql = mysql.format(sql, [token, username, expires]); db_controller.insertQuery(sql) .then((res) =&gt; { if (res.status === \"OK\") { logger.info(\"Access token successfully stored.\") } else { logger.error(\"Error storing access token. Response: \" + JSON.stringify(res)); } }); return token; } /** * Delete access token for this user. * * @param {string} accessToken Token used for identification. * @returns {boolean} True if token successfully deleted, false if invalid token. */ async function logoutUser(accessToken) { if (await verifyToken(accessToken)) { delete accessTokens[accessToken]; db_controller.deleteAccessToken(accessToken) .then((res) =&gt; { if (res.status === \"OK\") { logger.info(\"Access token successfully deleted.\") } else { logger.error(\"Error deleting access token. Response: \" + JSON.stringify(res)); } }); return true; } else { return false; } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_test_unit_authenticator-test.js.html":{"id":"server_test_unit_authenticator-test.js.html","title":"Source: server/test/unit/authenticator-test.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/test/unit/authenticator-test.js /** * This file contains tests that test the behaviour of authenticator.js * * @author Luka Kralj * @version 1.0 * * @module authenticator-test * @see module:authenticator */ const chai = require(\"chai\"); const expect = chai.expect; const rewire = require('rewire'); const should = chai.should(); const crypto = require(\"crypto\"); const authenticator = rewire(\"../../lib/authenticator\"); describe(\"Test authentication\", function() { context(\"User in database\", function(){ let testEntry; beforeEach(()=&gt;{ testEntry = [{id:\"1\", username:\"admin\", hashed_password:\"f0edc3ac2daf24876a782e9864e9596970a8b8717178e705cd70726b92dbfc58c8e8fb27f7082239969496d989ff65d0bb2fcc3bd91c3a0251fa221ca2cd88a5\", iterations:1268, salt:\"d50dbbbe33c2d3c545051917b6a60ccd577a1a3f1a96dfac95199e7b0de32841\"}]; }) it(\"Should return false when wrong credentials\", function(){ const testCredentials = {username: \"wrong\", password: crypto.createHash('sha256').update(\"wrong\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false when wrong credentials\", function(){ const testCredentials = {username: \"wrong2\", password: crypto.createHash('sha256').update(\"wrong2\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false when empty credentials\", function(){ const testCredentials = {username: \"\", password: crypto.createHash('sha256').update(\"\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false when empty password\", function(){ const testCredentials = {username: \"wrong\", password: crypto.createHash('sha256').update(\"\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false when empty username\", function(){ const testCredentials = {username: \"\", password: crypto.createHash('sha256').update(\"still wrong\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false for correct user, wrong password\", function(){ const testCredentials = {username: \"admin\", password: crypto.createHash('sha256').update(\"wrong\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false for correct password, wrong user\", function(){ const testCredentials = {username: \"wrong\", password: crypto.createHash('sha256').update(\"admin\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false for null password\", function(){ const testCredentials = {username: \"wrong\", password: null}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return false for null username\", function(){ const testCredentials = {username: null, password: crypto.createHash('sha256').update(\"admin\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); it(\"Should return true for correct credentials\", function(){ const testCredentials = {username: \"admin\", password: crypto.createHash('sha256').update(\"admin\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(true); }); }); context(\"No user in database\", function(){ let testEntry; it(\"Should return false when no user in database\", function(){ const testCredentials = {username: \"wrong\", password: crypto.createHash('sha256').update(\"admin\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); }); context(\"Two many users with same username in database\", function(){ const testEntry = [ {id:\"1\", username:\"admin\", hashed_password:\"f0edc3ac2daf24876a782e9864e9596970a8b8717178e705cd70726b92dbfc58c8e8fb27f7082239969496d989ff65d0bb2fcc3bd91c3a0251fa221ca2cd88a5\", iterations:1268, salt:\"d50dbbbe33c2d3c545051917b6a60ccd577a1a3f1a96dfac95199e7b0de32841\"}, {id:\"2\", username:\"admin\", hashed_password:\"fsddsdsjdsjdsjjjjjjjduweewbefwyewfbiewfkcenwowefewuefiefvevoeweovmevoevevoenvwoewvnevoewvnmoevmevowewvolevwmveemwvoveweovwmevea5\", iterations:1783, salt:\"wu3ueebe33c2d3c5dshjdsjhcbfwejyewfuwebviewuiewvbuieuie7b0de32841\"} ]; it(\"Should return false when no user in database\", function(){ const testCredentials = {username: \"wrong\", password: crypto.createHash('sha256').update(\"admin\").digest('hex')}; authenticator.canLogin(testCredentials, testEntry).should.equal(false); }); }); describe(\"Test registerNewUsername():\", () =&gt; { let accessTokens; beforeEach(() =&gt; { const tokenGenerator = { generateLoginToken: function() { return \"test_login_token\"; } }; accessTokens = {}; const db_controller = { insertQuery: async function() { return { status: \"OK\" }; } }; authenticator.__set__(\"tokenGenerator\", tokenGenerator); authenticator.__set__(\"accessTokens\", accessTokens); authenticator.__set__(\"db_controller\", db_controller); }); describe(\"&gt; Test if correct token is stored with the correct username:\", () =&gt; { it(\"Should store and return the correct token.\", async () =&gt; { const token = await authenticator.registerNewUsername(\"test_user\"); expect(token).to.equal(\"test_login_token\"); expect(accessTokens[\"test_login_token\"].username).to.equal(\"test_user\"); expect(accessTokens[\"test_login_token\"].expires).to.not.be.undefined; }); }); }); describe(\"Test verifyToken():\", () =&gt; { let accessTokens; let date; beforeEach(() =&gt; { date = new Date(); const validDate = new Date(); validDate.setDate(validDate.getDate() + 2); const invalidDate = new Date(); invalidDate.setDate(invalidDate.getDate() - 2); accessTokens = { test_valid_login_token: { username: \"test_user_valid\", expires: validDate }, test_invalid_login_token: { username: \"test_user_invalid\", expires: invalidDate } }; const db_controller = { deleteAccessToken: async function() { return { status: \"OK\" }; }, updateAccessToken: async function() { return { status: \"OK\" }; } }; authenticator.__set__(\"accessTokens\", accessTokens); authenticator.__set__(\"db_controller\", db_controller); }); describe(\"&gt; Test with invalid token:\", () =&gt; { it(\"Should return undefined.\", async () =&gt; { const username = await authenticator.verifyToken(\"invalid_token\"); expect(username).to.be.undefined; expect(accessTokens.test_valid_login_token.username).to.equal(\"test_user_valid\"); expect(accessTokens.test_invalid_login_token.username).to.equal(\"test_user_invalid\"); }); }); describe(\"&gt; Test with expired token:\", () =&gt; { it(\"Should delete that token and return undefined.\", async () =&gt; { const username = await authenticator.verifyToken(\"test_invalid_login_token\"); expect(username).to.be.undefined; expect(accessTokens.test_valid_login_token.username).to.equal(\"test_user_valid\"); expect(accessTokens.test_invalid_login_token).to.be.undefined; }); }); describe(\"&gt; Test with valid token:\", () =&gt; { it(\"Should return correct username and update expiry.\", async () =&gt; { const username = await authenticator.verifyToken(\"test_valid_login_token\"); expect(username).to.equal(\"test_user_valid\"); expect(accessTokens.test_valid_login_token.username).to.equal(\"test_user_valid\"); expect(accessTokens.test_invalid_login_token.username).to.equal(\"test_user_invalid\"); expect(accessTokens.test_valid_login_token.expires &gt; date).to.be.true; }); }); }); describe(\"Test logoutUser():\", () =&gt; { let accessTokens; beforeEach(() =&gt; { const validDate = new Date(); validDate.setDate(validDate.getDate() + 2); const invalidDate = new Date(); invalidDate.setDate(invalidDate.getDate() - 2); accessTokens = { test_valid_login_token: { username: \"test_user_valid\", expires: validDate }, test_invalid_login_token: { username: \"test_user_invalid\", expires: invalidDate } }; const db_controller = { deleteAccessToken: async function() { return { status: \"OK\" }; }, updateAccessToken: async function() { return { status: \"OK\" }; } }; authenticator.__set__(\"accessTokens\", accessTokens); authenticator.__set__(\"db_controller\", db_controller); }); describe(\"&gt; Test with invalid token:\", () =&gt; { it(\"Should return false.\", async () =&gt; { const res = await authenticator.logoutUser(\"invalid_token\"); expect(res).to.be.false; expect(accessTokens.test_valid_login_token.username).to.equal(\"test_user_valid\"); expect(accessTokens.test_invalid_login_token.username).to.equal(\"test_user_invalid\"); }); }); describe(\"&gt; Test with expired token:\", () =&gt; { it(\"Should delete token and return false.\", async () =&gt; { const res = await authenticator.logoutUser(\"test_invalid_login_token\"); expect(res).to.be.false; expect(accessTokens.test_valid_login_token.username).to.equal(\"test_user_valid\"); expect(accessTokens.test_invalid_login_token).to.be.undefined; }); }); describe(\"&gt; Test with valid token:\", () =&gt; { it(\"Should delete token and return true.\", async () =&gt; { const res = await authenticator.logoutUser(\"test_valid_login_token\"); expect(res).to.be.true; expect(accessTokens.test_valid_login_token).to.be.undefined; expect(accessTokens.test_invalid_login_token.username).to.equal(\"test_user_invalid\"); }); }); }); }); Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_src_lib_calendar-controller.js.html":{"id":"client_src_lib_calendar-controller.js.html","title":"Source: client/src/lib/calendar-controller.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/src/lib/calendar-controller.js /** * Controller functions to get dates using a frequency format * @module calendar-controller * @author Danilo Del Busso * @version 0.0.1 */ const Holidays = require('date-holidays'); const hd = new Holidays('GB'); const formatDate = new require(\"dateformat\"); function isPastDate(date){ let today = new Date(); today.setHours(0, 0, 0, 0); date = new Date(date); return date &lt; today; } /** *@param dateString a date of the form \"20190323\" */ function formatDatabaseDate(dateString){ const year = dateString.slice(0,4); const month = dateString.slice(4,6); const day = dateString.slice(6,8); return formatDate(`${year}-${month}-${day}`, \"dS mmm yyyy\") } /** * Gets the date object of the monday of the relative week * @param {Date} date any day of any week * @returns {Date} relative monday date */ function getMondayOfWeek(date){ let offset = date.getDay() === 0 ? -7 : 0; let toReturn = new Date(date.getFullYear(), date.getMonth(), date.getDate()); toReturn.setDate(toReturn.getDate() - toReturn.getDay() + 1 + offset); return toReturn; } function getWeekDays(day){ let monday = getMondayOfWeek(day); monday.setHours(0, 0, 0, 0); let restOfWeek = getNextDates(\"1-D:5\", monday); return [monday].concat(restOfWeek); } function getCurrentWeek(){ let monday = new Date(); monday.setHours(0, 0, 0, 0); monday.setDate(monday.getDate() - monday.getDay() + 1); let restOfWeek = getNextDates(\"1-D:5\", monday); return [monday].concat(restOfWeek); } /** * Gets the dates of the next week. * @param {List[Date]} week list with 5 dates from monday to friday * @returns {List[Date]} The week after from monday to friday */ function getNextWeek(week){ let monday = week[0]; let tuesday = week[1]; let wednesday = week[2]; let thursday = week[3]; let friday = week[4]; let saturday = week[5]; monday.setDate(monday.getDate() + 7); tuesday.setDate(tuesday.getDate() + 7); wednesday.setDate(wednesday.getDate() + 7); thursday.setDate(thursday.getDate() + 7); friday.setDate(friday.getDate() + 7); saturday.setDate(saturday.getDate() + 7); return [monday, tuesday, wednesday, thursday, friday, saturday]; } /** * Gets the dates of the previous week. * @param {List[Date]} week list with 5 dates from monday to friday * @returns {List[Date]} The week before from monday to friday */ function getPreviousWeek(week){ let monday = week[0]; let tuesday = week[1]; let wednesday = week[2]; let thursday = week[3]; let friday = week[4]; let saturday = week[5]; monday.setDate(monday.getDate() - 7); tuesday.setDate(tuesday.getDate() - 7); wednesday.setDate(wednesday.getDate() - 7); thursday.setDate(thursday.getDate() - 7); friday.setDate(friday.getDate() - 7); saturday.setDate(saturday.getDate() - 7); return [monday, tuesday, wednesday, thursday, friday, saturday]; } /** * Get all the next dates based on the frequency notation. * It does NOT return the original date * @param {string} frequency the frequency expressed as frequency notation * @param {Date} startingDate the starting date (not included in the result) * @returns {array&lt;Date&gt;} an array containing the next dates but not the given starting date */ function getNextDates(frequency, startingDate) { const f = frequency.split(':'); if (f.length != 2 || f[1] &lt; 0) { //console.error(\"The frequency format is wrong.\") return []; } const repetitions = parseInt(f[1]); const allDates = []; let date = getNextDate(f[0], startingDate); for (let i = 0; i &lt; repetitions; i++) { allDates.push(date); date = getNextDate(f[0], date); } return allDates; } /** * Get the next date * @example &lt;caption&gt;Example usage of getNextDate with X-D notation.&lt;/caption&gt; * // returns Date object of value 2018-01-04T00:00:00.000Z * getNextDate('3-D', new Date(2018, 0 , 1)); * * @param {string} frequency the frequency in the given format * @param {date} startingDate the starting date from which to calculate the next date */ function getNextDate(frequency, startingDate) { if(!validDate(startingDate)) return null if (frequency === null || frequency.split('-').length &gt; 2 || frequency.split('-').length &lt; 1) { //console.error(\"Error in formatting date. Date is either null or not in the right format\"); return null; } const f_value = parseInt(frequency.split('-')[0]); // the '3' in '3-Y' if (isNaN(f_value) || !stringIsInteger(frequency.split('-')[0])) { //console.error(\"Value must be a number\") return null; } const f_format = frequency.split('-')[1]; // the 'Y' in '2-Y' let date = null; let year = startingDate.getFullYear(); const month = startingDate.getMonth(); let day = startingDate.getDate() switch (f_format) { case 'Y': { year += f_value; date = new Date(year, startingDate.getMonth(), startingDate.getDate()); //month is month_number-1 e.g. Jan is 0 and December is 11 break; } case 'W': { day += (f_value * 7); date = new Date(year, month, day); break; } case 'D': { day += f_value; date = new Date(startingDate.getFullYear(), startingDate.getMonth(), day); break; } default: //console.error(\"Error in formatting date\"); return null; } if (validDate(date)) return date; return null; } /** * Check if date is valid * @param {date} date the date */ function validDate(date) { if (Object.prototype.toString.call(date) === \"[object Date]\") { if (isNaN(date.getTime())) { return false; } else { return true; } } else { return false; } } /** * Check if a date is a holiday in the UK * @param {date} date the date to check */ function isHoliday(date) { hd.isHoliday(date); } /** * Check if given string is an integer * @param {string} str * @returns {boolean} true if string is an integer */ function stringIsInteger(str) { const n = Math.floor(Number(str)); return String(n) === str; } module.exports = { isHoliday, isPastDate, getWeekDays, getNextWeek, getCurrentWeek, getPreviousWeek, getMondayOfWeek, getNextDates, formatDatabaseDate } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_calendar-functions.js.html":{"id":"server_lib_calendar-functions.js.html","title":"Source: server/lib/calendar-functions.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/calendar-functions.js /** * Provides a function that calculates a new due date. * * NB: this controller differs from the one on the client side! * * @module calendar-functions * @author Danilo Del Busso, Luka Kralj * @version 1.0 */ const Holidays = require('date-holidays'); const hd = new Holidays('GB'); /** * Get the next date * @example &lt;caption&gt;Example usage of getNextDate with X-D notation.&lt;/caption&gt; * // returns Date object of value 2018-01-04T00:00:00.000Z * getNextDate('3-D', new Date(2018, 0 , 1)); * * @param {string} frequency the frequency in the given format * @param {date} startingDate the starting date from which to calculate the next date */ function getNextDueDate(frequency, startingDate) { if (typeof startingDate === 'undefined' || frequency === undefined || frequency === null || frequency.split('-').length != 2 || !(startingDate instanceof Date)) { return null; } const f_value = parseInt(frequency.split('-')[0]); // the '3' in '3-Y' if (isNaN(f_value) || !stringIsInteger(frequency.split('-')[0])) { return null; } const f_format = frequency.split('-')[1]; // the 'Y' in '2-Y' const date = startingDate; switch (f_format) { case 'Y': { date.setFullYear(date.getFullYear() + f_value); break; } case 'W': { date.setDate(date.getDate() + f_value * 7); break; } case 'D': { date.setDate(date.getDate() + f_value); break; } default: return null; } while(isHoliday(date) || !isWeekend(date)) { date.setDate(date.getDate() + 1); } return date; } /** * Check if a date is a holiday in the UK * @param {date} date the date to check */ function isHoliday(date) { return hd.isHoliday(date); } /** * Check if the date falls on Saturday or Sunday. * * @param {date} date The date to check. * @returns {boolean} True if date is on weekend, false otherwise. */ function isWeekend(date) { // Sunday -&gt; 0; Saturday -&gt; 6 return date.getDay() === 0 || date.getDay() === 6; } /** * Check if given string is an integer * @param {string} str * @returns {boolean} true if string is an integer */ function stringIsInteger(str) { const n = Math.floor(Number(str)); return String(n) === str; } module.exports = { getNextDueDate } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_src_lib_calendar-functions.js.html":{"id":"client_src_lib_calendar-functions.js.html","title":"Source: client/src/lib/calendar-functions.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/src/lib/calendar-functions.js /** * @module calendar-functions * @author Alessandro Amantini * @version 0.0.2 */ //-----------------Calendar functions--------------------- const DAYS_IN_A_WEEK = 7; /** * Given a month and a year, return the number of days. * @param {integer} year: year * @param {integer} month: month * @return {integer} The number of days in that month for that year */ function getDaysInMonth(year, month) { return new Date(year, month, 0).getDate(); } /** * Given a month and a year return the date of the first day * (Sunday = 0, Monday = 1 etc.) * @param {integer} year: year * @param {integer} month: month * @return {integer} The date of the first day */ function getDateOfFirstDayOf(year, month) { return new Date(year, month-1, 0).getDay(); } /** * Take a date as parameter and generate an array of days so that all the * days from the current month are contained, plus last (prevMonthLastDay - daysFromPrevMonth) * days from the previous month at the beginning of the array, and the * first ones from the next at the bottom to make the array size % (#days in a week) = 0. * @param {integer} daysFromPrevMonth: number of days from the previous month to be put * at the beginning of the array. * @param {integer} prevMonthLastDay: last day of the previous month (eg. January last day = 31). * @param {integer} daysInCurrentMonth: last day of the current month (eg. ) */ function generateCalendarArr(daysFromPrevMonth, prevMonthLastDay, daysInCurrentMonth){ const arrCalendar = []; let whiteCells = 0; //days from the previous month for (let i = 0; i &lt; daysFromPrevMonth; ++i) { arrCalendar.unshift(prevMonthLastDay - i); } //days from current month for (let i = 0; i &lt; daysInCurrentMonth;) { arrCalendar.push(++i); } //remaining cells to be filled in to make (arrCalendar.length % DAYS_IN_A_WEEK) = 0. whiteCells = DAYS_IN_A_WEEK - (arrCalendar.length % DAYS_IN_A_WEEK); //days from next month for (let i = daysInCurrentMonth; whiteCells &gt; 0; ++i) { arrCalendar.push(i - daysInCurrentMonth + 1); whiteCells--; } return arrCalendar; } /** * Given an array and x columns, convert that array * into a matrix of x columns * @param {Object[]} array: array of any types * @param {integer} cols: number of columns in the matrix * @return {Object[Object[]]}: array converted into matrix with * number of columns equal to cols */ function convertArrayIntoMatrix(array, cols){ const rows = array.length / cols; const matrix = []; for (let i = 0; i &lt; rows; ++i) { matrix[i] = new Array(0); for (let j = 0; j &lt; cols; j++) { matrix[i].push(array[cols * i + j]); } } return matrix; } /** * Take a date as parameter and generate an array of arrays * of days so that all the days from the specified year and month * are contained in the matrix. The index of each array can be considered * as the day (0 -&gt; Sunday, 1 -&gt; Monday etc.) and no cell is ever empty, * so in case a month starts from Friday and ends on Monday, the remaining * cells are filled in with, respectively, the last days from the previous * month and the first ones from the next. * @param {Date} date: date to be converted into a matrix * @return {integer[integer[]]}: matrix of all the days from and * surrounding the month. */ function getCalendar(date) { const currentYear = date.getFullYear(); const currentMonth = date.getMonth() + 1; const daysFromPrevMonth = getDateOfFirstDayOf(currentYear, currentMonth); const daysInCurrentMonth = getDaysInMonth(currentYear, currentMonth); const prevMonthLastDay = getDaysInMonth(currentYear, currentMonth - 1); const arrCalendar = generateCalendarArr(daysFromPrevMonth, prevMonthLastDay, daysInCurrentMonth); const calendar = convertArrayIntoMatrix(arrCalendar, DAYS_IN_A_WEEK); return calendar; } //-----------------DayCell component functions--------------------- /** * Return True if the selected date is in the days of the * calendar belonging to the current month * @param {string} selectedDate: the selected day in the form yyyy-(m)m-(d)d * @param {Date} currentDate: the date displayed on the header of the the calendar * @return {boolean} True iff the day appears in the calendar table * and belongs to the current month, otherwise False */ function selectedDayIsFromCurrentMonth(selectedDate, currentDate){ return currentDate.getMonth() === selectedDate.getMonth() &amp;&amp; currentDate.getFullYear() === selectedDate.getFullYear(); } /** * Return True if the selected date is in the days of the * calendar belonging to the previous month * @param {string} selectedDate: the selected day in the form yyyy-(m)m-(d)d * @param {Date} currentDate: the date displayed on the header of the the calendar * @param {integer} day: the number of the day contained in this DayCell * @return {boolean} True iff the day appears in the calendar table * and belongs to the previous month, otherwise False */ function selectedDayIsFromPreviousMonth(selectedDate, currentDate, day){ return currentDate.getMonth() === (selectedDate.getMonth()+1)%12 &amp;&amp; // day &gt; 15 &amp;&amp; ((currentDate.getFullYear() === selectedDate.getFullYear() &amp;&amp; selectedDate.getMonth() !== 11) || (currentDate.getFullYear()-1 === selectedDate.getFullYear() &amp;&amp; selectedDate.getMonth() === 11)); } /** * Return True if the selected date is in the days of the * calendar belonging to the next month * @param {string} selectedDate: the selected day in the form yyyy-(m)m-(d)d * @param {Date} currentDate: the date displayed on the header of the the calendar * @param {integer} day: the number of the day contained in this DayCell * @return {boolean} True iff the day appears in the calendar table * and belongs to the next month, otherwise False */ function selectedDayIsFromNextMonth(selectedDate, currentDate, day){ return (currentDate.getMonth()+1)%12 === selectedDate.getMonth() &amp;&amp; day &lt; 15 &amp;&amp; ((currentDate.getFullYear() === selectedDate.getFullYear() &amp;&amp; selectedDate.getMonth() !== 0) || (currentDate.getFullYear()+1 === selectedDate.getFullYear() &amp;&amp; selectedDate.getMonth() === 0)); } /** * Return True if the day is selected * @param {boolean} isFromThisMonth: the day belongs to * the current month. * @param {string} selectedDay: the selected day in the form yyyy-(m)m-(d)d * @param {Date} currentDate: the date displayed on the header of the the calendar * @param {integer} day: the number of the day contained in this DayCell * @return {boolean} True if the day is selected, False otherwise */ function isSelected(isFromThisMonth, selectedDay, currentDate, day){ const selectedDate = new Date(selectedDay); return selectedDate.getDate() === day &amp;&amp; //current month ((isFromThisMonth &amp;&amp; selectedDayIsFromCurrentMonth(selectedDate, currentDate)) || //adjacent months (!isFromThisMonth &amp;&amp; (selectedDayIsFromPreviousMonth(selectedDate, currentDate, day) || (selectedDayIsFromNextMonth(selectedDate, currentDate, day))))); } module.exports = { isSelected, getCalendar } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_db_controller_db-controller.js.html":{"id":"server_lib_db_controller_db-controller.js.html","title":"Source: server/lib/db_controller/db-controller.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/db_controller/db-controller.js /** * This module enables secure execution of the basic queries. It prevents * deleting any entry that some user might be editing at the moment. * It also prevents editing the entry if someone else is already editing it. * * It does so through token exchange system that gives editing rights to whoever * obtains it. The token only works for a particular entry in the database. * * Additionally, the functions for critical queries deleteQuery, updateQuery and * requestEditing will never be executed synchronously. This is implemented with an * adapted Bakery algorithm. * * @author Luka Kralj * @version 1.0 * * @module db-controller */ module.exports = { selectQuery, insertQuery, deleteQuery, updateQuery, requestEditing, refreshToken, cancelEditing, updateAccessToken, deleteAccessToken }; const mysql = require(\"mysql\"); const tokenGenerator = require(\"./token-generator\"); const dateformat = require(\"dateformat\"); const databaseConfig = require(\"../../config/database\"); const Database = require(\"./Database\"); const logger = require('./../logger') const TOKEN_VALIDITY_MINUTES = 30; // Needed to ensure that critical queries are never executed concurrently. let current = 0; let next = 0; /** * Call this for SELECT queries. * * @param {string} sql The SQL query. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message, if the query was unsuccessful. */ async function selectQuery(sql) { return await nonCriticalQuery(sql, \"select\", async (result) =&gt; { const rows_ = []; for (const key in result) { rows_.push(result[key]); } return { query: \"OK\", rows: rows_ } }); } /** * Call this for INSERT queries. * * @param {string} sql The SQL query. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message, if the query was unsuccessful. */ async function insertQuery(sql) { return await nonCriticalQuery(sql, \"insert\", async (result) =&gt; { return await { query: \"OK\", affectedRows: result.affectedRows, insertId: result.insertId } }) } /** * Call this for DELETE queries. * * @param {string} sql The SQL query. * @param {string} entryTable Name of the table involved in the query. * @param {string} entryID Key of the entry that is being deleted. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message, if the query was unsuccessful. */ async function deleteQuery(sql, entryTable, entryID) { const waitFor = next; next++; while (waitFor != current) { // waiting for the lock... await sleep(1); } if (!startsWith(sql, \"delete\") || entryTable === undefined || entryID === undefined) { current++; throw new Error(\"Invalid use of deleteQuery.\"); } const database = new Database(databaseConfig); let response = undefined; await isValidEntry(database, entryTable, entryID) .then(async (isValid) =&gt; { if (!isValid) { response = await getErrResponse(\"Invalid entry table and entry ID pair.\"); } }) if (response !== undefined) { database.close(); current++; return response; } await editTokensEntryExists(database, entryTable, entryID) .then(async (result) =&gt; { if (result) { response = await getErrResponse(\"Entry is being modified and cannot be deleted.\"); } else { // free to delete response = await getResult(sql, database, async (result) =&gt; { return { query: \"OK\", affectedRows: result.affectedRows }; }); } }); database.close(); current++; return response; } /** * Call this for UPDATE queries. * * @param {string} sql The SQL query. * @param {string} entryTable Name of the table involved in the query. * @param {string} entryID Key of the entry that is being updated. * @param {string} token Token that is used for verifying the edit permissions. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message, if the query was unsuccessful. */ async function updateQuery(sql, entryTable, entryID, token) { const waitFor = next; next++; while (waitFor != current) { // waiting for the lock... await sleep(1); } if (!startsWith(sql, \"update\") || entryTable === undefined || entryID === undefined || token === undefined) { current++; throw new Error(\"Invalid use of updateQuery.\"); } const database = new Database(databaseConfig); let response = undefined; await isValidEntry(database, entryTable, entryID) .then(async (isValid) =&gt; { if (!isValid) { response = await getErrResponse(\"Invalid entry table and entry ID pair.\"); } }) if (response !== undefined) { database.close(); current++; return response; } await editTokensEntryExists(database, entryTable, entryID, token) .then(async (result) =&gt; { if (result) { // Token is valid. Execute query: response = await getResult(sql, database, async (result) =&gt; { return { query: \"OK\", affectedRows: result.affectedRows, changedRows: result.changedRows }; }); } else { response = await getErrResponse(\"Invalid or missing token.\"); } }); if (response.status !== \"OK\") { database.close(); current++; return response; } // delete token let deleteQuery = \"DELETE FROM EditTokens WHERE token = ?\"; deleteQuery = mysql.format(deleteQuery, [token]); await getResult(deleteQuery, database, async (result) =&gt; { if (result.affectedRows != 1) { logger.error(\"ERROR WHEN DELETING A TOKEN (\" + token + \")! Database response: &gt;&gt;\" + JSON.stringify(result) + \"&lt;&lt;.\"); } return result; }); database.close(); current++; return response; } /** * Request editing for the specific entry. * * @param {string} entryTable Table that we want to edit. * @param {string} entryID ID of the entry in that table that we want to edit. * @returns {Promise&lt;JSON&gt;} Response containing the valid token, or error message. */ async function requestEditing(entryTable, entryID) { const waitFor = next; next++; while (waitFor != current) { // waiting for the lock... await sleep(1); } if (entryTable === undefined || entryID === undefined) { current++; throw new Error(\"Invalid use of requestEditing.\"); } const database = new Database(databaseConfig); let response = undefined; await isValidEntry(database, entryTable, entryID) .then(async (isValid) =&gt; { if (!isValid) { response = await getErrResponse(\"Invalid entry table and entry ID pair.\"); } }) if (response !== undefined) { database.close(); current++; return response; } await editTokensEntryExists(database, entryTable, entryID) .then(async (result) =&gt; { if (result) { response = await getErrResponse(\"Entry is being modified and cannot be edited.\"); } else { response = getSuccessfulResponse(null); } }); if (response.status !== \"OK\") { database.close(); current++; return response; } // entry is not being edited, generate token, store it and return it const token_ = tokenGenerator.generateToken(); const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + TOKEN_VALIDITY_MINUTES); const expires = dateformat(nowDate, \"yyyymmddHHMMss\"); const insertQuery = mysql.format(\"INSERT INTO EditTokens VALUES (?, ?, ?, ?)\", [token_, entryTable, entryID, expires]); response = await getResult(insertQuery, database, () =&gt; { return { token: token_, expires: dateformat(nowDate, \"yyyy-mm-dd HH:MM:ss\") }; }); database.close(); current++; return response; } /** * Call this to refresh the current token. This will generate a new token * with a new expiration time. If the token is invalid, an error * message will be returned. * * @param {string} entryTable Name of the table that we are editing. * @param {string} entryID Key of the entry that we are editing * @param {string} token Token that is used for verifying the edit permissions. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message. */ async function refreshToken(entryTable, entryID, token) { if (entryTable === undefined || entryID === undefined || token === undefined) { throw new Error(\"Invalid use of refreshToken.\"); } const database = new Database(databaseConfig); let response = undefined; await editTokensEntryExists(database, entryTable, entryID, token) .then(async (result) =&gt; { if (result) { // Token is valid. Update it. const sql = mysql.format(\"DELETE FROM EditTokens WHERE token = ?\", [token]); await getResult(sql, database, (result) =&gt; { return result; }); const token_ = tokenGenerator.generateToken(); const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + TOKEN_VALIDITY_MINUTES); const expires = dateformat(nowDate, \"yyyymmddHHMMss\"); const insertQuery = mysql.format(\"INSERT INTO EditTokens VALUES (?, ?, ?, ?)\", [token_, entryTable, entryID, expires]); response = await getResult(insertQuery, database, () =&gt; { return { token: token_, expires: dateformat(nowDate, \"yyyy-mm-dd HH:MM:ss\") }; }); } else { response = await getErrResponse(\"Invalid token.\"); } }); database.close(); return response; } /** * Call this to delete the current token. This will allow other users * to edit this entry. If the token is invalid, an error * message will be returned. * * @param {string} entryTable Name of the table that we are editing. * @param {string} entryID Key of the entry that we are editing * @param {string} token Token that is used for verifying the edit permissions. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message. */ async function cancelEditing(entryTable, entryID, token) { if (entryTable === undefined || entryID === undefined || token === undefined) { throw new Error(\"Invalid use of cancelEditing.\"); } const database = new Database(databaseConfig); let response = undefined; await editTokensEntryExists(database, entryTable, entryID, token) .then(async (result) =&gt; { if (result) { // Token is valid. Delete it. const sql = mysql.format(\"DELETE FROM EditTokens WHERE token = ?\", [token]); await getResult(sql, database, (result) =&gt; { return result; }); response = getSuccessfulResponse(\"Editing successfully cancelled.\") } else { response = await getErrResponse(\"Invalid token.\"); } }); database.close(); return response; } /** * Updates the expiration of an access token specified. * * @param {string} accessToken - Access token we are editing. * @param {Date} newExpiration New expiration for this token. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message. */ async function updateAccessToken(accessToken, newExpiration) { let sql = \"UPDATE AccessTokens SET expiration = ? WHERE token = ?\"; sql = mysql.format(sql, [dateformat(newExpiration, \"yyyymmddHHMMss\"), accessToken]); const database = new Database(databaseConfig); const res = await getResult(sql, database, () =&gt; { return {status:\"OK\"}; }); database.close(); if (res.status !== \"OK\") { logger.error(\"Could not update access token expiration in the DB.\"); } return res; } /** * Deletes the access token specified. * * @param {string} accessToken - Access token we are editing. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message. */ async function deleteAccessToken(accessToken) { let sql = \"DELETE FROM AccessTokens WHERE token = ?\"; sql = mysql.format(sql, [accessToken]); const database = new Database(databaseConfig); const res = await getResult(sql, database, () =&gt; { return {status:\"OK\"}; }); database.close(); if (res.status !== \"OK\") { logger.error(\"Could not delete access token in the DB.\"); } return res; } //===================================== // HELPER FUNCTIONS BELOW: //===================================== /** * A helper function for insertQuery and selectQuery. * * @param {string} sql The SQL query. * @param {string} type \"select\" or \"insert\" * @param {function} treatResponse This function is called to format the query response, if * the query was successful. * @returns {Promise&lt;JSON&gt;} JSON object that contains response data or error message, if the query was unsuccessful. */ async function nonCriticalQuery(sql, type, treatResponse) { if (!startsWith(sql, type)) { throw new Error(\"Invalid use of \" + type + \"Query.\"); } const database = new Database(databaseConfig); const response = await getResult(sql, database, treatResponse); database.close(); return response; } /** * Helper function that executes the query. * * @param {string} sql Query to execute. * @param {Database} database Database object to execute the query on. * @param {function} treatResponse Decide how the response of a successful query is modified. * @returns {JSON} Result of the query or error response, if query unsuccessful. */ async function getResult(sql, database, treatResponse) { let result = undefined; try { result = await database.query(sql); } catch(err) { const errResponse = await getSQLErrorResponse(err); return errResponse; } const treated = await treatResponse(result); return await getSuccessfulResponse(treated); } /** * Generate a JSON error response. * * @param {string} cause * @returns {JSON} Error response. */ function getErrResponse(cause_) { return { status: \"ERR\", err: { type: \"Invalid request.\", cause: cause_ } }; } /** * Formats the error response to give some information about the query error * (type, code, error number, SQL message). * * @param {Error} err Error thrown by the database query function. * @returns {JSON} Formatted error response. */ function getSQLErrorResponse(err) { return { status: \"ERR\", err: { type: \"SQL Error\", code: err.code, errno: err.errno, sqlMessage: err.sqlMessage } }; } /** * Formats a successful response. Enables all responses to follow the same format. * * @param {JSON} response Preformatted query-specific response. * @returns {JSON} A formatted response. */ function getSuccessfulResponse(response_) { return { status: \"OK\", response: response_ } } /** * Shorthand function for comparing the start of a string. Leading spaces * and capitalisation are ignored. * * @param {string} toCheck A string the start of which we want to check. * @param {string} compareTo A string that should appear at the start of the toCheck. * @returns {boolean} True if toCheck starts with compareTo, false otherwise. */ function startsWith(toCheck, compareTo) { return toCheck.trim().toLowerCase().startsWith(compareTo.toLowerCase()); } /** * Check if the entry with the given parameters exists in the EditTokens table. * * @param {Database} database * @param {string} entryTable * @param {string} entryID * @param {string} token * @returns {Promise&lt;boolean&gt;} True if such entry exists, false if not. */ async function editTokensEntryExists(database, entryTable, entryID, token) { if (database === undefined || entryTable === undefined || entryID === undefined) { return await Promise.reject(\"Invalid use of entryExists.\"); } let tokenQuery = \"SELECT * FROM EditTokens \" tokenQuery += \"WHERE table_name = ? AND table_key = ?\"; const options = [entryTable, entryID]; if (token !== undefined) { tokenQuery += \" AND token = ?\"; options.push(token); } tokenQuery = mysql.format(tokenQuery, options); const queryResult = await getResult(tokenQuery, database, async (result) =&gt; { if (result.length == 1) { const expires = new Date(result[0].expiration); if ((expires - new Date()) &lt;= 0) { // Token has expired. let delQuery = \"DELETE FROM EditTokens \" delQuery += \"WHERE table_name = ? AND table_key = ?\"; const options = [entryTable, entryID]; if (token !== undefined) { delQuery += \" AND token = ?\"; options.push(token); } delQuery = mysql.format(delQuery, options); await getResult(delQuery, database, async (result) =&gt; { if (result.affectedRows != 1) { logger.error(\"ERROR WHEN DELETING A TOKEN (\" + entryTable + \", \" + entryID + \")! Database response: &gt;&gt;\" + JSON.stringify(result) + \"&lt;&lt;.\"); } return result; }); return false; } else { return true; } } else { return false; } }); if (queryResult.status !== \"OK\") { return false; } return queryResult.response; } /** * Checks if the table name and table ID pair actually represent some * valid database entry. * * @param {Database} database * @param {string} entryTable * @param {string} entryID * @returns {Promise&lt;boolean&gt;} True if entry exists, false if not. */ async function isValidEntry(database, entryTable, entryID) { let primaryKey = undefined; switch(entryTable) { case \"Hospital\": primaryKey = \"hospital_id\"; break; case \"Patient\": primaryKey = \"patient_no\"; break; case \"Carer\": primaryKey = \"carer_id\"; break; case \"Test\": primaryKey = \"test_id\"; break; case \"User\": primaryKey = \"username\"; break; } if (primaryKey === undefined) { return false; } let sql = \"SELECT * FROM \" + entryTable + \" WHERE \" + primaryKey + \" = ?\"; sql = mysql.format(sql, [entryID]); const response = await getResult(sql, database, (result) =&gt; { if (result.length &gt; 0) { return true; } else { return false; } }); return response.response; } /** * Await for this function to pause execution for a certain time. * * @param {number} ms Time in milliseconds * @returns {Promise} */ function sleep(ms){ return new Promise((resolve) =&gt; { setTimeout(resolve,ms); }); } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_test_integration_lib_db_controller_db-controller-test.js.html":{"id":"server_test_integration_lib_db_controller_db-controller-test.js.html","title":"Source: server/test/integration/lib/db_controller/db-controller-test.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/test/integration/lib/db_controller/db-controller-test.js /** * This file contains tests that test the behaviour of * main DB controller. * * @author Luka Kralj * @version 1.0 * * @module db_controller_test * @see module:db_controller */ const expect = require(\"chai\").expect; const db_controller = require(\"../../../../lib/db_controller/db-controller\"); // These are needed for setting up a testing environment. const databaseConfig = require(\"../../../../config/database\"); const Database = require(\"../../../../lib/db_controller/Database\"); const dateFormat = require(\"dateformat\"); describe(\"Test main DB controller behaviour:\", () =&gt; { describe(\"Test selectQuery() function:\", () =&gt; { // Setup environment. let test_hos_id = 0; before(async () =&gt; { const database = new Database(databaseConfig); await database.query(\"INSERT INTO Hospital (hospital_name, hospital_email) VALUES ('Test Lab 123_S', 'test@email')\") .then((result) =&gt; { test_hos_id = result.insertId; }) .catch((err) =&gt; { printSetupError(err); }); await database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname, hospital_id) \" + \"VALUES ('test_no_S', 'testName', 'testSurname', '\" + test_hos_id + \"')\") .catch((err) =&gt; { printSetupError(err); }); await database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_S2', 'testName2', 'testSurname2')\") .catch((err) =&gt; { printSetupError(err); }); const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); await database.query(\"INSERT INTO EditTokens \" + \"VALUES ('test_token_S', 'Patient', 'test_no_S2', \" + expires + \")\") .catch((err) =&gt; { printSetupError(err); }); await database.close(); }); describe(\"&gt; Select single entry, valid SQL\", () =&gt; { it(\"Should return one correct entry.\", (done) =&gt; { const sql = \"SELECT * FROM Patient WHERE patient_no = 'test_no_S'\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.rows.length).to.equal(1); expect(result.response.rows[0].patient_no).to.equal(\"test_no_S\"); expect(result.response.rows[0].patient_name).to.equal(\"testName\"); expect(result.response.rows[0].patient_surname).to.equal(\"testSurname\"); expect(result.response.rows[0].hospital_id).to.equal(test_hos_id); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Select single entry, invalid SQL\", () =&gt; { it(\"Should return an error message.\", (done) =&gt; { const sql = \"SELECT * FROM invalidTable\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Attempt to execute multiple queries at once\", () =&gt; { it(\"Should return an error message.\", (done) =&gt; { const sql = \"SELECT * FROM Patient WHERE patient_no = 'test_no_S'; \" + \"SELECT * FROM Patient WHERE patient_no = 'test_no_S'\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Select with a join Patient-Hospital\", () =&gt; { it(\"Should return one entry.\", (done) =&gt; { const sql = \"SELECT * FROM Patient NATURAL JOIN Hospital \" + \"WHERE patient_no = 'test_no_S'\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.rows.length).to.equal(1); expect(result.response.rows[0].patient_no).to.equal(\"test_no_S\"); expect(result.response.rows[0].patient_name).to.equal(\"testName\"); expect(result.response.rows[0].patient_surname).to.equal(\"testSurname\"); expect(result.response.rows[0].hospital_id).to.equal(test_hos_id); expect(result.response.rows[0].hospital_name).to.equal(\"Test Lab 123_S\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Select with a join Patient-Hospital, but invalid SQL\", () =&gt; { it(\"Should return an error message.\", (done) =&gt; { const sql = \"SELECT * FROM Patient NATURAL JOIN Hospital \" + \"WHERE patient_no = 'test_no_S' invalid\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Select multiple entries, valid SQL\", () =&gt; { it(\"Should return a list of correct entries.\", (done) =&gt; { const sql = \"SELECT * FROM Patient WHERE patient_no = 'test_no_S' OR patient_no = 'test_no_S2'\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.rows.length).to.equal(2); expect(result.response.rows[0].patient_no).to.equal(\"test_no_S\"); expect(result.response.rows[0].patient_name).to.equal(\"testName\"); expect(result.response.rows[0].patient_surname).to.equal(\"testSurname\"); expect(result.response.rows[0].hospital_id).to.equal(test_hos_id); expect(result.response.rows[1].patient_no).to.equal(\"test_no_S2\"); expect(result.response.rows[1].patient_name).to.equal(\"testName2\"); expect(result.response.rows[1].patient_surname).to.equal(\"testSurname2\"); expect(result.response.rows[1].hospital_id).to.equal(null); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Select multiple entries, invalid SQL\", () =&gt; { it(\"Should return an error message.\", (done) =&gt; { const sql = \"SELECT * FROM Patient WHERE patient_no = 'test_no_S' OR patient_no == 'test_no_S2'\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Select entry that is being edited\", () =&gt; { it(\"Should return a correct entry.\", (done) =&gt; { const sql = \"SELECT * FROM Patient WHERE patient_no = 'test_no_S2'\"; db_controller.selectQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.rows.length).to.equal(1); expect(result.response.rows[0].patient_no).to.equal(\"test_no_S2\"); expect(result.response.rows[0].patient_name).to.equal(\"testName2\"); expect(result.response.rows[0].patient_surname).to.equal(\"testSurname2\"); expect(result.response.rows[0].hospital_id).to.equal(null); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); after(async () =&gt; { const database = new Database(databaseConfig); await database.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_S' OR patient_no = 'test_no_S2'\") .catch((err) =&gt; { printSetupError(err); }); await database.query(\"DELETE FROM Hospital WHERE hospital_id = \" + test_hos_id) .catch((err) =&gt; { printSetupError(err); }); await database.query(\"DELETE FROM EditTokens WHERE token = 'test_token_S'\") .catch((err) =&gt; { printSetupError(err); }); await database.close(); }); }); describe(\"Test insertQuery() function:\", () =&gt; { describe(\"&gt; Insert one entry, valid SQL\", () =&gt; { it(\"Should return no errors.\", (done) =&gt; { const sql = \"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_I', 'testName_I', 'testSurname_I')\"; db_controller.insertQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.affectedRows).to.equal(1); expect(result.response.insertId).to.equal(0); // because not auto_increment primary key }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { // clean entry const database = new Database(databaseConfig); database.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_I'\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); }); }); describe(\"&gt; Insert one entry, invalid SQL\", () =&gt; { it(\"Should return an error message.\", (done) =&gt; { const sql = \"INSERT INTO Patient \" + \"(patient_no, patient_nam, patient_surname) \" + // wrong spelling on purpose \"VALUES ('test_no_I2', 'testName_I', 'testSurname_I')\"; db_controller.insertQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { // clean entry const database = new Database(databaseConfig); database.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_I2'\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); }); }); describe(\"&gt; Insert same entry twice\", () =&gt; { it(\"Should return an error message.\", (done) =&gt; { const sql = \"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_I', 'testName_I', 'testSurname_I')\"; let error = undefined; db_controller.insertQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.affectedRows).to.equal(1); expect(result.response.insertId).to.equal(0); // because not auto_increment primary key }) .then(() =&gt; { db_controller.insertQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { // clean entry const database = new Database(databaseConfig); database.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_I'\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { if (error) done(error); else done(); }); }); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Insert multiple entries, valid SQL\", () =&gt; { it(\"Should return no errors.\", (done) =&gt; { const sql = \"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_I3', 'testName_I3', 'testSurname_I3'), \" + \"('test_no_I4', 'testName_I4', 'testSurname_I4')\"; db_controller.insertQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.affectedRows).to.equal(2); expect(result.response.insertId).to.equal(0); // because not auto_increment primary key }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { // clean entry const database = new Database(databaseConfig); database.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_I3' OR patient_no = 'test_no_I4'\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); }); }); describe(\"&gt; Insert multiple entries, invalid SQL\", () =&gt; { it(\"Should return an error message.\", (done) =&gt; { const sql = \"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_I3', 'testName_I3', 'testSurname_I3') \" + // missing comma on purpose \"('test_no_I4', 'testName_I4', 'testSurname_I4')\"; db_controller.insertQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { // clean entry const database = new Database(databaseConfig); database.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_I3' OR patient_no = 'test_no_I4'\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); }); }); describe(\"&gt; Insert query with auto-incremented primary key\", () =&gt; { it(\"Should return a valid primary key\", (done) =&gt; { const sql = \"INSERT INTO Hospital (hospital_name, hospital_email) \" + \"VALUES ('Test_lab_INS', 'test@email')\"; let insId = 0; db_controller.insertQuery(sql) .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.affectedRows).to.equal(1); expect(result.response.insertId).to.not.equal(0); insId = result.response.insertId; }) .then(() =&gt; { const database = new Database(databaseConfig); database.query(\"SELECT * FROM Hospital WHERE hospital_id = \" + insId) .then((result) =&gt; { expect(result.length).to.equal(1); expect(result[0].hospital_name).to.equal(\"Test_lab_INS\"); }) .then(() =&gt; { database.close(); done(); }) .catch((err) =&gt; { database.close(); done(err); }) }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { // clean entry const database = new Database(databaseConfig); database.query(\"DELETE FROM Hospital WHERE hospital_id = \" + insId) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }); }); }); }); }); describe(\"Test deleteQuery() function:\", () =&gt; { describe(\"&gt; Delete single entry, valid arguments, valid SQL\", () =&gt; { it(\"Should return no error.\", (done) =&gt; { const sql = \"DELETE FROM Patient WHERE patient_no = 'test_no_D'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_D', 'testNameD', 'testSurnameD')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.deleteQuery(sql, \"Patient\", \"test_no_D\") .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.affectedRows).to.equal(1); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(sql).catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Delete single entry, invalid arguments, valid SQL\", () =&gt; { it(\"Should reject the request.\", (done) =&gt; { const sql = \"DELETE FROM Patient WHERE patient_no = 'test_no_D2'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_D2', 'testNameD', 'testSurnameD')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.deleteQuery(sql, \"invalid\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(sql).catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Delete single entry, valid arguments, invalid SQL\", () =&gt; { it(\"Should return an SQL error message.\", (done) =&gt; { const sql = \"DELETE FROM Patient WHERE invalid = 'test_no_D3'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_D3', 'testNameD', 'testSurnameD')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.deleteQuery(sql, \"Patient\", \"test_no_D3\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_D3'\").catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Delete single entry, invalid arguments, invalid SQL\", () =&gt; { it(\"Should reject the request.\", (done) =&gt; { const sql = \"DELETE FROM Patient WHERE invalid = 'test_no_D4'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_D4', 'testNameD', 'testSurnameD')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.deleteQuery(sql, \"Patient\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_D4'\").catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Attempt to delete entry that is being edited\", () =&gt; { it(\"Should reject the request.\", (done) =&gt; { const sql = \"DELETE FROM Patient WHERE patient_no = 'test_no_D5'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_D5', 'testNameD', 'testSurnameD')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('test_token_D', 'Patient', 'test_no_D5', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.deleteQuery(sql, \"Patient\", \"test_no_D5\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(sql) .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE token = 'test_token_D'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Attempt to delete entry that is being edited, but the token has expired\", () =&gt; { it(\"Should return no error.\", (done) =&gt; { const sql = \"DELETE FROM Patient WHERE patient_no = 'test_no_D6'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_D6', 'testNameD', 'testSurnameD')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setSeconds(nowDate.getSeconds() - 1); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('test_tokenD', 'Patient', 'test_no_D6', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.deleteQuery(sql, \"Patient\", \"test_no_D6\") .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.affectedRows).to.equal(1); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(sql) .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE token = 'test_tokenD'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); }); describe(\"Test updateQuery() function:\", () =&gt; { describe(\"&gt; Update single entry, valid arguments, valid SQL\", () =&gt; { it(\"Should return no error message.\", (done) =&gt; { const sql = \"UPDATE Patient SET patient_name = 'U1 - updated' WHERE patient_no = 'testNo_U1'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('testNo_U1', 'testName', 'testSurname')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('test_token_U1', 'Patient', 'testNo_U1', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.updateQuery(sql, \"Patient\", \"testNo_U1\", \"test_token_U1\") .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response.query).to.equal(\"OK\"); expect(result.response.affectedRows).to.equal(1); expect(result.response.changedRows).to.equal(1); }) .then(() =&gt; { const database2 = new Database(databaseConfig); database2.query(\"SELECT * FROM Patient WHERE patient_no = 'testNo_U1'\") .then((result) =&gt; { expect(result.length).to.equal(1); expect(result[0].patient_name).to.equal(\"U1 - updated\"); }) .then(() =&gt; { database2.query(\"SELECT * FROM EditTokens WHERE token = 'test_token_U1'\") .then((result) =&gt; { expect(result.length).to.equal(0); done(); }) .catch((err) =&gt; { done(err); }); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { database2.close(); }); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'testNo_U1'\") .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE token = 'test_token_U1'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Update single entry, valid arguments, invalid SQL\", () =&gt; { it(\"Should return SQL error message.\", (done) =&gt; { const sql = \"UPDATE Patient SET patient_name = invalid WHERE patient_no = 'testNo_U2'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('testNo_U2', 'testName', 'testSurname')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('test_token_U2', 'Patient', 'testNo_U2', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.updateQuery(sql, \"Patient\", \"testNo_U2\", \"test_token_U2\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"SQL Error\"); done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'testNo_U2'\") .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE token = 'test_token_U2'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Update single entry, invalid arguments, valid SQL\", () =&gt; { it(\"Should reject the request.\", (done) =&gt; { const sql = \"UPDATE Patient SET patient_name = 'U3 - updated' WHERE patient_no = 'testNo_U3'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('testNo_U3', 'testName', 'testSurname')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setSeconds(nowDate.getSeconds() - 1); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('test_token_U3', 'Patient', 'testNo_U3', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.updateQuery(sql, \"Patient\", \"testNo_U3\", \"test_token_U3\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'testNo_U3'\") .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE token = 'test_token_U3'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); describe(\"&gt; Update single entry, invalid arguments, invalid SQL\", () =&gt; { it(\"Should reject the request.\", (done) =&gt; { const sql = \"UPDATE Patient invalid patient_name = 'U3 - updated' WHERE patient_no = 'testNo_U4'\"; // prepare environment const database = new Database(databaseConfig); database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('testNo_U4', 'testName', 'testSurname')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setSeconds(nowDate.getSeconds() + 30); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('test_token_U4', 'Patient', 'testNo_U4', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.updateQuery(sql, \"invalid\", \"testNo_U4\", \"test_token_U4\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); done(); }) .catch((err) =&gt; { done(err); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'testNo_U4'\") .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE token = 'test_token_U4'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }); }); }); }); }); describe(\"Test requestEditing() function:\", () =&gt; { describe(\"&gt; Request on entry that does not exist\", () =&gt; { // Similar tests to ensure code coverage it(\"Should reject the request.\", (done) =&gt; { db_controller.requestEditing(\"Test\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); it(\"Should reject the request.\", (done) =&gt; { db_controller.requestEditing(\"Hospital\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); it(\"Should reject the request.\", (done) =&gt; { db_controller.requestEditing(\"Carer\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); it(\"Should reject the request.\", (done) =&gt; { db_controller.requestEditing(\"User\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); it(\"Should reject the request.\", (done) =&gt; { db_controller.requestEditing(\"Patient\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); it(\"Should reject the request.\", (done) =&gt; { db_controller.requestEditing(\"invalid\", \"invalid\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Request on a valid entry\", () =&gt; { it(\"Should return a token with correct validity\", (done) =&gt; { const database = new Database(databaseConfig); let error = undefined; database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_R', 'testName', 'testSurname')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.requestEditing(\"Patient\", \"test_no_R\") .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const shouldExpire = dateFormat(nowDate, \"yyyymmddHHMM\"); const tokenExpire = new Date(result.response.expires); const actualExpire = dateFormat(tokenExpire, \"yyyymmddHHMM\"); expect(actualExpire).to.equal(shouldExpire); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_R'\") .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE table_key = 'test_no_R'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }) .then(() =&gt; { if (error) done(error); else done(); }); }); }); }); describe(\"&gt; Request on a valid entry that is being edited\", () =&gt; { it(\"Should reject the request\", (done) =&gt; { const database = new Database(databaseConfig); let error = undefined; database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_R1', 'testName', 'testSurname')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('token_R', 'Patient', 'test_no_R1', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.requestEditing(\"Patient\", \"test_no_R1\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .catch((err) =&gt; { error = err; }); }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_R1'\") .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE token = 'token_R'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }) .then(() =&gt; { if (error) done(error); else done(); }); }); }); describe(\"&gt; Request on a valid entry with expired token\", () =&gt; { it(\"Should return a token with correct validity, previous token should be deleted.\", (done) =&gt; { const database = new Database(databaseConfig); let error = undefined; database.query(\"INSERT INTO Patient \" + \"(patient_no, patient_name, patient_surname) \" + \"VALUES ('test_no_R2', 'testName', 'testSurname')\") .then(() =&gt; { const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() - 30); const expires = dateFormat(nowDate, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('token_R2', 'Patient', 'test_no_R2', \" + expires + \")\") }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); }) .then(() =&gt; { db_controller.requestEditing(\"Patient\", \"test_no_R2\") .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const shouldExpire = dateFormat(nowDate, \"yyyymmddHHMM\"); const tokenExpire = new Date(result.response.expires); const actualExpire = dateFormat(tokenExpire, \"yyyymmddHHMM\"); expect(actualExpire).to.equal(shouldExpire); }) .then(() =&gt; { // previous token should be deleted const database2 = new Database(databaseConfig); database2.query(\"SELECT * FROM EditTokens WHERE token = 'token_R2'\") .then((result) =&gt; { expect(result.length).to.equal(0); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { database2.close(); }); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { const database1 = new Database(databaseConfig); database1.query(\"DELETE FROM Patient WHERE patient_no = 'test_no_R2'\") .then(() =&gt; { database1.query(\"DELETE FROM EditTokens WHERE table_key = 'test_no_R2'\") .catch((err) =&gt; { printSetupError(err); }); }) .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database1.close(); }); }) .then(() =&gt; { if (error) done(error); else done(); }); }); }); }); }); describe(\"Test refreshToken() function:\", () =&gt; { describe(\"&gt; Refresh an invalid token\", () =&gt; { it(\"Should return an error message.\" , (done) =&gt; { db_controller.refreshToken(\"Patient\", \"1\", \"invalid token\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Refresh a valid token\", () =&gt; { it(\"Should return a new token.\" , (done) =&gt; { const database = new Database(databaseConfig); const date = new Date(); date.setMinutes(date.getMinutes() + 10); const expires = dateFormat(date, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('ref_token', 'Patient', 'rand_id', '\" + expires + \"')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); let error = undefined; db_controller.refreshToken(\"Patient\", \"rand_id\", \"ref_token\") .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); const nowDate = new Date(); nowDate.setMinutes(nowDate.getMinutes() + 30); const shouldExpire = dateFormat(nowDate, \"yyyymmddHHMM\"); const tokenExpire = new Date(result.response.expires); const actualExpire = dateFormat(tokenExpire, \"yyyymmddHHMM\"); expect(actualExpire).to.equal(shouldExpire); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { // check if previous token has been deleted const database1 = new Database(databaseConfig); database1.query(\"SELECT * FROM EditTokens WHERE table_name = 'Patient' AND table_key = 'rand_id'\") .then((result) =&gt; { expect(result.length).to.equal(1); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { // clean DB database1.query(\"DELETE FROM EditTokens WHERE table_name = 'Patient' AND table_key = 'rand_id'\") .catch((err) =&gt; { error = err; }).then(() =&gt; { database1.close(); if (error) done(error); else done(); }); }); }); }); }); }); describe(\"&gt; Refresh an expired token\", () =&gt; { it(\"Should return an error message.\" , (done) =&gt; { const database = new Database(databaseConfig); const date = new Date(); date.setMinutes(date.getMinutes() - 10); const expires = dateFormat(date, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('ref2_token', 'Patient', 'rand_id2', '\" + expires + \"')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); let error = undefined; db_controller.refreshToken(\"Patient\", \"rand_id2\", \"ref2_token\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { // check if previous token has been deleted const database1 = new Database(databaseConfig); database1.query(\"SELECT * FROM EditTokens WHERE table_name = 'Patient' AND table_key = 'rand_id2'\") .then((result) =&gt; { expect(result.length).to.equal(0); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { // clean DB database1.query(\"DELETE FROM EditTokens WHERE table_name = 'Patient' AND table_key = 'rand_id2'\") .catch((err) =&gt; { error = err; }).then(() =&gt; { database1.close(); if (error) done(error); else done(); }); }); }); }); }); }); }); describe(\"Test cancelEditing() function:\", () =&gt; { describe(\"&gt; Cancel with an invalid token\", () =&gt; { it(\"Should return an error message.\" , (done) =&gt; { db_controller.cancelEditing(\"Patient\", \"1\", \"invalid token\") .then((result) =&gt; { expect(result.status).to.equal(\"ERR\"); expect(result.err.type).to.equal(\"Invalid request.\"); }) .then(() =&gt; { done(); }) .catch((err) =&gt; { done(err); }); }); }); describe(\"&gt; Cancel with a valid token\", () =&gt; { it(\"Should delete that token.\" , (done) =&gt; { const database = new Database(databaseConfig); const date = new Date(); date.setMinutes(date.getMinutes() + 10); const expires = dateFormat(date, \"yyyymmddHHMMss\"); database.query(\"INSERT INTO EditTokens VALUES \" + \"('ref3_token', 'Patient', 'rand_id3', '\" + expires + \"')\") .catch((err) =&gt; { printSetupError(err); }) .then(() =&gt; { database.close(); let error = undefined; db_controller.cancelEditing(\"Patient\", \"rand_id3\", \"ref3_token\") .then((result) =&gt; { expect(result.status).to.equal(\"OK\"); expect(result.response).to.equal(\"Editing successfully cancelled.\"); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { // check if previous token has been deleted const database1 = new Database(databaseConfig); database1.query(\"SELECT * FROM EditTokens WHERE table_name = 'Patient' AND table_key = 'rand_id3'\") .then((result) =&gt; { expect(result.length).to.equal(0); }) .catch((err) =&gt; { error = err; }) .then(() =&gt; { // clean DB database1.query(\"DELETE FROM EditTokens WHERE table_name = 'Patient' AND table_key = 'rand_id3'\") .catch((err) =&gt; { error = err; }).then(() =&gt; { database1.close(); if (error) done(error); else done(); }); }); }); }); }); }); }); describe(\"Test improper use of query functions:\", () =&gt; { describe(\"&gt; Improper use of selectQuery\", () =&gt; { it(\"Should throw an Error\", (done) =&gt; { const sql = \"updAte ...\"; db_controller.selectQuery(sql) .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); }); describe(\"&gt; Improper use of insertQuery\", () =&gt; { it(\"Should throw an Error\", (done) =&gt; { const sql = \" SELECT ...\"; db_controller.insertQuery(sql) .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); }); describe(\"&gt; Improper use of deleteQuery\", () =&gt; { it(\"Should throw an Error\", (done) =&gt; { const sql = \"SELECT ...\"; db_controller.deleteQuery(sql, 'Patient', 'id') .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); it(\"Should throw an Error\", (done) =&gt; { const sql = \"DELETE ...\"; db_controller.deleteQuery(sql, 'Test') .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); }); describe(\"&gt; Improper use of updateQuery\", () =&gt; { it(\"Should throw an Error\", (done) =&gt; { const sql = \"SELECT ...\"; db_controller.updateQuery(sql, \"Patient\", \"id\", \"token\") .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); it(\"Should throw an Error\", (done) =&gt; { const sql = \"UPDATE ...\"; db_controller.updateQuery(sql, \"Patient\", \"id\") .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); }); describe(\"&gt; Improper use of requestEditing\", () =&gt; { it(\"Should throw an Error\", (done) =&gt; { db_controller.requestEditing('Patient') .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); }); describe(\"&gt; Improper use of refreshToken\", () =&gt; { it(\"Should throw an Error\", (done) =&gt; { db_controller.refreshToken('Patient', \"entry\") .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); }); describe(\"&gt; Improper use of cancelEditing\", () =&gt; { it(\"Should throw an Error\", (done) =&gt; { db_controller.cancelEditing('Patient', \"entry\") .then(() =&gt; { done(new Error(\"Did not throw an error for improper use.\")) }) .catch(() =&gt; { done(); }); }); }); }); }); /** * Prints an error that occurred during setting up the testing * environment in a nice format. * * @param {Error} err Error that occurred. */ function printSetupError(err) { console.log(\"=======================================\"); console.log(\"Error setting up testing environment:\\n\" + err); console.log(\"=======================================\"); } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_email_email-controller.js.html":{"id":"server_lib_email_email-controller.js.html","title":"Source: server/lib/email/email-controller.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/email/email-controller.js /** * This module processes mailing requests and organises the data that * is then used in email sender. It also updates the DB accordingly. * * @author Luka Kralj * @version 1.0 * @module email-controller */ module.exports = { sendOverdueReminders, sendNormalReminders, recoverPassword } const query_controller = require('./../query-controller'); const email_sender = require('./email-sender'); const authenticator = require('./../authenticator.js'); const crypto = require(\"crypto\"); const logger = require('./../logger'); const dateformat = require('dateformat'); /** * Send reminders for overdue tests. * * @param {Array} testIDs - List of all the overdue tests' IDs * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query. success is true only if all the emails were successfully sent. * Some emails might fail to be sent for various reasons. It can be that the patient was sent * an email but the hospital was not or vice versa, or maybe both emails failed to send. * Response format: * {success: true, response: \"All emails sent successfully.\"} * * The three \"failed\" lists are disjoint. * {success: false, * response: { * failedBoth: [] // might be empty * failedPatient: [] // might be empty * failedHospital: [] // might be empty * } * } **/ async function sendOverdueReminders(testIDs, actionUsername) { return await send(testIDs, actionUsername, email_sender.sendOverdueReminderToPatient, email_sender.sendOverdueReminderToHospital, true); } /** * Send reminders for tests (not overdue). * * @param {Array} testIDs - List of all the overdue tests' IDs * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query. success is true only if all the emails were successfully sent. * Some emails might fail to be sent for various reasons. It can be that the patient was sent * an email but the hospital was not or vice versa, or maybe both emails failed to send. * Response format: * {success: true, response: \"All emails sent successfully.\"} * * The three \"failed\" lists are disjoint. * {success: false, * response: { * failedBoth: [] // might be empty * failedPatient: [] // might be empty * failedHospital: [] // might be empty * } * } **/ async function sendNormalReminders(testIDs, actionUsername) { return await send(testIDs, actionUsername, email_sender.sendReminderToPatient, email_sender.sendReminderToHospital, false); } /** * Send reminders for overdue tests. * * @param {Array} testIDs - List of all the overdue tests' IDs * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query. success is true only if all the emails were successfully sent. * Some emails might fail to be sent for various reasons. It can be that the patient was sent * an email but the hospital was not or vice versa, or maybe both emails failed to send. * Response format: * {success: true, response: \"All emails sent successfully.\"} * * The three \"failed\" lists are disjoint. * {success: false, * response: { * failedBoth: [] // might be empty * failedPatient: [] // might be empty * failedHospital: [] // might be empty * } * } **/ async function send(testIDs, actionUsername, patientFunction, hospitalFunction, isOvedue) { const failedBoth = []; const failedPatient = []; const failedHospital = []; for (let i = 0; i &lt; testIDs.length; i++) { const token = await query_controller.requestEditing(\"Test\", testIDs[i], actionUsername); if (!token) { failedBoth.push(testIDs[i]); continue; } let test = null; let patient = null; let hospital = null; let carer = null; try { test = (await query_controller.getTest(testIDs[i])).response[0]; patient = (await query_controller.getPatient(test.patient_no)).response[0]; hospital = null; carer = null; if (patient.carer_id !== null) { carer = (await query_controller.getCarer(patient.carer_id)).response[0]; } if (patient.hospital_id !== null) { hospital = (await query_controller.getHospital(patient.hospital_id)).response[0]; } } catch (err) { failedBoth.push(testIDs[i]); // release token query_controller.returnToken(\"Test\", testIDs[i], token, actionUsername); continue; } const emailInfo = { patient: patient, hospital: hospital, test: test, carer: carer }; let contactPatient = false; if (isOvedue) { // check if this patient has already been contacted if (test.last_reminder === null) { contactPatient = true; } else { const date_1 = dateformat(test.last_reminder, \"yyyymmdd\"); const date_2 = dateformat(new Date(), \"yyyymmdd\"); if (date_1 === date_2) { contactPatient = false; } } } let pat_ok = true; if (contactPatient) { pat_ok = await patientFunction(emailInfo); } let hos_ok = true; if (hospital !== null) { hos_ok = await hospitalFunction(emailInfo); } if (!pat_ok &amp;&amp; !hos_ok) { failedBoth.push(testIDs[i]); } else if (!pat_ok) { failedPatient.push(testIDs[i]); } else if (!hos_ok) { failedHospital.push(testIDs[i]); } if (pat_ok) { // email for patient sent successfully query_controller.updateLastReminder(testIDs[i], token, actionUsername).then((res) =&gt; { if (!res.success) { logger.error(\"Error updating latest reminder. Response: \" + JSON.stringify(res)); } }); } else { // release token query_controller.returnToken(\"Test\", testIDs[i], token, actionUsername); } } if (failedBoth.length === 0 &amp;&amp; failedPatient.length === 0 &amp;&amp; failedHospital.length === 0) { return { success: true, response: \"All emails sent successfully.\" }; } else { return { success: false, response: { failedBoth: failedBoth, failedPatient: failedPatient, failedHospital: failedHospital } }; } } /** * Recover password of user * @param {String} username - user to recover password * @result {JSON} result - {success:Boolean response:(optional) Error/Problem} **/ async function recoverPassword(username) { const user = await query_controller.getUser(username); if (!user.success) { return user; } if (user.response[0].length == 0) { return { success: false, response: \"No user found!\" } } const token = await query_controller.requestEditing(\"User\", username, username); if (!token) { return { success: false, response: \"Could not send an email.\" }; } const newPassword = authenticator.produceSalt(); const userToEmail = { user: { username: username, new_password: newPassword, recovery_email: user.response[0].recovery_email } } const emailResponse = await email_sender.sendPasswordRecoveryEmail(userToEmail); if (!emailResponse) { query_controller.returnToken(\"User\", username, token, username); return { success: false, response: \"Could not send an email.\" }; } const hash = crypto.createHash('sha256').update(newPassword).digest('hex'); return await query_controller.editUser({ username: username, hashed_password: hash }, token, username); } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_email_email-generator.js.html":{"id":"server_lib_email_email-generator.js.html","title":"Source: server/lib/email/email-generator.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/email/email-generator.js /** * The functions exported from this module generate different types of emails depending on their purpose. They all need information contained in the \"email_info\" JSON objects. * @example &lt;caption&gt;The email_info JSON needs to reflect this format in order to be properly parsed:&lt;/caption&gt; { \"patient\": { \"patient_no\": \"P799886\", \"patient_name\": \"Bruce\", \"patient_surname\": \"Wayne\", \"patient_email\": \"imnotbatman@gotham.com\", \"patient_phone\": null, \"hospital_id\": 551, \"carer_id\": null, \"additional_info\": null }, \"test\": { \"test_id\": 1, \"patient_no\": \"P799886\", \"due_date\": date_obj, //a date object \"frequency\": \"4-W\", \"occurrences\": 9, \"completed_status\": \"yes\", \"completed_date\": date_obj, //a date object \"notes\": null }, \"hospital\": { \"hospital_id\": 551, \"hospital_name\": \"Gotham City Hospital\", \"hospital_email\": \"hospital@gotham.com\", \"hospital_phone\": null } \"user\":{ \"username\": \"admin\" \"new_password\": \"newpassword123\" \"recovery_email\": \"admin@admin.com\" } } * @module email-generator * @author Danilo Del Busso, Luka Kralj * @version 0.0.2 */ /* |-------------------------------------------------------------------------- | MODULE EXPORTS |-------------------------------------------------------------------------- */ module.exports = { testReminderForPatient, testReminderForHospital, overdueTestReminderForPatient, overdueTestReminderForHospital, passwordRecoveryEmail }; const dateformat = require('dateformat'); const mjml2html = require(\"mjml\"); /* |-------------------------------------------------------------------------- | EMAIL GENERATION FUNCTIONS |-------------------------------------------------------------------------- | This section contains the functions which generate html code for different kinds of email | */ /** * Return html for an email containing info about a test which is overdue for a patient. * @param {JSON} email_info the json containing info needed to generate the email. For format info look at the module's documentation. * @returns {string} html for an email containing info about a test which is due for a patient */ async function overdueTestReminderForHospital(email_info, email_config) { const greeting = \"Dear colleagues,\"; const computed_html = mjml2html(await generateReminderBody(email_info, email_config.content.overdueHospital, greeting, true, email_config)); let subject = email_config.content.overdueHospital.subject.title; const due_date = beautifyDate(email_info.test.due_date); if (email_config.content.overdueHospital.subject.appendDate) { subject += (subject.endsWith(\" \")) ? due_date : \" \" + due_date; } if (computed_html.errors.length === 0) { return { to: email_info.hospital.hospital_email, html: (computed_html.html + \"&lt;br&gt;\" + getFooter(email_config)).replace(/--br--/g, \"&lt;br&gt;\"), subjectTitle: subject }; } return null; } /** * Return html for an email containing info about a test which is overdue for a patient. * @param {JSON} email_info the json containing info needed to generate the email. For format info look at the module's documentation. * @returns {string} html for an email containing info about a test which is due for a patient */ async function overdueTestReminderForPatient(email_info, email_config) { if (email_info.patient.patient_email === null || email_info.patient.patient_email === undefined || email_info.patient.patient_email.length === 0 || email_info.patient.patient_email === \"null\") { return await overdueTestReminderForCarer(email_info, email_config); } let name = email_info.patient.patient_name; let surname = email_info.patient.patient_surname; name = (name === null || name === undefined|| name.length === 0 || name === \"null\") ? undefined : name; surname = (surname === null || surname === undefined || surname.length === 0 || surname === \"null\") ? undefined : surname; let greeting = \"Dear \"; if (name &amp;&amp; surname) { greeting += name + \" \" + surname + \",\"; } else { greeting += \"patient,\"; } const computed_html = mjml2html(await generateReminderBody(email_info, email_config.content.overduePatient, greeting, true, email_config)); let subject = email_config.content.overduePatient.subject.title; const due_date = beautifyDate(email_info.test.due_date); if (email_config.content.overduePatient.subject.appendDate) { subject += (subject.endsWith(\" \")) ? due_date : \" \" + due_date; } if (computed_html.errors.length === 0) { return { to: email_info.patient.patient_email, html: (computed_html.html + \"&lt;br&gt;\" + getFooter(email_config)).replace(/--br--/g, \"&lt;br&gt;\"), subjectTitle: subject }; } return null; } /** * Return html for an email containing info about a test which is overdue for a patient. * @param {JSON} email_info the json containing info needed to generate the email. For format info look at the module's documentation. * @returns {string} html for an email containing info about a test which is due for a patient */ async function overdueTestReminderForCarer(email_info, email_config) { if (email_info.carer === null || email_info.carer === undefined) { return null; } let name = email_info.carer.carer_name; let surname = email_info.carer.carer_surname; name = (name === null || name === undefined || name.length === 0 || name === \"null\") ? undefined : name; surname = (surname === null || surname === undefined || surname.length === 0 || surname === \"null\") ? undefined : surname; let greeting = \"Dear \"; if (name &amp;&amp; surname) { greeting += name + \" \" + surname + \",\"; } else { greeting += \"carer,\"; } const computed_html = mjml2html(await generateReminderBody(email_info, email_config.content.overdueCarer, greeting, true, email_config)); let subject = email_config.content.overdueCarer.subject.title; const due_date = beautifyDate(email_info.test.due_date); if (email_config.content.overdueCarer.subject.appendDate) { subject += (subject.endsWith(\" \")) ? due_date : \" \" + due_date; } if (computed_html.errors.length === 0) { return { to: email_info.carer.carer_email, html: (computed_html.html + \"&lt;br&gt;\" + getFooter(email_config)).replace(/--br--/g, \"&lt;br&gt;\"), subjectTitle: subject }; } return null; } /** * Return html for an email containing info about a new password which is generated for a User. * @param {JSON} email_info the json containing info needed to generate the email. For format info look at the module's documentation. * @returns {string} html for an email containing info about a test which is due for a patient */ async function passwordRecoveryEmail(email_info, email_config) { const subject = email_config.content.recoveryEmail.subject; const newPassword = email_info.user.new_password; const computed_html = mjml2html(await generateRecoveryEmailBody(newPassword, email_config.content.recoveryEmail)); if (computed_html.errors.length === 0) { return { to: email_info.user.recovery_email, html: (computed_html.html + \"&lt;br&gt;\" + getFooter(email_config)).replace(/--br--/g, \"&lt;br&gt;\"), subjectTitle: subject }; } return null; } /** * Return html for an email containing info about a test which is due for a patient. * @param {JSON} email_info the json containing info needed to generate the email. For format info look at the module's documentation. * @returns {string} html for an email containing info about a test which is due for a patient */ async function testReminderForPatient(email_info, email_config) { if (email_info.patient.patient_email === null || email_info.patient.patient_email === undefined || email_info.patient.patient_email.length === 0 || email_info.patient.patient_email === \"null\") { return await testReminderForCarer(email_info, email_config); } let name = email_info.patient.patient_name; let surname = email_info.patient.patient_surname; name = (name === null || name === undefined || name.length === 0 || name === \"null\") ? undefined : name; surname = (surname === null || surname === undefined || surname.length === 0 || surname === \"null\") ? undefined : surname; let greeting = \"Dear \"; if (name &amp;&amp; surname) { greeting += name + \" \" + surname + \",\"; } else { greeting += \"patient,\"; } const computed_html = mjml2html(await generateReminderBody(email_info, email_config.content.generalPatient, greeting, false, email_config)); let subject = email_config.content.generalPatient.subject.title; const due_date = beautifyDate(email_info.test.due_date); if (email_config.content.generalPatient.subject.appendDate) { subject += (subject.endsWith(\" \")) ? due_date : \" \" + due_date; } if (computed_html.errors.length === 0) { return { to: email_info.patient.patient_email, html: (computed_html.html + \"&lt;br&gt;\" + getFooter(email_config)).replace(/--br--/g, \"&lt;br&gt;\"), subjectTitle: subject }; } return null; } /** * Generate an email aimed at hospitals which reminds of a blood test due for a patient of theirs * @param {JSON} email_info the json containing info needed to generate the email. For format info look at the module's documentation. */ async function testReminderForHospital(email_info, email_config) { const greeting = \"Dear colleagues,\"; const computed_html = mjml2html(await generateReminderBody(email_info, email_config.content.generalHospital, greeting, false, email_config)); let subject = email_config.content.generalHospital.subject.title; const due_date = beautifyDate(email_info.test.due_date); if (email_config.content.generalHospital.subject.appendDate) { subject += (subject.endsWith(\" \")) ? due_date : \" \" + due_date; } if (computed_html.errors.length === 0) { return { to: email_info.hospital.hospital_email, html: (computed_html.html + \"&lt;br&gt;\" + getFooter(email_config)).replace(/--br--/g, \"&lt;br&gt;\"), subjectTitle: subject }; } return null; } /** * Generate an email aimed at carers which reminds of a blood test due for a patient * @param {JSON} email_info the json containing info needed to generate the email. For format info look at the module's documentation. */ async function testReminderForCarer(email_info, email_config) { if (email_info.carer === null || email_info.carer === undefined) { return null; } let name = email_info.carer.carer_name; let surname = email_info.carer.carer_surname; name = (name === null || name === undefined || name.length === 0 || name === \"null\") ? undefined : name; surname = (surname === null || surname === undefined || surname.length === 0 || surname === \"null\") ? undefined : surname; let greeting = \"Dear \"; if (name &amp;&amp; surname) { greeting += name + \" \" + surname + \",\"; } else { greeting += \"carer,\"; } const computed_html = mjml2html(await generateReminderBody(email_info, email_config.content.generalCarer, greeting, false, email_config)); let subject = email_config.content.generalCarer.subject.title; const due_date = beautifyDate(email_info.test.due_date); if (email_config.content.generalCarer.subject.appendDate) { subject += (subject.endsWith(\" \")) ? due_date : \" \" + due_date; } if (computed_html.errors.length === 0) { return { to: email_info.carer.carer_email, html: (computed_html.html + \"&lt;br&gt;\" + getFooter(email_config)).replace(/--br--/g, \"&lt;br&gt;\"), subjectTitle: subject }; } return null; } /* |-------------------------------------------------------------------------- | COMMON EMAIL ELEMENTS |-------------------------------------------------------------------------- | This section contains the functions which generate mjml code for common elements in | the emails | */ /** * Generates the body of the email according to the content configuration. * * @param {JSON} contentConfiguration - format: { \"subject\": { \"title\": \"\", \"appendDate\": true|false }, \"mainBody\": \"\", \"details\": { \"includePatientNo\": true|false, \"includePatientName\": true|false, \"includePatientContact\": true|false, \"includeDueDate\": true|false } }, */ async function generateReminderBody(emailInfo, contentConfiguration, greeting, isOverdue) { const patient = emailInfo.patient; const main = contentConfiguration.mainBody; let html = ` &lt;mjml&gt; ${getHead(\"Blood Test Reminder\")} &lt;mj-body&gt; &lt;mj-section&gt; &lt;mj-column width=\"45%\"&gt; &lt;mj-text align=\"center\" font-weight=\"500\" padding=\"0px\" font-size=\"18px\"&gt;BLOOD TEST REMINDER&lt;/mj-text&gt; &lt;mj-divider border-width=\"2px\" border-color=\"#616161\" /&gt; &lt;mj-divider border-width=\"2px\" border-color=\"#616161\" width=\"45%\" /&gt; &lt;/mj-column&gt; &lt;/mj-section&gt; &lt;mj-section padding-top=\"30px\"&gt; &lt;mj-column width=\"100%\"&gt; &lt;mj-text&gt; ${greeting} --br----br-- ${main} --br----br-- `; let rows = \"\"; if (contentConfiguration.details.includePatientNo) { rows += `&lt;i&gt;Patient number: &lt;/i&gt; ${patient.patient_no}--br--`; } if (contentConfiguration.details.includePatientName) { let name = patient.patient_name; let surname = patient.patient_surname; name = (name === null || name === undefined || name.length === 0 || name === \"null\") ? undefined : name; surname = (surname === null || surname === undefined || surname.length === 0 || surname === \"null\") ? undefined : surname; if (name &amp;&amp; surname) { rows += `&lt;i&gt;Full name: &lt;/i&gt; ${patient.patient_name} ${patient.patient_surname}--br--`; } else if (name) { rows += `&lt;i&gt;Name: &lt;/i&gt; ${patient.patient_name}--br--`; } else if (surname) { rows += `&lt;i&gt;Name: &lt;/i&gt; ${patient.patient_surname}--br--`; } } if (contentConfiguration.details.includePatientContact) { if (!(patient.patient_email === null || patient.patient_email === undefined || patient.patient_email.length === 0 || patient.patient_email === \"null\")) { rows += `&lt;i&gt;Email: &lt;/i&gt; ${patient.patient_email}--br--`; } if (!(patient.patient_phone === null || patient.patient_phone === undefined || patient.patient_phone.length === 0 || patient.patient_phone === \"null\")) { rows += `&lt;i&gt;Phone number: &lt;/i&gt; ${patient.patient_phone}--br--`; } } if (rows.length &gt; 0) { const tableHeader = ` &lt;b&gt;Patient details:&lt;/b&gt;--br----br--`; html += tableHeader + rows + \"--br--\"; } if (contentConfiguration.details.includeDueDate) { const test_date = beautifyDate(emailInfo.test.due_date); if (isOverdue) { html += ` &lt;b&gt;This test was due on ${test_date}.&lt;b&gt; `; } else { html += ` &lt;b&gt;This test is due on ${test_date}.&lt;b&gt; `; } } html += `--br--&lt;/mj-text&gt; &lt;/mj-column&gt; &lt;/mj-section&gt; &lt;/mj-body&gt; &lt;/mjml&gt;`; return html; } /** * Generates the body of the email according to the content configuration. * * @param {JSON} contentConfiguration - format: { \"subject\": \"\", \"mainBody\": \"\", }, */ async function generateRecoveryEmailBody(newPassword, contentConfiguration) { const main = contentConfiguration.mainBody; let html = ` &lt;mjml&gt; ${getHead(\"Password recovery\")} &lt;mj-body&gt; &lt;mj-section&gt; &lt;mj-column width=\"45%\"&gt; &lt;mj-text align=\"center\" font-weight=\"500\" padding=\"0px\" font-size=\"18px\"&gt;Password recovery email&lt;/mj-text&gt; &lt;mj-divider border-width=\"2px\" border-color=\"#616161\" /&gt; &lt;mj-divider border-width=\"2px\" border-color=\"#616161\" width=\"45%\" /&gt; &lt;/mj-column&gt; &lt;/mj-section&gt; &lt;mj-section padding-top=\"30px\"&gt; &lt;mj-column width=\"100%\"&gt; &lt;mj-text&gt; Dear user, --br----br-- ${main} --br----br-- &lt;b&gt;New password: &lt;/b&gt;${newPassword}--br-- `; html += `--br--&lt;/mj-text&gt; &lt;/mj-column&gt; &lt;/mj-section&gt; &lt;/mj-body&gt; &lt;/mjml&gt;`; return html; } /** * Get mjml code for image at the top of emails * @return {string} mjml code for image at the top of emails */ function getLogo(email_config) { const header_image_url = email_config.content.common.logo; if (header_image_url == null) { return \"\"; } return ` &lt;div&gt; &lt;img src=\"${header_image_url}\" alt=\"Logo\" width=\"200\"&gt; &lt;/div&gt; `; } /** * Get mjml code describing common head of emails * @param {title} the title of the html document * @return {string} mjml code describing common head of emails */ function getHead(title) { return ` &lt;mj-head&gt; &lt;mj-title&gt;${title}&lt;/mj-title&gt; &lt;mj-font name=\"Roboto\" href=\"https://fonts.googleapis.com/css?family=Roboto:300,500\" /&gt; &lt;mj-attributes&gt; &lt;mj-all font-family=\"Roboto, Helvetica, sans-serif\" /&gt; &lt;mj-text font-weight=\"300\" font-size=\"16px\" color=\"#616161\" line-height=\"24px\" /&gt; &lt;mj-section padding=\"0px\" /&gt; &lt;/mj-attributes&gt; &lt;/mj-head&gt; `; } /** * Get mjml code describing common footer of emails * @return {string} mjml code describing common footer of emails */ function getFooter(email_config) { return `--br-- ${getLogo(email_config)}--br-- ${email_config.content.common.footer} `; } /** * Beautify a date object as a readable string of \"1st October 2020\" format * @param {date} date the date object to be beautified * @returns {string} the beautified date */ function beautifyDate(date) { return dateformat(date, \"dS mmmm yyyy\") } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_email_email-sender.js.html":{"id":"server_lib_email_email-sender.js.html","title":"Source: server/lib/email/email-sender.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/email/email-sender.js /** * The email-sender sends email to patients and labs. * The module is centered around a specific config file to be created which specifies * the host email from which emails are being sent, as well as when emails have to be sent and to who. * @example &lt;caption&gt;Example of the config file.&lt;/caption&gt; { \"transporter\": { \"host\": \"smtp.gotham.mail.com\", //example of SMTP host \"port\": 465, \"secure\": true, //this value true only with port 465 \"auth\": { \"user\": \"imnotbatman@gotham.com\", //example of email \"pass\": \"jokerisajoke42\" //password } } } * @module email-sender * @author Danilo Del Busso, Jacopo Madaluni, Luka Kralj * @version 0.0.3 */ /* |-------------------------------------------------------------------------- | MODULE EXPORTS |-------------------------------------------------------------------------- */ module.exports = { sendReminderToPatient, sendReminderToHospital, sendOverdueReminderToPatient, sendOverdueReminderToHospital, sendPasswordRecoveryEmail }; const email_generator = require(\"./email-generator\"); const nodeMailer = require(\"nodemailer\"); const jsonController = require(\"../json-parser\"); const CONFIG_ABSOLUTE_PATH = __dirname + \"/../../config/email_config.json\"; //the absolute path of the email_config.json file const email_config = jsonController.getJSON(CONFIG_ABSOLUTE_PATH); const logger = require('./../logger'); /* |-------------------------------------------------------------------------- | MAIN EMAIL SENDING FUNCTIONS |-------------------------------------------------------------------------- | This section contains the functions which can be called externally to send emails, | these functions do not directly handle data and generate emails. They are written to simplify | usage of the module. */ async function sendPasswordRecoveryEmail(emailInfo) { return await sendOneEmail(emailInfo, email_generator.passwordRecoveryEmail); } /** * Send a single reminder to patient. * * @param {JSON} emailInfo - { * patient: * test: * hospital: * carer: * } * @returns {boolean} True if email was successfully sent, false if something went wrong. */ async function sendReminderToPatient(emailInfo) { return await sendOneEmail(emailInfo, email_generator.testReminderForPatient); } /** * Send a single reminder to hospital. * * @param {JSON} emailInfo - { * patient: * test: * hospital: * carer: * } * @returns {boolean} True if email was successfully sent, false if something went wrong. */ async function sendReminderToHospital(emailInfo) { return await sendOneEmail(emailInfo, email_generator.testReminderForHospital); } /** * Send a single reminder to patient. * * @param {JSON} emailInfo - { * patient: * test: * hospital: * carer: * } * @returns {boolean} True if email was successfully sent, false if something went wrong. */ async function sendOverdueReminderToPatient(emailInfo) { return await sendOneEmail( emailInfo, email_generator.overdueTestReminderForPatient ); } /** * Send a single reminder to hospital. * * @param {JSON} emailInfo - { * patient: * test: * hospital: * carer: * } * @returns {boolean} True if email was successfully sent, false if something went wrong. */ async function sendOverdueReminderToHospital(emailInfo) { return await sendOneEmail( emailInfo, email_generator.overdueTestReminderForHospital ); } /* |-------------------------------------------------------------------------- | EMAIL GENERATING AND SENDING FUNCTIONS SECTION |-------------------------------------------------------------------------- | This section contains the functions which send emails and handle | email creation. */ /** * Generate and send a single email. * * @param {JSON} emailInfo - { * patient: * test: * hospital: * carer: * } * @param {function} emailGeneratorFunction Function that generates the email from emailInfo. * @returns {boolean} True if email was successfully sent, false if something went wrong. */ async function sendOneEmail(emailInfo, emailGeneratorFunction) { const transporter = nodeMailer.createTransport(email_config.transporter); const generated = await emailGeneratorFunction(emailInfo, email_config); if (generated == null) { return false; } const receiverOptions = { from: transporter.options.auth.user, to: generated.to, subject: generated.subjectTitle, html: generated.html }; if (receiverOptions.to !== undefined &amp;&amp; receiverOptions.to !== null &amp;&amp; receiverOptions.to.length !== 0) { const res = await sendEmail(transporter, receiverOptions); if (res) return true; } return false; } /** * Send a single email based on the options * @param {transporter} transporter the transporter from which emails are being sent * @param {JSON} receiverOptions the options of the email address to be sent, as well as the content of the mail */ async function sendEmail(transporter, receiverOptions) { let successful = false; let finished = false; await transporter.sendMail(receiverOptions, (err, info) =&gt; { if (err) { logger.error(err); successful = false; } else { logger.info(\"Email sent successfully to: \" + receiverOptions.to + \".\"); successful = true; } transporter.close(); finished = true; }); while (!finished) { await sleep(1); } return successful; } /** * Await for this function to pause execution for a certain time. * * @param {number} ms Time in milliseconds * @returns {Promise} */ function sleep(ms) { return new Promise(resolve =&gt; { setTimeout(resolve, ms); }); } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_lib_json-controller.js.html":{"id":"client_lib_json-controller.js.html","title":"Source: client/lib/json-controller.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/lib/json-controller.js /** * Controller functions for json files reading and writing * @module json-controller * @author Danilo Del Busso * @version 0.0.2 */ /* |-------------------------------------------------------------------------- | MODULE EXPORTS |-------------------------------------------------------------------------- */ module.exports = { getJSON, isJSON, writeServerConfigFile } const fs = require('fs'); /** * Returns the content of the JSON file * @param {string} path The absolute path of the config file * @return {json} The config in JSON format, null if the file doesn't exist or is not a properly formatted JSON object * @example &lt;caption&gt;Example usage of getJSON.&lt;/caption&gt; * getJSON(__dirname + '/config.json') */ function getJSON(path) { if (fs.existsSync(path)) { const data = fs.readFileSync(path); return isJSON(data) } else { console.error(`There is no JSON file at ${path}`) return null; } } function writeServerConfigFile(json){ let toWrite = JSON.stringify(json); console.log(toWrite); fs.writeFile('src/server_connect_config.json', toWrite, 'utf8', err =&gt; { console.log(err); }); } /** * Check if the data is a properly formatted JSON file * @param {string} data * @return {JSON} null if the data was not a properly formatted JSON object, the data in JSON if otherwise */ function isJSON(data) { try { const json = JSON.parse(data); return json; } catch (e) { console.error(`The file is not in JSON format`); return null; } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_json-parser.js.html":{"id":"server_lib_json-parser.js.html","title":"Source: server/lib/json-parser.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/json-parser.js /** * Controller functions for json files reading and writing * @module json-parser * @author Danilo Del Busso * @version 0.0.2 */ /* |-------------------------------------------------------------------------- | MODULE EXPORTS |-------------------------------------------------------------------------- */ module.exports = { getJSON, isJSON } const fs = require('fs'); /** * Returns the content of the JSON file * @param {string} path The absolute path of the config file * @return {json} The config in JSON format, null if the file doesn't exist or is not a properly formatted JSON object * @example &lt;caption&gt;Example usage of getJSON.&lt;/caption&gt; * getJSON(__dirname + '/config.json') */ function getJSON(path) { if (fs.existsSync(path)) { const data = fs.readFileSync(path); return isJSON(data) } else { return null; } } /** * Check if the data is a properly formatted JSON file * @param {string} data * @return {JSON} null if the data was not a properly formatted JSON object, the data in JSON if otherwise */ function isJSON(data) { try { const json = JSON.parse(data); return json; } catch (e) { return null; } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_logger.js.html":{"id":"server_lib_logger.js.html","title":"Source: server/lib/logger.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/logger.js /** * A logger module, it allows for different levels of logging * and to save a log file and/or output the log to console. * @module logger * @author Danilo Del Busso * @version 0.0.2 */ /* |-------------------------------------------------------------------------- | MODULE EXPORTS |-------------------------------------------------------------------------- */ module.exports = { log, info, error, warning, debug, changeOption, deleteLogFile, deleteAllLogFiles, createLog } const jsonController = require('./json-parser.js'); const CONFIG_FILE_PATH = __dirname + '/../config/logger.json' const fs = require('fs'); const dateformat = require('dateformat'); let writeStream = null; let logPath = \"\"; const colors = { //all colors are without background. usage: console.log(colors.Red, \"string to display colorized\") or replace the \"%s\" with the string that has to be colored Black: \"\\x1b[30m%s\\x1b[0m\", Red: \"\\x1b[31m%s\\x1b[0m\", Green: \"\\x1b[32m%s\\x1b[0m\", Yellow: \"\\x1b[33m%s\\x1b[0m\", Blue: \"\\x1b[34m%s\\x1b[0m\", Magenta: \"\\x1b[35m%s\\x1b[0m\", Cyan: \"\\x1b[36m%s\\x1b[0m\", White: \"\\x1b[37m%s\\x1b[0m\", } const defaultOptions = { //default options for the use of the module compact: true, timeStamp: true, consoleOutput: true, fileOutput: true, colorize: true, outputFilePath: \"./logs/\" } let options = initialise(CONFIG_FILE_PATH); //the options used by the logger /* |-------------------------------------------------------------------------- | LEVELS LOGGING FUNCTIONS |-------------------------------------------------------------------------- | This section contains all the functions which can be called to log something. | They take in any kind and number of parameters and will display one message containing | all the parameters' information. | The log() function is general and does not hold any particular meaning. */ /** * Use to create a info log message. It takes any number of parameters */ function info() { createLog(argumentsToArray(arguments), \"INFO\") } /** * Use to create a error log message. It takes any number of parameters */ function error() { createLog(argumentsToArray(arguments), \"ERROR\") } /** * Use to create a warning log message. It takes any number of parameters */ function warning() { createLog(argumentsToArray(arguments), \"WARNING\") } /** * Use to create a debugging log message. It takes any number of parameters */ function debug() { createLog(argumentsToArray(arguments), \"DEBUG\") } /** * Use to create a general log message. It takes any number of parameters */ function log() { createLog(argumentsToArray(arguments), \"LOG\") } /** |-------------------------------------------------------------------------- | LOG CREATION FUNCTIONS |-------------------------------------------------------------------------- | This section contains all the functions that allow to generate logs both on the console | and in a file. | The behaviour depends on the options that are set in a config file (see CONFIG_FILE_PATH const for | the path of the options file. */ /** * Generate the options for the use of this module and create a write stream. * If the path of the config is not valid, use a set of default options. * @param {string} configPath the path of the config file. * @returns {JSON} the options for logging. */ function initialise(configPath) { let json = null; try { json = jsonController.getJSON(configPath); } catch (err) { console.error(err) } if (json == null) json = defaultOptions; let outputFilePath = json.outputFilePath; if (outputFilePath[outputFilePath.length - 1] !== '/') //check if the output file path is formatted as a directory outputFilePath += '/'; logPath = getLogPath(outputFilePath); try { if (writeStream == null &amp;&amp; json.fileOutput == true) { if (!fs.existsSync(outputFilePath)) fs.mkdirSync(outputFilePath); writeStream = fs.createWriteStream(logPath, { 'flags': 'a' }); } //flag \"a\" allows for appending } catch (err) { console.error(err) } return json; } /** * Log all the strings or objects contained using the options configuration. * @param {array} messages the set of objects * @param {string} level */ function createLog(messages, level) { //checks for invalid parameters values if (options == null) options = initialise(CONFIG_FILE_PATH); if (level == null || level == undefined) level = \"LOG\"; if (messages == undefined || !Array.isArray(messages)) { error(level, \"Log failed with messages array:\", messages); return; } let timeStamp = \"\" if (options.timeStamp == true) timeStamp = \"|\" + dateformat(new Date(), \"yyyy-mm-dd HH-MM-ss\") + \"|\"; const fileOutputString = `${timeStamp} ${level} =&gt;`; if (options.fileOutput == true) { append(`\\n${fileOutputString}`) messages.forEach(msg =&gt; { append(msg); }); } //OUTPUT TO CONSOLE let levelLabel = `&lt;============ ${level} ============&gt;\\n` let logElementsSeparator = \"\\n\"; if (options.compact == true) { levelLabel = level + \": \"; logElementsSeparator = \" \"; } if (options.colorize == true) { let color = null; switch (level) { case \"INFO\": color = colors.Green; break; case \"ERROR\": color = colors.Red; break; case \"WARNING\": color = colors.Yellow; break; case \"DEBUG\": color = colors.Blue; break; default: color = colors.Magenta; break; } levelLabel = color.replace('%s', `${levelLabel}`); timeStamp = colors.Yellow.replace('%s', timeStamp); } const consoleOutputString = `${levelLabel}${timeStamp}`; if (options.consoleOutput == true) { process.stdout.write(consoleOutputString); messages.forEach(msg =&gt; { process.stdout.write(logElementsSeparator); process.stdout.write(convertToString(msg)) }); process.stdout.write(\"\\n\"); } } /** * Append an element to the log file. * @param {Object} element the element to be appended to the log file */ function append(element) { if (writeStream == null) { options = initialise(CONFIG_FILE_PATH); } writeStream.write(convertToString(element) + \" \"); } /** * Flush the content of the log file. And delete it. */ function deleteLogFile() { if (options === null) { options = initialise(CONFIG_FILE_PATH); } if (fs.existsSync(logPath)) { fs.unlinkSync(logPath, function (err) { if (err) { return error(err) } return; }); } } /** * Flush the content of every log file and delete them. */ function deleteAllLogFiles() { deleteFolderRecursive(options.outputFilePath); } /** |-------------------------------------------------------------------------- | HELPER FUNCTIONS |-------------------------------------------------------------------------- | Miscellaneous functions used for various purposes. */ /** * Change an existing option value. * If the option does not exist, nothing is changed. * If the value does not have the same type as the value that needs to be changed, nothing is changed. * @param {string} optionName the name of the existing options. * @param {Object} value the new value of the option. * @returns {Object} the new value of the option. null if the parameters are not valid. */ function changeOption(optionName, value) { if (options == null) options = initialise(CONFIG_FILE_PATH); if (typeof options[optionName] === typeof value) { options[optionName] = value; return options[optionName]; } return null } /** * Convert any object to a string * If the object is a JSON file, use the stringify() function. * Else, use the String(obj) * @param {Object} obj the object to be converted to a string * @returns {string} the object converted to string */ function convertToString(obj) { if (typeof obj !== \"string\") { try { const temp = JSON.stringify(obj); if (temp == undefined || temp === JSON.stringify({})) throw \"Not a valid JSON object\"; return temp; } catch (err) { return String(obj); } } return obj } /** * Generate the log path for this module * @param {string} outputPath the output path */ function getLogPath(outputPath){ return outputPath + dateformat(new Date(), \"yyyymmdd_HHMMss\") + \"_server.log\"; } /** * Convert the JSON file created by calling the \"arguments\" variable inside a function with no parameters, to an array * @param {JSON} args the JSON file created by calling the \"arguments\" variable inside a function with no parameters7 * @returns {array} an array containing the values of the JSON file. Empty if the args JSON was not valid. */ function argumentsToArray(args) { const array = [] try { for (let i = 0; i &lt; args.length; ++i) { array[i] = args[i]; } } catch (e) { warning(e) } return array; } /** * Recursively and synchronously delete all files inside a path. * taken from https://bit.ly/2TqLDWv * @param {string} path */ function deleteFolderRecursive(path) { if (fs.existsSync(path)) { fs.readdirSync(path).forEach(function (file) { const curPath = path + \"/\" + file; if (fs.lstatSync(curPath).isDirectory()) { deleteFolderRecursive(curPath); } else { // delete file fs.unlinkSync(curPath, function (err) { if (err) { return error(err); } return; }); } }); fs.rmdirSync(path); } } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_src_lib_overdue-controller.js.html":{"id":"client_src_lib_overdue-controller.js.html","title":"Source: client/src/lib/overdue-controller.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/src/lib/overdue-controller.js /** * Controller functions to handle overdue tests * @module overdue-controller * @author Jacopo Madaluni * @version 0.0.1 */ /** * @param {Date} date1 * @param {Date} date2 * @return {Int} The number of days in between. */ function daysBetweenDates(date1, date2){ var oneDay = 24*60*60*1000; // hours*minutes*seconds*milliseconds date1 = new Date(date1); date2 = new Date(date2); let distance = Math.round(Math.abs((date1.getTime() - date2.getTime())/(oneDay))); return distance; } // TODO to be tested function weeksBetweenDates(date1, date2){ return Math.floor(daysBetweenDates(date1, date2))/7; } // TODO to be tested function monthsBetweenDates(date1, date2){ return Math.floor(daysBetweenDates(date1, date2)/30); } // TODO to be tested function yearsBetweenDates(date1, date2){ return Math.floor(daysBetweenDates(date1, date2)/365); } /** * Returns a sorted list in descending order based on * how much time each test has been overdue for. * @param {List} tests The list of overdue tests * @return {List} A sorted version of the imput list */ function sortByOverdueTime(tests, left, right){ var i = left; var j = right; var tmp; var pivot = tests[Math.floor((left + right) / 2)]; var today = new Date(); while (i &lt;= j){ while (daysBetweenDates(tests[i].due_date, today) &gt; daysBetweenDates(pivot.due_date, today)){ i++; } while (daysBetweenDates(tests[j].due_date, today) &lt; daysBetweenDates(pivot.due_date, today)){ j--; } if (i &lt;= j){ tmp = tests[i]; tests[i] = tests[j]; tests[j] = tmp; i++; j--; } } if (left &lt; j){ sortByOverdueTime(tests, left, j); } if (i &lt; right){ sortByOverdueTime(tests, i, right); } return tests; } /** * Groups the list of tests based on whether they spent 1 year+, months, * or weeks overdue. * @param {List[Date]} tests The list of overdue tests * @return {List[JSON]} A list of groups with the relative list of tests. */ function group(tests, testDay=undefined){ //TODO do be tested const today = testDay ? testDay : new Date(); let sortedTests = sortByOverdueTime(tests, 0, tests.length - 1); let groups = [{class: \"Year+\", tests: []}, {class: \"6+ months\", tests: []},{class: \"1-6 months\", tests: []}, {class: \"2-4 weeks\", tests: []}, {class: \"Less than 2 weeks\", tests: []}]; var i = 0; while (i &lt; sortedTests.length &amp;&amp; yearsBetweenDates(sortedTests[i].due_date, today) &gt; 0){ groups[0].tests = groups[0].tests.concat(sortedTests[i]); i++; } while (i &lt; sortedTests.length &amp;&amp; monthsBetweenDates(sortedTests[i].due_date, today) &gt; 6){ groups[1].tests = groups[1].tests.concat(sortedTests[i]); i++; } while (i &lt; sortedTests.length &amp;&amp; monthsBetweenDates(sortedTests[i].due_date, today) &gt;= 1){ groups[2].tests = groups[2].tests.concat(sortedTests[i]); i++; } while (i &lt; sortedTests.length &amp;&amp; weeksBetweenDates(sortedTests[i].due_date, today) &gt;= 2){ groups[3].tests = groups[3].tests.concat(sortedTests[i]); i++; } while (i &lt; sortedTests.length){ groups[4].tests = groups[4].tests.concat(sortedTests[i]); i++; } return groups; } function getNumberOfTestsInGroup(group){ var length = 0; for(var i = 0 ; i &lt; group.length ; i++){ length += group[i].tests.length; } return length; } function testGroup(tests){ let today = new Date(2019, 2, 1); return group(tests, today); } module.exports = { daysBetweenDates, sortByOverdueTime, group, getNumberOfTestsInGroup, testGroup } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_query-controller.js.html":{"id":"server_lib_query-controller.js.html","title":"Source: server/lib/query-controller.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/query-controller.js /** * This module collects all the queries that are dealing with the core data. * * @author Mateusz Nowak, Luka Kralj * @module query-controller * @version 1.0 */ const calendarController = require(\"./calendar-functions.js\"); const authenticator = require(\"./authenticator.js\"); const dateformat = require(\"dateformat\"); const selector = require('./query-modules/selector') const inserter = require('./query-modules/inserter') const deleter = require('./query-modules/deleter') const updater = require('./query-modules/updater') const tokenConroller = require('./query-modules/token-controller') /*===============================* SELECT QUERIES *===============================*/ /** * Collects data from selector queries and returns them. * * @param {date} date * @returns {JSON} {success:Boolean, response:JSON} */ async function getMonthlyReport(date) { date = dateformat(date, \"yyyymmdd\"); let thisMonth = await selector.getDueTestsInMonth(date); let completedOnTime = await selector.getCompletedOnTimeInMonth(date); let completedLate = await selector.getCompletedLateInMonth(date); let remindersSent = await selector.getNumberOfRemindersSent(date); let children = await selector.getPatientsNumber(false); let adults = await selector.getPatientsNumber(true); try { console.log(thisMonth) thisMonth = thisMonth.response[0].Number; completedOnTime = completedOnTime.response[0].Number; completedLate = completedLate.response[0].Number; remindersSent = remindersSent.response[0].Number; children = children.response[0].Number; adults = adults.response[0].Number; } catch(err) { console.log(err); return {success: false}; } return { success:true, response: { thisMonth: thisMonth, completedOnTime: completedOnTime, completedLate: completedLate, remindersSent: remindersSent, children: children, adults: adults }}; } /** * Get the patient given its patient number * @param {string} patient_no the patient number * @return {JSON} - {success:Boolean response:Array or Error} */ async function getPatient(patient_no) { return await selector.getPatient(patient_no); } /** * Get the info of the patient together with the info of eventual carers and hospitals * @param {string} patient_no the patient number * @return {JSON} - {success:Boolean response:Array or Error} */ async function getFullPatientInfo(patient_no) { return await selector.getFullPatientInfo(patient_no); } /** * Get the carer given its carer id * @param {string} carerID the carer id * @return {JSON} - {success:Boolean response:Array or Error} */ async function getCarer(carerID) { return await selector.getCarer(carerID); } /** * Get the hospital given its hospital id * @param {string} hospital_id the hospital id * @return {JSON} - {success:Boolean response:Array or Error} */ async function getHospital(hospital_id) { return await selector.getHospital(hospital_id); } /** * Get all the patients from the database * @param {Boolean} isAdult If the records should be displayed for adult users * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getAllPatients(isAdult) { return await selector.getAllPatients(isAdult); } /** * Get user from database * @param {String} username - username to retrieve * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getUser(username) { return await selector.getUser(username); } /** * Get all users from database * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getAllUsers() { return await selector.getAllUsers(); } /** * Get test from the database * @param {String} test_id - id of test * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getTest(test_id) { return await selector.getTest(test_id); } /** * Get not completed tests from patient * @param {String} patientId - id of patient * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getNextTestsOfPatient(patientId) { return await selector.getNextTestsOfPatient(patientId) } /** * Get test info with patient info from the database * @param {String} test_id - id of test * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getTestInfo(test_id) { return await selector.getTestInfo(test_id); } /** * Get all the overdue tests from the database plus additional info about time difference * @param {Boolean} isAdult If the records should be displayed for adult users * @return {JSON} result of the query - {success:true/false response:Array{SortedWeek}/Error} * @typedef {SortedWeek} * @property class {String} - monday of the week, format: 'Mon Mar 04 2019 00:00:00 GMT+0000 (GMT)' * @property tests {Array[JSON]} - tests within week **/ async function getSortedOverdueWeeks(isAdult) { return await selector.getSortedOverdueWeeks(isAdult) } /** * Get all tests within the week from the database * @param {String} date - any date (from Monday to Friday) within the week to retrieve (format: \"YYYY-MM-DD\") * @param {Boolean} isAdult If the records should be displayed for adult users * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function getTestWithinWeek(date, isAdult) { return await selector.getTestWithinWeek(date, isAdult); } /** * Returns overdue tests that are separated into two groups. One group are the tests that haven't been * sent a reminder. The other group are the tests that have already been sent a reminder. * Response includes some basic info about the test. * * @param {Boolean} isAdult If the records should be displayed for adult users * @returns {JSON} { * success: true|false, * response: { * notReminded: [{ * test_id: * due_date: * patient_no: * patient_name: * patient_surname: * }, ...] * reminded: [{ * test_id: * due_date: * patient_no: * patient_name: * patient_surname: * last_reminder: * reminders_sent: * }, ...] * } * } */ async function getOverdueReminderGroups(isAdult) { return await selector.getOverdueReminderGroups(isAdult); } /*===============================* UPDATE QUERIES *===============================*/ /** * Edit test query * @param testId The id of the test to be updated * @param {JSON} newInfo All the information of the test (new and old) * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editTest(testId, newInfo, token, actionUsername) { let scheduleNew = false; const testInfo = await getTest(testId); if (!testInfo.success) { return testInfo; } if (testInfo.response.length == 0) { return { success: false, response: \"No new tests added - No test found!\" }; } if (newInfo.completed_status == \"yes\" ||newInfo.completed_status == \"in review\") { scheduleNew = true; newInfo[\"completed_date\"] = dateformat(new Date(), \"yyyymmdd\"); } else { newInfo[\"completed_date\"] = \"NULL\"; } const res = await updater.editTest(testId, newInfo, token, actionUsername) if (res.success &amp;&amp; scheduleNew &amp;&amp;testInfo.response[0].completed_status == \"no\") { const insertedResponse = await scheduleNextTest(testId, actionUsername); if (insertedResponse.success) { res.response.new_date = insertedResponse.response.new_date; res.response.insertId = insertedResponse.response.insertId; } } return res; } /** * Edit patient query * @param {JSON} newInfo All the information of the patient to update * Obligatory fields in JSON * @property patient_no {String} * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editPatient(newInfo, token, actionUsername) { return await updater.editPatient(newInfo, token, actionUsername) } /** * Edit patient with hospital and carer query * @param {JSON} newInfo All the information of the patient/hospital/carer to update * @param token The token that grants edit privileges * @return {JSON} query result {success:Boolean response:{Response of each query as {success:Boolean response:Array/Error/String} or {} }} */ async function editPatientExtended(newInfo, token, actionUsername) { const patientResponse = await getPatient(newInfo.patient_no); console.log(newInfo); if (!patientResponse.success) { return patientResponse; } const patient = patientResponse.response[0]; //Separate into carer hospital and patient info const updateProperties = sortPatinetProperties(newInfo) const carer = updateProperties.carer; const hospital = updateProperties.hospital; const patientNewInfo = updateProperties.patient; let querySuccess = true; let carerQueryResponse = {}; if (Object.keys(carer).length &gt; 0 &amp;&amp; token) { //Carer added with patient update if (patient.carer_id == undefined ||patient.carer_id == null || patient.carer_id == \"NULL\") { carerQueryResponse = await addCarer(carer, actionUsername); if(carerQueryResponse.success){ patientNewInfo[\"carer_id\"] = carerQueryResponse.response.insertId; } } //Database has info on this carer else { const carerToken = await requestEditing(\"Carer\",patient.carer_id,actionUsername); carer[\"carer_id\"] = patient.carer_id; carerQueryResponse = await editCarer(carer, carerToken, actionUsername); } } else if (Object.keys(carer).length == 0 &amp;&amp; token &amp;&amp; patient.carer_id) { carerQueryResponse = await deleteCarer(patient.carer_id, actionUsername); } let hospitalQueryResponse = {}; if (Object.keys(hospital).length &gt; 0 &amp;&amp; token) { //Hospital added with update if (patient.hospital_id == undefined || patient.hospital_id == null || patient.hospital_id == \"NULL\") { hospitalQueryResponse = await addHospital(hospital, actionUsername); if(hospitalQueryResponse.success){ patientNewInfo[\"hospital_id\"] = hospitalQueryResponse.response.insertId; } } //Database has info on the hospital else { const hospitalToken = await requestEditing(\"Hospital\",patient.hospital_id,actionUsername); hospital[\"hospital_id\"] = patient.hospital_id; hospitalQueryResponse = await editHospital(hospital,hospitalToken,actionUsername); } } else if (Object.keys(hospital).length == 0 &amp;&amp;token &amp;&amp; patient.hospital_id) { hospitalQueryResponse = await deleteHospital(patient.hospital_id,actionUsername); } const patientUpdateResponse = await editPatient(patientNewInfo,token,actionUsername); if ((patientUpdateResponse.success === false &amp;&amp; typeof patientUpdateResponse.success != \"undefined\") || (hospitalQueryResponse.success === false &amp;&amp; typeof hospitalQueryResponse.success != \"undefined\") || (carerQueryResponse.success === false &amp;&amp; typeof carerQueryResponse.success != \"undefined\")){ querySuccess = false; } return { success: querySuccess, response: { patientQuery: patientUpdateResponse, hospitalQuery: hospitalQueryResponse, carerQuery: carerQueryResponse} }; } /** * Edit hospital query * @param {JSON} newInfo All the information of the hospital to update * Obligatory fields in JSON * @property hospital_id {String} * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editHospital(newInfo, token, actionUsername) { return await updater.editHospital(newInfo, token, actionUsername); } /** * Edit carer query * @param {JSON} newInfo All the information of the carer to update * @property carer_id {String} * @param token The token that grants edit privileges * @param {string} actionUsername The user who issued the request. */ async function editCarer(newInfo, token, actionUsername) { return await updater.editCarer(newInfo, token, actionUsername) } /** * Edit test due date - drag &amp; drop method * @param {String} testId Id of the test to update * @param {Date} newDate new due date * @returns result of the query - {success:Boolean response:Array/Error} */ async function changeTestDueDate(testId, newDate, actionUsername) { const token = await requestEditing(\"Test\", testId, actionUsername); const res = await updater.changeTestDueDate(testId,token, newDate, actionUsername) if (!res.success) { res.response = res.response.problem; } return res; } /** * Update User in database * @param {JSON} json - user * @param {string} actionUsername The user who issued the request. * Obligatory properties: * @property username {String}, * One of optional properties * Optional properties: * @property recovery_email {String} * @property hashed_password {String} * @return {JSON} - {success:Boolean response:Array or Error} **/ async function editUser(json, token, actionUsername) { const response = await getUser(json.username); if (!response.success) { return response; } if(response.response.length!=1){ return {success: false, response: \"No user found\" } } const user = {username: json.username} if(json.hashed_password){ const hash = authenticator.produceHash(json.hashed_password, response.response[0].iterations, response.response[0].salt); user[\"hashed_password\"] = hash; } if(json.recovery_email){ user[\"recovery_email\"] = json.recovery_email; } if(json.isAdmin){ user[\"isAdmin\"]=json.isAdmin; } return await updater.editUser(user, token, actionUsername); } /** * Change the status of the test in the database * @param {JSON} test * @param {string} actionUsername The user who issued the request. * @property testId {String} - id of a test to change * @property newStatus {enum: \"completed\"/\"late\"/\"inReview\"} - new status of a test * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function changeTestStatus(test, actionUsername) { const token = await requestEditing(\"Test\", test.testId, actionUsername); const testInfo = await getTest(test.testId); if (!testInfo.success) { return testInfo; } if (testInfo.response.length == 0) { return { success: false, response: \"No new tests added - No test found!\" }; } if(test.newStatus!=\"late\" &amp;&amp; test.newStatus != \"completed\" &amp;&amp; test.newStatus != \"inReview\"){ return { success: false, response: \"NO SUCH UPDATE\" }; } let scheduleNew = false; if (test.newStatus == \"completed\" || test.newStatus == \"inReview\"){ scheduleNew = true; } const res = await updater.changeTestStatus(test,token,actionUsername) if (res.success &amp;&amp;scheduleNew &amp;&amp;testInfo.response[0].completed_status == \"no\") { const insertedResponse = await scheduleNextTest(test.testId,actionUsername); if (insertedResponse.success) { res.response.new_date = insertedResponse.response.new_date; res.response.insertId = insertedResponse.response.insertId; } } return res; } /** * Update when the last reminder for this test was sent. * * @param {string} testId - id of a test to change * @param {string} token - The token that grants edit privileges. * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:true/false response:Array/Error} **/ async function updateLastReminder(testId, token, actionUsername) { return await updater.updateLastReminder(testId, token, actionUsername) } /** * Edit test colour - quick update. * * @param {String} testId Id of the test to update * @param {string} newColour - New colour to be stored. * @returns result of the query - {success:Boolean response:Array/Error} */ async function changeTestColour(testId, newColour, actionUsername) { const token = await requestEditing(\"Test\", testId, actionUsername); const res = await updater.changeTestColour(testId, newColour,token,actionUsername) if (!res.success) { res.response = res.response.problem; } return res; } /** * Edit patient colour - quick update. * * @param {String} patientNo Number of the patient to update * @param {string} newColour - New colour to be stored. * @returns result of the query - {success:Boolean response:Array/Error} */ async function changePatientColour(patientNo, newColour, actionUsername) { const token = await requestEditing(\"Patient\", patientNo, actionUsername); const res = await updater.changePatientColour(patientNo, newColour,token,actionUsername); if (!res.success) { res.response = res.response.problem; } return res; } /*===============================* INSERT QUERIES *===============================*/ /** * Add new user to the database * @param {JSON} - user * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property username {String} * @property hashed_password {String} * @property email {String} * @property isAdmin {string} \"yes\" | \"no\" * @return {JSON} result of the query - {success:Boolean} **/ async function addUser(json, actionUsername) { return await inserter.addUser(json, actionUsername) } /** * Add new test to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property patient_no * @property due_date * @return {JSON} result of the query - {success:Boolean} **/ async function addTest(json, actionUsername) { return await inserter.addTest(json, actionUsername) } /** * Add new patient to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property patient_no * @return {JSON} result of the query - {success:Boolean} **/ async function addPatient(json, actionUsername) { return await inserter.addPatient(json, actionUsername) } /** * Add new Hospital to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property hospital_email * @return {JSON} result of the query - {success:Boolean} **/ async function addHospital(json, actionUsername) { return await inserter.addHospital(json, actionUsername) } /** * Add new carer to the database * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * Obligatory properties within JSON * @property carer_email * @return {JSON} result of the query - {success:Boolean} **/ async function addCarer(json, actionUsername) { return await inserter.addCarer(json, actionUsername); } /** * Add new patient entry to the database with optional carer/hospital * @param {JSON} - entry to add * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:{insertedId/problem (+ optional fields)}} **/ async function addPatientExtended(patientInfo, actionUsername) { const properties = sortPatinetProperties(patientInfo) const carer = properties.carer; const hospital = properties.hospital; const patient = properties.patient; let carerInsertResponse = {}; //Try to add any data if (Object.keys(carer).length &gt; 0) { carerInsertResponse = await addCarer(carer, actionUsername); if (carerInsertResponse.success) { patient[\"carer_id\"] = carerInsertResponse.response.insertId; } } else { patient[\"carer_id\"] = \"NULL\"; } let hospitalInsertResponse = {}; //Try to add any data if (Object.keys(hospital).length &gt; 0) { hospitalInsertResponse = await addHospital(hospital, actionUsername); if (hospitalInsertResponse.success) { patient[\"hospital_id\"] = hospitalInsertResponse.response.insertId; } } else { patient[\"hospital_id\"] = \"NULL\"; } //Hospital query failed but carer was inserted if (patient.carer_id &amp;&amp; !patient.hospital_id) { let success = true; if (patient.carer_id != \"NULL\") { const deleteResponse = await deleteCarer(patient.carer_id,actionUsername); if (!deleteResponse.success) { success = false; } } return { success: false, response: { problem: \"Incorrect data for hospital\", delete:success}}; } //Carer query failed but hospital was inserted if (patient.hospital_id &amp;&amp; !patient.carer_id) { let success = true; if (patient.hospital_id != \"NULL\") { const deleteResponse = await deleteHospital(patient.hospital_id,actionUsername); if (!deleteResponse.success) { success = false; } } return { success: false, response: { problem: \"Incorrect data for carer\", delete: success}}; } //Both added correctly if (patient.hospital_id &amp;&amp; patient.carer_id) { const patientInsertResponse = await addPatient(patient, actionUsername); if (patientInsertResponse.success) { return { success: true, response: { insertedId: patient.patient_no } }; } //Query to insert patient failed else { let carer = true; let hospital = true; if (patient.carer_id != \"NULL\") { const deleteResponse = await deleteCarer(patient.carer_id,actionUsername); if (!deleteResponse.success) { carer = false; } } if (patient.hospital_id != \"NULL\") { const deleteResponse = await deleteHospital(patient.hospital_id,actionUsername); if (!deleteResponse.success) { hospital = false; } } return {success: false, response: {problem: \"Problem on patient insert\",carer: carer,hospital: hospital}}; } } else { return {success: false, response: { problem: \"Incorrect data for carer and hospital\"}}; } } /*===============================* DELETE QUERIES *===============================*/ /** * Delete Carer entry from database *@param {String} carerid - id of a carer to be deleted * @param {string} actionUsername The user who issued the request. *@return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deleteCarer(carerid, actionUsername) { return await deleter.deleteCarer(carerid, actionUsername) } /** * Delete hospital entry from database * @param {String} hospitalid - id of a hospital to be deleted * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deleteHospital(hospitalid, actionUsername) { return await deleter.deleteHospital(hospitalid, actionUsername); } /** * Delete Patient and cancel the patient edit token * @param {String} patientid - patient_no of a patient * @param {String} token - token to be returned with query * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deletePatient(patientid, token, actionUsername) { const check = await checkIfPatientsTestsAreEdited(patientid); if (check === true) { return { success: false, response: \"Someone is editing the test\" }; } if (check === false) { //Try returning token const tokenResponse = await returnToken(\"Patient\",patientid,token,actionUsername); if (!tokenResponse.success) { return tokenResponse; } //Patient with tests can be deleted return await deleter.deletePatient(patientid,actionUsername) } //Error on the check return check; } /** * Delete test entry from database * @param {String} testid - id of a test to be deleted * @param {string} actionUsername The user who issued the request. * @return {JSON} result of the query - {success:Boolean response:\"Entry deleted\"/Error} **/ async function deleteTest(testid, actionUsername) { return await deleter.deleteTest(testid, actionUsername); } /** * Unschedule test * @param testid {String} - id of the test to delete * @param token {String} - token to realease with the unscheduling * @param actionUsername {String} - username that triggered the action **/ async function unscheduleTest(testid, token, actionUsername) { const tokenRealeaseResponse = await returnToken(\"Test\",testid,token,actionUsername); if (!tokenRealeaseResponse.success) { return tokenRealeaseResponse; } return await deleteTest(testid, actionUsername); } /*===============================* HELPER FUNCTIONS BELOW: *===============================*/ /** * Check if test are edited within the EditTokens database * @return {Boolean} {false - If no tests are edited (no tokens)} * @return {Boolean} {true - If tests are edited (tokens in table)} * @return {JSON} {Error response} **/ async function checkIfPatientsTestsAreEdited(patientid) { const response = await selector.getPatientEditedTests(patientid); if (response.success &amp;&amp; response.response.length == 0) { return false; } if (response.success &amp;&amp; response.response.length &gt; 0) { return true; } return response; } /** * Get next due date of a test in \"YYYY-MM-DD\" format; relative to today * @param frequency {String} - frequency of the test as stored in database * @return {String} - next due date in \"YYYY-MM-DD\" format **/ function getNextDueDate(frequency, completed_date) { const nextDate = calendarController.getNextDueDate(frequency,new Date(completed_date)); return dateformat(new Date(nextDate), \"yyyymmdd\"); } /** * Schedule next blood test based on information in database and/or new information provided * New information have priority over stored in database (new info &gt; database info) * @param testId {String} - id of a string from which to take the info * @param {string} actionUsername The user who issued the request. * @param newInfo {JSON} - (optional) new info to add into database with new test * @return {JSON} - result of query {success:true/false reply:(optional;when no new entry inserted due to finished range of tests)} **/ async function scheduleNextTest(testId, actionUsername) { const response = await getTest(testId); const test = response.response[0]; if (test.frequency !== null &amp;&amp; test.occurrences &gt; 1) { const newTest = { patient_no: test.patient_no, frequency: test.frequency, due_date: getNextDueDate(test.frequency, test.completed_date), occurrences: test.occurrences - 1, notes: test.notes, test_colour: test.test_colour }; const response = await addTest(newTest, actionUsername); if (response.success) { response.response[\"new_date\"] = newTest.due_date; } return response; } return { success: true, response: \"No new tests\" }; } /** * Request editing of an entry in table * @param {String} table - Table to edit * @param {String} id - id to edit * @param {string} actionUsername The user who issued the request. * @return {String} token **/ async function requestEditing(table, id, actionUsername) { return await tokenConroller.requestEditing(table, id, actionUsername); } /** * Cancel editing on an entry * @param {String} table - Table of an entry * @param {String} id - id value of an entry * @param {String} token - token to return * @param {string} actionUsername The user who issued the request. * @return {JSON} result - {success:Boolean response:\"Token cancelled\"/Error} **/ async function returnToken(table, id, token, actionUsername) { return await tokenConroller.returnToken(table, id, token, actionUsername) } /** * Sort patient properties into patient,carer and hospital information * @param {JSON} patientInfo - information to be sorted * @return {JSON} Sorted information: {patient: hospital: carer:} **/ function sortPatinetProperties(patientInfo) { const objectProperties = Object.keys(patientInfo); const patient = {}; const carer = {}; const hospital = {}; for (let i = 0; i &lt; objectProperties.length; i++){ if (objectProperties[i].startsWith(\"carer\") || objectProperties[i] == \"relationship\") { carer[objectProperties[i]] = patientInfo[objectProperties[i]]; } if (objectProperties[i].startsWith(\"hospital\")) { hospital[objectProperties[i]] = patientInfo[objectProperties[i]]; } if (objectProperties[i].startsWith(\"patient\") ||objectProperties[i] == \"additional_info\" || objectProperties[i] == \"isAdult\") { patient[objectProperties[i]] = patientInfo[objectProperties[i]]; } } return {patient: patient, carer:carer, hospital:hospital} } module.exports = { //SELECTS getPatient, getTest, getHospital, getCarer, getUser, getAllUsers, getAllPatients, getFullPatientInfo, getTestInfo, getNextTestsOfPatient, getTestWithinWeek, getSortedOverdueWeeks, getOverdueReminderGroups, getMonthlyReport, //INSERTS addTest, addUser, addPatient, addHospital, addPatientExtended, addCarer, //UPDATES editTest, editCarer, editHospital, editPatient, editPatientExtended, updateLastReminder, changeTestStatus, changeTestDueDate, changeTestColour, changePatientColour, editUser, //DELETE deleteHospital, deletePatient, deleteCarer, unscheduleTest, deleteTest, //TOKEN CONTROL requestEditing, returnToken, //Helper functions - for tests only sortPatinetProperties, scheduleNextTest, checkIfPatientsTestsAreEdited, getNextDueDate, }; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_report-generator.js.html":{"id":"server_lib_report-generator.js.html","title":"Source: server/lib/report-generator.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/report-generator.js /** * This module provides function for reports generation. * * @author Luka Kralj * @version 1.0 * @module report-generator */ module.exports = { getMonthlyReport } const queryController = require('./query-controller'); const dateformat = require('dateformat'); const actionLogger = require('./action-logger'); /** * Generate monthly report for a particular month. * * @param {string} month * @param {string} actionUsername User who requested the report * @returns {JSON} {success:Boolean, html: string} */ async function getMonthlyReport(month, actionUsername) { const date = getDate(month); if (date === undefined) { return {success:false, response: \"Report could not be generated.\"}; } let res = await queryController.getMonthlyReport(date); if (!res.success) { return {success:false, response: \"Report could not be generated.\"}; } // Log to keep track of who generated the files. actionLogger.logOther(actionUsername, \"User\", actionUsername, \"This user requested a monthly report.\") const timestamp = dateformat(new Date(), \"d mmmm yyyy, 'at' HH:MM:ss\"); res = res.response; const html = ` &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Monthly report - Blood Test Diary&lt;/title&gt; &lt;style&gt; h1 { text-align: center; } h3 { text-align: center; } body { font-family: Arial, Helvetica, sans-serif; } table { width: 100%; border-collapse: collapse; padding: 5px 0 10px 0; } th, td { padding: 10px 0 0 0; border-bottom: 1px solid black; } .rtd { text-align: right; } main { width: 90%; margin-left: 5%; margin-right: 5%; } p { padding: 5px 0 10px 0; } #end { text-align: right; padding: 10px 0 5px 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;King's College Hospital&lt;/h3&gt; &lt;h1&gt;Blood Test Diary&lt;br&gt;-&lt;br&gt;MONTHLY REPORT&lt;/h1&gt; &lt;br&gt; Generated on: ${timestamp}&lt;br&gt; Generated by: ${actionUsername} &lt;hr&gt; &lt;main&gt; &lt;p&gt;This is an automatically generated report for ${month}.&lt;/p&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Number of tests, due in ${month}:&lt;/td&gt; &lt;td class='rtd'&gt;${res.thisMonth == null ? \"0\" : res.thisMonth}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tests, completed on time in ${month}:&lt;/td&gt; &lt;td class='rtd'&gt;${res.completedOnTime == null ? \"0\" : res.completedOnTime}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tests, completed late in ${month}:&lt;/td&gt; &lt;td class='rtd'&gt;${res.completedLate == null ? \"0\" : res.completedLate}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Number of reminders sent in ${month}:&lt;/td&gt; &lt;td class='rtd'&gt;${res.remindersSent == null ? \"0\" : res.remindersSent}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;In the system, there is currently ${res.children == null ? \"0\" : res.children} patients under 12 years old and ${res.adults == null ? \"0\" : res.adults} patient that are 12 years old or older.&lt;/p&gt; &lt;div id='end'&gt;&lt;b&gt;End of report.&lt;/b&gt;&lt;/div&gt; &lt;/main&gt; &lt;hr&gt;&lt;p&gt;&lt;i&gt;This document may contain confidential information.&lt;br&gt;Please take caution who you share this information with.&lt;/i&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;`; return {success:true, html: html}; } /** * Transforms string into a valid date in that month. * * @param {string} month * @returns {Date} */ function getDate(month) { const date = new Date(); switch(month) { case \"January\": date.setMonth(0); break; case \"February\": date.setMonth(1); break; case \"March\": date.setMonth(2); break; case \"April\": date.setMonth(3); break; case \"May\": date.setMonth(4); break; case \"June\": date.setMonth(5); break; case \"July\": date.setMonth(6); break; case \"August\": date.setMonth(7); break; case \"September\": date.setMonth(8); break; case \"October\": date.setMonth(9); break; case \"November\": date.setMonth(10); break; case \"December\": date.setMonth(11); break; default: return undefined; } return date; } Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_app.js.html":{"id":"server_app.js.html","title":"Source: server/app.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/app.js /** * The module responsible for all the queries on the database * and processing of the data retrieved. * @module server * @author Mateusz Nowak, Jacopo Madaluni, Luka Kralj * @version 0.0.1 */ //the logger has to be required before anything else so that the right output file path is specified const logger = require('./lib/logger') logger.changeOption(\"outputFilePath\", __dirname + \"/logs\") const app = require('express')(); const http = require('http').Server(app); const io = require('socket.io')(http); const queryController = require('./lib/query-controller.js'); const CONFIG_FILE_PATH = __dirname + '/config/config.json'; const jsonController = require('./lib/json-parser'); const conf = jsonController.getJSON(CONFIG_FILE_PATH); const port = conf.port; const authenticator = require(\"./lib/authenticator.js\"); const email_controller = require('./lib/email/email-controller'); const reportGenerator = require('./lib/report-generator'); http.listen(port); // to broadcast in room =&gt; io.in(\"room\").emit(\"change\", json); io.on('connection',function(socket) { // ============== // CONNECTIVITY // ============== logger.info(`Socket ${socket.id} connected`); socket.emit(\"connected\"); socket.on(\"disconnect\", () =&gt; { logger.info(`Socket ${socket.id} disconnected`); }); socket.on(\"join\", (oldRoom, room, reconnecting=false) =&gt; { if (reconnecting){ if (socket.rooms[room] !== undefined){ return; } } if (oldRoom !== room){ if (oldRoom !== \"\"){ socket.leave(oldRoom); logger.info(`Socket ${socket.id} left ${oldRoom}`); } socket.join(room); logger.info(`Socket ${socket.id} joined ${room}`); socket.emit(\"joined\", room); } }); // ============== // AUTHENTICATION // ============== /** * Login endpoint. * @param {username:username, password:password} credentials Hashed json of credentials * @return {Boolean} True if credentials are correct */ socket.on('authenticate', async (credentials) =&gt; { logger.info(`Authentication request from ${socket.id}`); const user = await queryController.getUser(credentials.username); let res = authenticator.canLogin(credentials,user.response); let accessToken = undefined; if (res) { accessToken = await authenticator.registerNewUsername(credentials.username); } logger.info(\"access token: \" + accessToken); // TODO: return to user logger.info(`Authentication ${res ? \"successful\" : \"unsuccessful\"}`); if (res) { res = {success:true, accessToken: accessToken}; } else { res = {success:false}; } socket.emit('authenticationResponse', res); }); socket.on(\"logout\", async (accessToken) =&gt; { if (!accessToken) { // REQUIRE TOKEN. socket.emit(\"logoutResponse\", { success:false, response: \"Authentication required.\" }); return; } const res = await authenticator.logoutUser(accessToken); if (!res) { // INVALID TOKEN. socket.emit(\"logoutResponse\", { success:false, response: \"Invalid credentials.\" }); return; } socket.emit(\"logoutResponse\", { success:true, response: \"User logged out.\" }); }); // ============== // GETTERS // ============== socket.on('getAllPatients', async (accessToken,isAdult=true) =&gt; { if (!accessToken) { socket.emit(\"getAllPatientsResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getAllPatientsResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getAllPatients(isAdult); socket.emit(\"getAllPatientsResponse\", {success: true, response: response.response}); }); socket.on(\"getFullPatientInfo\", async (patientId, accessToken) =&gt; { if (!accessToken) { socket.emit(\"getFullPatientInfoResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getFullPatientInfoResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getFullPatientInfo(patientId); socket.emit(\"getFullPatientInfoResponse\", {success: true, response: response.response}); }); socket.on('getNextTestsOfPatient', async (patientId, accessToken) =&gt; { if (!accessToken) { socket.emit(\"getNextTestsOfPatientResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getNextTestsOfPatientResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getNextTestsOfPatient(patientId); socket.emit('getNextTestsOfPatientResponse', response); }); /** *@param {String} date of type \"yyyy-mm-dd\" *@param {Boolean} anydayTestsOnly - if unscheduled test to return **/ //TODO: PASS \"isAdult\" VARIABLE (BOOLEAN) FROM THE UI socket.on('getTestsInWeek',async (date, accessToken,isAdult=true) =&gt; { if (!accessToken) { socket.emit(\"getTestsInWeekResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getTestsInWeekResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getTestWithinWeek(date,isAdult); socket.emit('getTestsInWeekResponse', {success: true, response: response.response}); }); //TODO: PASS \"isAdult\" VARIABLE (BOOLEAN) FROM THE UI socket.on('getOverdueTests', async (accessToken,isAdult=true) =&gt; { if (!accessToken) { socket.emit(\"getOverdueTestsResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getOverdueTestsResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } //const response = await queryController.getOverdueGroups(); const response = await queryController.getSortedOverdueWeeks(isAdult); socket.emit('getOverdueTestsResponse', {success: true, response: response.response}); }); socket.on('getTestInfo', async (testId, accessToken) =&gt; { if (!accessToken) { socket.emit(\"getTestInfoResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getTestInfoResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getTestInfo(testId); socket.emit(\"getTestInfoResponse\", response); }); //TODO: PASS \"isAdult\" VARIABLE (BOOLEAN) FROM THE UI socket.on('getOverdueReminderGroups', async (accessToken,isAdult=true) =&gt; { if (!accessToken) { socket.emit(\"getOverdueReminderGroupsResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getOverdueReminderGroupsResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getOverdueReminderGroups(isAdult); socket.emit(\"getOverdueReminderGroupsResponse\", response); }); socket.on('getUser', async (accessToken, user=undefined) =&gt; { if (!accessToken) { socket.emit(\"getUserResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getUserResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } if (user === undefined) { // User can retrieve their info. const response = await queryController.getUser(username); socket.emit(\"getUserResponse\", response); return; } let canRetrieve = false; try { const admin = (await queryController.getUser(username)).response[0]; if (admin.isAdmin === \"yes\") { canRetrieve = true; } } catch(err) { logger.error(err); } if (!canRetrieve) { socket.emit(\"getUserResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getUser(user); if (response.success) { delete response.response[0].hashed_password; delete response.response[0].salt; delete response.response[0].iterations; } socket.emit(\"getUserResponse\", response); }); socket.on('getAllUsers', async (accessToken) =&gt; { if (!accessToken) { socket.emit(\"getAllUsersResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"getAllUsersResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } let canRetrieve = false; try { const admin = (await queryController.getUser(username)).response[0]; if (admin.isAdmin === \"yes\") { canRetrieve = true; } } catch(err) { logger.error(err); } if (!canRetrieve) { socket.emit(\"getAllUsersResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.getAllUsers(); socket.emit(\"getAllUsersResponse\", response); }); // ============== // ADDING // ============== socket.on(\"addTest\", async (patientId, date, notes, frequency, occurrences, accessToken) =&gt; { logger.debug(\"New info: \", date, notes, \"f: \"+frequency, \"o: \"+occurrences); if (!accessToken) { socket.emit(\"addTestResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"addTestResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const test = {patient_no:patientId, due_date:date, notes:notes, frequency:frequency, occurrences:occurrences} const response = await queryController.addTest(test, username); if (response.success){ socket.emit(\"addTestResponse\", {success: true}); io.in(\"main_page\").emit(\"testAdded\") }else{ socket.emit(\"addTestResponse\", {success: false}); logger.info(\"error in insert\"); } }); socket.on(\"addPatient\", async (newPatient, accessToken) =&gt; { if (!accessToken) { socket.emit(\"addPatientResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"addPatientResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.addPatientExtended(newPatient, username); if (response.success){ socket.emit(\"addPatientResponse\", {success: true, response: response.response}); io.in(\"patients_page\").emit(\"patientEdited\", newPatient.patient_no, newPatient); }else{ socket.emit(\"addPatientResponse\", {success: false}); } }); socket.on(\"addUser\", async (newUser, accessToken) =&gt; { if (!accessToken) { socket.emit(\"addUserResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"addUserResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } let canInsert = false; try { const admin = (await queryController.getUser(username)).response[0]; if (admin.isAdmin === \"yes\") { canInsert = true; } } catch(err) { logger.error(err); } if (!canInsert) { socket.emit(\"addUserResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.addUser(newUser, username); if (response.success){ socket.emit(\"addUserResponse\", {success: true, response: response.response}); // TODO: do we need this? //io.in(\"patients_page\").emit(\"patientEdited\", newPatient.patient_no, newPatient); }else{ socket.emit(\"addUserResponse\", {success: false}); } }); // ============== // EDIT TOKEN EXCHANGE // ============== socket.on(\"requestTestEditToken\", async (testId, accessToken) =&gt; { if (!accessToken) { socket.emit(\"requestTestEditTokenResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"requestTestEditTokenResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } let response = await queryController.requestEditing(\"Test\", testId, username); if (response) { response = {success: true, token: response} } else { response = {success: false} } socket.emit(\"requestTestEditTokenResponse\", response); }); socket.on(\"requestPatientEditToken\", async (patientId, accessToken) =&gt; { if (!accessToken) { socket.emit(\"requestPatientEditTokenResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"requestPatientEditTokenResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } let response = await queryController.requestEditing(\"Patient\", patientId, username); if (response) { response = {success: true, token: response} } else { response = {success: false} } socket.emit(\"requestPatientEditTokenResponse\", response); }); socket.on(\"requestUserEditToken\", async (user, accessToken) =&gt; { if (!accessToken) { socket.emit(\"requestUserEditTokenResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"requestUserEditTokenResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } let canRequest = false; try { const admin = (await queryController.getUser(username)).response[0]; if (user === username || admin.isAdmin === \"yes\") { canRequest = true; } } catch(err) { logger.error(err); } if (!canRequest) { socket.emit(\"requestUserEditTokenResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } let response = await queryController.requestEditing(\"User\", user, username); if (response) { response = {success: true, token: response} } else { response = {success: false} } socket.emit(\"requestUserEditTokenResponse\", response); }); socket.on(\"discardTestEditing\", async (id, token, accessToken) =&gt; { if (!accessToken) { socket.emit(\"discardTestEditingResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"discardTestEditingResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.returnToken(\"Test\", id, token, username); socket.emit(\"discardTestEditingResponse\", response); }); socket.on(\"discardPatientEditing\", async (id, token, accessToken) =&gt; { if (!accessToken) { socket.emit(\"discardPatientEditingResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"discardPatientEditingResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.returnToken(\"Patient\", id, token, username); socket.emit(\"discardPatientEditingResponse\", response); }); socket.on(\"discardUserEditing\", async (id, token, accessToken) =&gt; { if (!accessToken) { socket.emit(\"discardUserEditingResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"discardUserEditingResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.returnToken(\"User\", id, token, username); socket.emit(\"discardUserEditingResponse\", response); }); // ============== // DELETING // ============== socket.on(\"deletePatient\", async (patientId, token, accessToken) =&gt; { if (!accessToken) { socket.emit(\"deletePatientResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"deletePatientResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.deletePatient(patientId, token, username); logger.debug(response) if (response.success){ socket.emit(\"deletePatientResponse\", {success: true}); io.in(\"patients_page\").emit(\"patientEdited\"); io.in(\"main_page\").emit(\"testAdded\"); }else{ socket.emit(\"deletePatientResponse\", {success: false}); } }); socket.on(\"unscheduleTest\", async (testId, token, accessToken) =&gt; { if (!accessToken) { socket.emit(\"unscheduleTestResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"unscheduleTestResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.unscheduleTest(testId, token, username); if (response.success){ socket.emit(\"unscheduleTestResponse\", { success:true }); io.in(\"main_page\").emit(\"testAdded\"); }else{ socket.emit(\"unscheduleTestResponse\", {success:false, message: \"Something went wrong\"}); } }); // ============== // UPDATING // ============== socket.on('testStatusChange', async (testId, newStatus, accessToken) =&gt; { if (!accessToken) { socket.emit(\"testStatusChangeResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"testStatusChangeResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const test = {testId: testId, newStatus: newStatus} const response = await queryController.changeTestStatus(test, username); if (response.success){ socket.emit('testStatusChangeResponse', {success: true, response: response.response}); io.in(\"main_page\").emit('testAdded'); }else{ socket.emit('testStatusChangeResponse', {success: false}); } }); socket.on(\"editTest\", async (testId, newInfo, token, accessToken) =&gt; { logger.debug(\"New info: \", newInfo); if (!accessToken) { socket.emit(\"editTestResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"editTestResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.editTest(testId, newInfo, token, username); logger.info({response}); if (response.success){ socket.emit(\"editTestResponse\", {success: true, response: response.response}); //socket.emit(\"testAdded\"); io.in(\"main_page\").emit(\"testAdded\"); } else { socket.emit(\"editTestResponse\", {success: false}); } }); socket.on(\"changeTestDueDate\", async (testId, newDate, accessToken) =&gt; { if (!accessToken) { socket.emit(\"changeTestDueDateResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"changeTestDueDateResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.changeTestDueDate(testId, newDate, username); if (response.success){ socket.emit(\"changeTestDueDateResponse\", {success: true}); io.in(\"main_page\").emit(\"testAdded\"); }else{ socket.emit(\"changeTestDueDateResponse\", {success: false}); } }); socket.on(\"editPatient\", async (patientId, newInfo, token, accessToken) =&gt; { if (!accessToken) { socket.emit(\"editPatientResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"editPatientResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } logger.info(token); const response = await queryController.editPatientExtended(newInfo, token, username); logger.info(response); if (response.success){ socket.emit(\"editPatientResponse\", {success: true}); } else { socket.emit(\"editPatientResponse\", response); } // !important to be here and not in the if statement! io.in(\"patients_page\").emit(\"patientEdited\", patientId, newInfo); }); socket.on(\"changeTestColour\", async (testId, newColour, accessToken) =&gt; { if (!accessToken) { socket.emit(\"changeTestColourResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"changeTestColourResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.changeTestColour(testId, newColour, username); if (response.success){ socket.emit(\"changeTestColourResponse\", {success: true}); io.in(\"main_page\").emit(\"testAdded\"); }else{ socket.emit(\"changeTestColourResponse\", {success: false}); } }); socket.on(\"changePatientColour\", async (patientNo, newColour, accessToken) =&gt; { if (!accessToken) { socket.emit(\"changePatientColourResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"changePatientColourResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.changePatientColour(patientNo, newColour, username); logger.info(response) if (response.success){ socket.emit(\"changePatientColourResponse\", {success: true}); io.in(\"main_page\").emit(\"testAdded\"); }else{ socket.emit(\"changePatientColourResponse\", {success: false}); } }); socket.on(\"editUser\", async (newData, token, accessToken) =&gt; { if (!accessToken) { socket.emit(\"editUserResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"editUserResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } let canEdit = false; try { const admin = (await queryController.getUser(username)).response[0]; if (newData.username === username || admin.isAdmin === \"yes\") { canEdit = true; } } catch(err) { logger.error(err); } if (!canEdit) { socket.emit(\"editUserResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const response = await queryController.editUser(newData, token, username); logger.info(response); if (response.success){ socket.emit(\"editUserResponse\", {success: true, response: response.response}); // TODO: do we need this? //io.in(\"patients_page\").emit(\"patientEdited\", newPatient.patient_no, newPatient); }else{ socket.emit(\"editUserResponse\", {success: false}); } }); // ============== // OTHER // ============== //TODO: ADD CLIENT CONNECTION HERE //PARAMETER - (STRING) USERNAME TO CHANGE PASSWORD socket.on('passwordRecoverRequest', async (username) =&gt; { const passwordResponse = await email_controller.recoverPassword(username); socket.emit('passwordRecoverResponse', passwordResponse); }); socket.on('sendOverdueReminders', async (testID, accessToken) =&gt; { if (!accessToken) { socket.emit(\"sendOverdueRemindersResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"sendOverdueRemindersResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } if (!Array.isArray(testID)) { testID = [testID]; } const response = await email_controller.sendOverdueReminders(testID, username); socket.emit(\"sendOverdueRemindersResponse\", response); }); socket.on('sendNormalReminders', async (testID, accessToken) =&gt; { if (!accessToken) { socket.emit(\"sendNormalRemindersResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"sendNormalRemindersResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } if (!Array.isArray(testID)) { testID = [testID]; } const response = await email_controller.sendNormalReminders(testID, username); socket.emit(\"sendNormalRemindersResponse\", response); }); socket.on('generateMonthlyReport', async (month, accessToken) =&gt; { if (!accessToken) { socket.emit(\"generateMonthlyReportResponse\", { success:false, errorType:\"authentication\", response: \"Authentication required.\" }); return; } const username = await authenticator.verifyToken(accessToken); if (!username) { socket.emit(\"generateMonthlyReportResponse\", { success:false, errorType:\"authentication\", response: \"Invalid credentials.\" }); return; } const res = await reportGenerator.getMonthlyReport(month, username); socket.emit(\"generateMonthlyReportResponse\", res); }); }); Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"client_src_serverConnection.js.html":{"id":"client_src_serverConnection.js.html","title":"Source: client/src/serverConnection.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: client/src/serverConnection.js /** * This file establishes a socket connection with the server and provides every single * protocol need by every component of the UI * The socket connection can be created by using the only method available to the public (getServerConnect()) * which will return a ServerConnect object. That object represent a socket connection and will be * univoque and shared between all client components. * Every protocol will be available through this object. * @module serverConnection * @author Danilo Del Busso, Mateusz Nowak, Jacopo Madaluni * @version 0.0.2 */ import openSocket from 'socket.io-client'; import Cookies from 'universal-cookie'; const cookies = new Cookies(); const host = decodeURIComponent(cookies.get(\"ip\")); const port = cookies.get(\"port\"); const underTwelve = 0; const overTwelve = 1; class ServerConnect { constructor(){ this.loginToken = cookies.get(\"accessToken\"); this.currentRoom = \"\"; this.socket = openSocket(`${host}:${port}`); this.currentMode = overTwelve; /** * Triggered when a connection is established. */ this.onConnected = undefined; this.socket.on(\"connected\", () =&gt; { this.socket.emit(\"join\", \"\", this.currentRoom, true); this.onConnected(); }); /** * Triggered when the connection is lost. */ this.onDisconnect = undefined; this.socket.on(\"disconnect\", () =&gt; { this.onDisconnect(); }); this.onRoomJoin = undefined; this.socket.on(\"joined\", room =&gt; { this.onRoomJoin(room); }); /** * Triggered when a new test is added. */ this.onTestAdded = undefined; this.socket.on(\"testAdded\", newTest =&gt; { this.onTestAdded(newTest); }); /** * Triggered when a patient is edited. */ this.onPatientEdit = undefined; this.socket.on(\"patientEdited\", (patientId, newInfo) =&gt; { this.onPatientEdit(patientId, newInfo); }); } isAdmin(){ return this.currentUser.isAdmin === \"yes\"; } setUnderTwelve(){ this.currentMode = underTwelve; } setOverTwelve(){ this.currentMode = overTwelve; } isUnderTwelve(){ return this.currentMode == underTwelve; } /** * Protocol to delete the current authentication token. */ deleteLoginToken(){ this.loginToken = undefined; cookies.set('accessToken', \"\", { path: '/' }); } initSession(token, callback){ this.setLoginToken(token); callback(); } /** * Set the current authentication token. * @param {String} token the new token */ setLoginToken(token){ this.loginToken = token; cookies.set('accessToken', token, { path: '/' }); } /** * Joins the main page room in the server. */ joinMainPage(){ this.socket.emit(\"join\", this.currentRoom, \"main_page\"); this.currentRoom = \"main_page\"; } /** * Joins the login page room in the server. */ joinLoginPage(){ this.socket.emit(\"join\", this.currentRoom, \"login_page\"); this.currentRoom = \"login_page\"; } /** * Joins the patients page room in the server. */ joinPatientsPage(){ this.socket.emit(\"join\", this.currentRoom, \"patients_page\"); this.currentRoom = \"patients_page\"; } setOnRoomJoin(callback){ this.onRoomJoin = callback; } /** * Sets the callback to be called when socket.on(\"connected\") is triggered. * @param {function} callback */ setOnConnect(callback){ this.onConnected = callback; } /** * Sets the callback to be called when socket.on(\"disconnect\") is triggered. * @param {function} callback */ setOnDisconnect(callback){ this.onDisconnect = callback; } /** * Sets the callback to be called when a new test is added * (when socket.on(\"testAdded\")) is triggered * @param {function} callback */ setOnTestAdded(callback){ this.onTestAdded = callback; } /** * Sets the callback to be called when a patient is edited * (when socket.on(\"patientEdited\") is triggered) * @param {function} callback */ setOnPatientEdited(callback){ this.onPatientEdit = callback; } /** * Function to be called when user needs to be authenticated * @param {JSON} credentials * @param {function} callback The callback function to be called on response * @example login({username: \"exampleUsername\", password: \"examplePassword\"}) */ login(credentials, callback){ this.socket.emit('authenticate', credentials); this.socket.once('authenticationResponse', res =&gt; { callback(res); }); } /** * Function to be called before logout. * Asks the server to get rid of the authentication token stored in the db * @param callback The callback function to be called on response */ logout(callback){ this.socket.emit(\"logout\", this.loginToken); this.socket.once(\"logoutResponse\", res =&gt; { if (res.success){ this.deleteLoginToken(); } callback(res); }); } getCurrentUser(callback){ this.socket.emit(\"getUser\", this.loginToken); this.socket.once(\"getUserResponse\", res =&gt; { callback(res); }); } getAllUsers(callback){ this.socket.emit(\"getAllUsers\", this.loginToken); this.socket.once(\"getAllUsersResponse\", res =&gt; { callback(res); }); } /** * Function to be called when all patients have to be retrieved. * @param {function} callback The callback function to be called on response */ getAllPatients(callback){ let isAdult = this.currentMode == overTwelve; this.socket.emit('getAllPatients', this.loginToken, isAdult); this.socket.once(\"getAllPatientsResponse\", res =&gt; { callback(res); }); } /** * Retrieves all information regarding a patient, calls the callback with the response. * @param {String} patientId The id of the patient * @param {function} callback */ getFullPatientInfo(patientId, callback){ this.socket.emit(\"getFullPatientInfo\", patientId, this.loginToken); this.socket.once(\"getFullPatientInfoResponse\", res =&gt; { callback(res); }); } /** * Retrieves all the tests of a particular patient, calls the callback with the response * @param {String} patientId The id of the patient we want to retrieve the information of. * @param {function} callback */ getNextTestsOfPatient(patientId, callback){ this.socket.emit('getNextTestsOfPatient', patientId, this.loginToken); this.socket.once('getNextTestsOfPatientResponse', res =&gt; { callback(res); }); } /** * Retrieves all overdue tests, calls the callback with the response. * @param {function} callback */ getOverdueTests(callback){ let isAdult = this.currentMode == overTwelve; this.socket.emit('getOverdueTests', this.loginToken, isAdult); this.socket.once('getOverdueTestsResponse', res =&gt; { callback(res); }); } /** * Retrieves all tests in a week, calls the callback with the response. * @param {Date} date Any date on the week we want to select * @param {boolean} anydayTestsOnly True if you only want the tests that are not scheduled on a particular day. * @param {function} callback */ getTestsInWeek(date, callback){ let isAdult = this.currentMode == overTwelve; this.socket.emit('getTestsInWeek', date, this.loginToken, isAdult); this.socket.once('getTestsInWeekResponse', res =&gt; { callback(res); }); } /** * Retrieves the information regarding a test, calls the callback with the response. * @param {int} testId The id of the test * @param {function} callback */ getTestInfo(testId, callback){ this.socket.emit(\"getTestInfo\", testId, this.loginToken); this.socket.once(\"getTestInfoResponse\", res =&gt; { callback(res.response[0]); }); } /** * Requests a token to edit the choosen test, calls the callback with the response. * @param {int} testId The id of the test * @param {function} callback */ requestTestEditing(testId, callback){ this.socket.emit(\"requestTestEditToken\", testId, this.loginToken); this.socket.once(\"requestTestEditTokenResponse\", res =&gt; { callback(res); }); } /** * Requests a token to edit the choosen patient, calls the callback with the response. * @param {String} patientId The id of the patient * @param {function} callback */ requestPatientEditing(patientId, callback){ this.socket.emit(\"requestPatientEditToken\", patientId, this.loginToken); this.socket.once(\"requestPatientEditTokenResponse\", res =&gt; { callback(res); }); } requestUserEditing(username, callback){ this.socket.emit(\"requestUserEditToken\", username, this.loginToken); this.socket.once(\"requestUserEditTokenResponse\", res =&gt; { callback(res); }); } /** * Requests the distruction of the token previously received to edit a test, calls the callback with the response. * @param {int} testId The id of the test * @param {String} token The token to destroy. * @param {function} callback */ discardTestEditing(testId, token, callback){ this.socket.emit(\"discardTestEditing\", testId, token, this.loginToken); this.socket.once(\"discardTestEditingResponse\", res =&gt; { callback(res); }); } /** * Requests the distruction of the token previously received to edit a patient, calls the callback with the response. * @param {int} patientId The id of the patient * @param {String} token The token to destroy. * @param {function} callback */ discardPatientEditing(patientId, token, callback){ this.socket.emit(\"discardPatientEditing\", patientId, token, this.loginToken); this.socket.once(\"discardPatientEditingResponse\", res =&gt; { callback(res); }); } discardUserEditing(username, token, callback){ this.socket.emit(\"discardUserEditing\", username, token, this.loginToken); this.socket.once(\"discardUserEditingResponse\", res =&gt; { callback(res); }) } addUser(newUser, callback){ this.socket.emit(\"addUser\", newUser, this.loginToken); this.socket.once(\"addUserResponse\", res =&gt; { callback(res); }); } addPatient(newPatient, callback){ this.socket.emit(\"addPatient\", newPatient, this.loginToken); this.socket.once(\"addPatientResponse\", res =&gt; { callback(res); }); } deletePatient(patientId, token, callback){ this.socket.emit(\"deletePatient\", patientId, token, this.loginToken); this.socket.once(\"deletePatientResponse\", res =&gt; { callback(res); }); } /** * Thim method emits a request to add a test into the database, calls the callback with the response * @param {String} patientId The number of the patient that has to take the test. * @param {Date} date The first due date of the test * @param {String} notes Additional info about the test * @param {String} frequency The frequency of the test * @example var frequencyExample = \"3:W\"; // Read db manual for more info * @param {int} occurrences The number of times to repeat the test * @param {function} callback */ addTest(patientId, date, notes, frequency, occurrences, callback){ this.socket.emit(\"addTest\", patientId, date, notes, frequency, occurrences, this.loginToken); this.socket.once(\"addTestResponse\", res =&gt; { callback(res); }); } /** * Thim method emits a request to add a test into the database, calls the callback with the response * @param {int} testId The id of the test to be changed. * @param {String} newStatus The new status of the test * @example var statusExample = \"completed\" // Read db manual for more info * @param {function} callback */ changeTestStatus(testId, newStatus, callback){ this.socket.emit('testStatusChange', testId, newStatus, this.loginToken); this.socket.once(\"testStatusChangeResponse\", res =&gt; { callback(res); }); } /** * Thim method emits a request to change a test due date, calls the callback with the response * @param {int} testId The id of the test to be changed. * @param {Date} newDate The new status of the test * @param {function} callback */ changeTestDueDate(testId, newDate, callback){ this.socket.emit(\"changeTestDueDate\", testId, newDate, this.loginToken); this.socket.once(\"changeTestDueDateResponse\", res =&gt; { callback(res); }); } /** * Thim method emits a request to edit a test into the database, calls the callback with the response. * @param {int} testId The id of the test to be changed. * @param {JSON} newData All the information about the test * @param {String} token The token that grants editing priviledges. * @param {function} callback */ editTest(testId, newData, token, callback){ this.socket.emit(\"editTest\", testId, newData, token, this.loginToken); this.socket.once(\"editTestResponse\", response =&gt; { callback(response); }); } /** * Thim method emits a request to edit a patient into the database, calls the callback with the response. * @param {String} patientId The id of the patient to be changed. * @param {JSON} newData All the information about the patient * @param {String} token The token that grants editing priviledges. * @param {function} callback */ editPatient(patientId, newData, token, callback){ this.socket.emit(\"editPatient\", patientId, newData, token, this.loginToken); this.socket.once(\"editPatientResponse\", res =&gt; { callback(res); }); } editUser(newData, token, callback){ this.socket.emit(\"editUser\", newData, token, this.loginToken); this.socket.once(\"editUserResponse\", res =&gt; { callback(res); }); } unscheduleTest(testId, token, callback){ this.socket.emit(\"unscheduleTest\", testId, token, this.loginToken); this.socket.once(\"unscheduleTestResponse\", res =&gt; { callback(res); }); } getOverdueReminderGroups(callback){ let isAdult = this.currentMode == overTwelve; this.socket.emit(\"getOverdueReminderGroups\", this.loginToken, isAdult); this.socket.once(\"getOverdueReminderGroupsResponse\", res =&gt; { callback(res); }); } sendOverdueReminders(testIds, callback){ this.socket.emit(\"sendOverdueReminders\", testIds, this.loginToken); this.socket.once(\"sendOverdueRemindersResponse\", res =&gt; { callback(res); }); } sendNormalReminders(testId, callback){ this.socket.emit(\"sendNormalReminders\", testId, this.loginToken); this.socket.once(\"sendNormalRemindersResponse\", res =&gt; { callback(res); }); } changePatientColour(patientId, newColor, callback){ this.socket.emit(\"changePatientColour\", patientId, newColor, this.loginToken); this.socket.once(\"changePatientColourResponse\", res =&gt; { callback(res); }); } changeTestColour(testId, newColor, callback){ this.socket.emit(\"changeTestColour\", testId, newColor, this.loginToken); this.socket.once(\"changeTestColourResponse\", res =&gt; { callback(res); }); } recoverPassword(username, callback){ this.socket.emit(\"passwordRecoverRequest\", username); this.socket.once(\"passwordRecoverResponse\", res =&gt; { callback(res); }); } generateMonthlyReport(month, callback) { this.socket.emit(\"generateMonthlyReport\", month, this.loginToken); this.socket.once(\"generateMonthlyReportResponse\", res =&gt; { callback(res); }); } } let serverConnect = new ServerConnect(); /** * Function to get the unique instance of the server connection * @returns {ServerConnect} */ function getServerConnect(){ if (typeof serverConnect === undefined){ serverConnect = new ServerConnect(); } return serverConnect; } export {getServerConnect}; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_test_unit_lib_calendar-functions-test.js.html":{"id":"server_test_unit_lib_calendar-functions-test.js.html","title":"Source: server/test/unit/lib/calendar-functions-test.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/test/unit/lib/calendar-functions-test.js /** * This file contains tests that test the behaviour of token-generator.js * * @author Luka Kralj * @version 1.0 * * @module token-functions-test * @see module:token-generator */ const expect = require(\"chai\").expect; const calendarController = require('../../../lib/calendar-functions'); const dateformat = require('dateformat'); describe(\"Test calendar controller:\", () =&gt; { describe(\"Test with invalid arguments:\", () =&gt; { describe(\"&gt; 'undefined' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(undefined, new Date())).to.be.null; }); }); describe(\"&gt; 'null' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(null, new Date())).to.be.null; }); }); describe(\"&gt; 'null' (as string) (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"null\", new Date())).to.be.null; }); }); describe(\"&gt; 'randText' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"randText\", new Date())).to.be.null; }); }); describe(\"&gt; 'rand-Text' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"rand-Text\", new Date())).to.be.null; }); }); describe(\"&gt; '' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"\", new Date())).to.be.null; }); }); describe(\"&gt; '4-D-3' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-D-3\", new Date())).to.be.null; }); }); describe(\"&gt; '-D' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"-D\", new Date())).to.be.null; }); }); describe(\"&gt; '4-' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-\", new Date())).to.be.null; }); }); describe(\"&gt; '4--Y' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4--Y\", new Date())).to.be.null; }); }); describe(\"&gt; '4-5' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-5\", new Date())).to.be.null; }); }); describe(\"&gt; '4-M' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-M\", new Date())).to.be.null; }); }); describe(\"&gt; '4-five' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"randText\", new Date())).to.be.null; }); }); describe(\"&gt; '4-d' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"randText\", new Date())).to.be.null; }); }); describe(\"&gt; '4-y' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"randText\", new Date())).to.be.null; }); }); describe(\"&gt; '4-w' (&amp; valid date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"randText\", new Date())).to.be.null; }); }); describe(\"&gt; '4-D' (valid) &amp; empty date):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-D\", \"\")).to.be.null; }); }); describe(\"&gt; '4-D' (valid) &amp; 'undefined'):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-D\", undefined)).to.be.null; }); }); describe(\"&gt; '4-D' (valid) &amp; 'null'):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-D\", null)).to.be.null; }); }); describe(\"&gt; '4-D' (valid) &amp; 'null' (as string)):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-D\", \"null\")).to.be.null; }); }); describe(\"&gt; '4-D' (valid) &amp; '20190822'):\", () =&gt; { it(\"Should return null.\", () =&gt; { expect(calendarController.getNextDueDate(\"4-D\", \"20190822\")).to.be.null; }); }); }); describe(\"Test with valid arguments:\", () =&gt; { describe(\"&gt; '1-Y' &amp; 12 Mar 2019:\", () =&gt; { it(\"Should return 14 Mar 2020.\", () =&gt; { const param = new Date(\"2019-03-12\"); let actual = calendarController.getNextDueDate(\"1-Y\", param); actual = dateformat(actual, \"yyyymmdd\") const expected = \"20200314\"; expect(actual).to.equal(expected); }); }); describe(\"&gt; '1-Y' &amp; 14 Mar 2019 (check Saturday):\", () =&gt; { it(\"Should return 14 Mar 2020.\", () =&gt; { const param = new Date(\"2019-03-14\"); let actual = calendarController.getNextDueDate(\"1-Y\", param); actual = dateformat(actual, \"yyyymmdd\") const expected = \"20200314\"; expect(actual).to.equal(expected); }); }); describe(\"&gt; '5-D' &amp; 12 Mar 2019 (check Sunday):\", () =&gt; { it(\"Should return 19 Mar 2019.\", () =&gt; { const param = new Date(\"2019-03-12\"); let actual = calendarController.getNextDueDate(\"5-D\", param); actual = dateformat(actual, \"yyyymmdd\") const expected = \"20190317\"; expect(actual).to.equal(expected); }); }); describe(\"&gt; '4-W' &amp; 1 Feb 2019:\", () =&gt; { it(\"Should return 1 Mar 2019.\", () =&gt; { const param = new Date(\"2019-02-01\"); let actual = calendarController.getNextDueDate(\"4-W\", param); actual = dateformat(actual, \"yyyymmdd\") const expected = \"20190302\"; expect(actual).to.equal(expected); }); }); describe(\"&gt; '7-D' &amp; 12 Apr 2019 (holiday + weekend + holiday):\", () =&gt; { it(\"Should return 23 Apr 2019.\", () =&gt; { const param = new Date(\"2019-04-12\"); let actual = calendarController.getNextDueDate(\"7-D\", param); actual = dateformat(actual, \"yyyymmdd\") const expected = \"20190420\"; expect(actual).to.equal(expected); }); }); }); }); Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_db_controller_token-generator.js.html":{"id":"server_lib_db_controller_token-generator.js.html","title":"Source: server/lib/db_controller/token-generator.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/db_controller/token-generator.js /** * Unique token generator. * * @author Luka Kralj * @version 1.0 * * @module token-generator */ const dateFormat = require(\"dateformat\"); let map = {}; /** * Generates a random integer. * * @param {number} min Lower bound. * @param {number} max Upper bound. * @returns {number} Random integer. */ function randInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive } /** * Inserts letters into the token so that it is even harder to guess. * * @param {string} token Token obtained from the timestamp. * @returns {string} Token with added letters. */ function addLetters(token) { let toReturn = \"\"; toReturn += randSeq(); for (let i = 0; i &lt; token.length; i++) { toReturn += randSeq(); toReturn += token.charAt(i); } toReturn += randSeq(); return toReturn; } /** * Generates a random sequence of letters, possibly empty. * * @param {number} max Maximum length of the string that we want. * @returns {string} Random sequence, possibly empty. */ function randSeq(max = 3) { let toReturn = \"\"; const toAdd = randInt(0, max + 1); for (let j = 0; j &lt; toAdd; j++) { toReturn += randLetter(); } return toReturn; } /** * Returns a random letter from A-Z or a-z. * * @returns A random letter. */ function randLetter() { const all = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"; return all.charAt(randInt(0, all.length)); } /** * Generates a unique sequence of numbers and letters that can be used for identification. * * @returns {string} A unique sequence of numbers and letters (usually around 40 characters long). */ function generateToken() { const formatted = dateFormat(new Date(), \"yyyymmddHHMMssl\"); let toReturn = \"\"; if (formatted in map) { // Another token requested in the same millisecond. let found = false; do { const rand = randInt(10000, 10000000); // Verify that the random number hasn't already been used for this timestamp. if (map[formatted].find((element) =&gt; { return element === rand; }) === undefined) { found = true; map[formatted].push(rand); toReturn = addLetters(formatted + rand); } } while (!found); } else { // First instance of token with such timestamp. // Since the timestamp always changes - if value is not found it means it's because it's not in the same millisecond. // Hence, the previous values in the map will never be repeated again so the map can be deleted. map = {}; const rand = randInt(10000, 10000000); map[formatted] = [rand]; toReturn = addLetters(formatted + rand); } return toReturn; } /** * Generates a unique sequence of numbers and letters that can be used for identification. * This generates a longer token than generateToken() which makes it more secure. * * @returns A unique token. */ function generateLoginToken() { return randSeq(4) + generateToken() + randSeq(6); } module.exports = { generateToken, generateLoginToken }; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_test_unit_lib_db_controller_token-generator-test.js.html":{"id":"server_test_unit_lib_db_controller_token-generator-test.js.html","title":"Source: server/test/unit/lib/db_controller/token-generator-test.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/test/unit/lib/db_controller/token-generator-test.js /** * This file contains tests that test the behaviour of token-generator.js * * @author Luka Kralj * @version 1.0 * * @module token-generator-test * @see module:token-generator */ require('./../../../../lib/logger').changeOption(\"consoleOutput\", false) const expect = require(\"chai\").expect; const id_gen = require(\"../../../../lib/db_controller/token-generator\"); /** * Generates and compares 10000 tokens. * * @returns {boolean} true if all tokens are unique, false if not. */ function testUniqueness() { console.log(\" Testing uniqueness of 10000 tokens:\") const all = []; for (let i = 1; i &lt; 10001; i++) { all.push(id_gen.generateToken()); if (i % 100 === 0) { process.stdout.clearLine(); process.stdout.cursorTo(0); process.stdout.write(\" \" + (i / 100) + \" %\"); } } console.log(\"\\n all generated\"); console.log(\" sorting...\"); const sorted = all.sort(); console.log(\" sorted\"); console.log(\" comparing...\"); let allUnique = true; for (let i = 0; i &lt; sorted.length - 1; i++) { if (i % (sorted.length/100) === 0) { process.stdout.clearLine(); process.stdout.cursorTo(0); process.stdout.write(\" \" + (i / sorted.length * 100) + \" %\"); } process.stdout.clearLine(); process.stdout.cursorTo(0); process.stdout.write(\" 100 %\"); if (sorted[i] === sorted[i+1]) { allUnique = false; break; } } if (allUnique) { console.log(\"\\n All tokens are unique.\"); return true; } else { console.log(\"\\n Duplicates were found!!\"); return false; } } describe(\"Test token generator:\", () =&gt; { describe(\"&gt; Test uniqueness of tokens\", () =&gt; { it(\"Should return true - all tokens are unique.\", (done) =&gt; { expect(testUniqueness()).to.be.true; done(); }).timeout(5000); }); }); require('./../../../../lib/logger').deleteLogFile(); Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"server_lib_query-modules_token-controller.js.html":{"id":"server_lib_query-modules_token-controller.js.html","title":"Source: server/lib/query-modules/token-controller.js","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Source: server/lib/query-modules/token-controller.js const actionLogger = require(\"../action-logger\"); const databaseController = require(\"../db_controller/db-controller.js\"); /** * Request editing of an entry in table * @param {String} table - Table to edit * @param {String} id - id to edit * @param {string} actionUsername The user who issued the request. * @return {String} token **/ async function requestEditing(table, id, actionUsername) { const data = await databaseController.requestEditing(table, id).then(data =&gt; { return data; }); // TODO: return token + expiration if (data.status == \"OK\") { actionLogger.logOther(actionUsername,table,id,\"Request for editing was approved.\"); return data.response.token; } else { actionLogger.logOther(actionUsername,table,id,\"Request for editing was rejected with message: &gt;&gt;\" +data.err.cause +\"&lt;&lt;.\"); return undefined; } } /** * Cancel editing on an entry * @param {String} table - Table of an entry * @param {String} id - id value of an entry * @param {String} token - token to return * @param {string} actionUsername The user who issued the request. * @return {JSON} result - {success:Boolean response:\"Token cancelled\"/Error} **/ async function returnToken(table, id, token, actionUsername) { const response = await databaseController.cancelEditing(table, id, token); if (response.status === \"OK\") { actionLogger.logOther(actionUsername, table, id, \"Successfully released token.\"); return { success: true, response: \"Token cancelled\" }; } else if (response.err.type === \"SQL Error\") { actionLogger.logOther(actionUsername,table,id,\"Unsuccessfully tried to release token. SQL Error message: &gt;&gt;\" +response.err.sqlMessage +\"&lt;&lt;.\"); } else { actionLogger.logOther(actionUsername,table,id,\"Unsuccessfully tried to release token. Invalid request error message: &gt;&gt;\" +response.err.cause +\"&lt;&lt;.\"); } return { success: false, response: response.err }; } module.exports = { requestEditing, returnToken, }; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Global Members &lt;constant&gt; intRegex Purpose of functions below is to verify if given input matches some criteria.For instance if email has valid type such as \"anystring@anystring.anystring\". Author: Jakub Cerven Source: client/src/lib/inputChecker.js, line 8 Methods &lt;async&gt; addCarer(json, actionUsername) Add new carer to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description carer_email Source: server/lib/query-modules/inserter.js, line 91 Returns: result of the query - {success:Boolean} Type JSON &lt;async&gt; addHospital(json, actionUsername) Add new Hospital to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description hospital_email Source: server/lib/query-modules/inserter.js, line 78 Returns: result of the query - {success:Boolean} Type JSON &lt;async&gt; addPatient(json, actionUsername) Add new patient to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description patient_no patient_name patient_surname hospital_id carer_id Source: server/lib/query-modules/inserter.js, line 60 Returns: result of the query - {success:Boolean} Type JSON &lt;async&gt; addTest(json, actionUsername) Add new test to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description patient_no due_date Source: server/lib/query-modules/inserter.js, line 43 Returns: result of the query - {success:Boolean} Type JSON &lt;async&gt; addUser(json, actionUsername) Add new user to the database Parameters: Name Type Description json JSON user actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description username String hashed_password String email String isAdmin string \"yes\" | \"no\" Source: server/lib/query-modules/inserter.js, line 17 Returns: result of the query - {success:Boolean} Type JSON arraysOfDatesEqual(_arr1, _arr2) Check if two arrays containing dates havethe same values Parameters: Name Type Description _arr1 array1 _arr2 array2 Source: client/test/unit/lib/calendar_controller_test.js, line 289 callCommand(command, logger) Call a logger command Parameters: Name Type Description command string the command to call logger JSON the logger module object Source: server/test/unit/lib/logger_test.js, line 118 &lt;async&gt; changePatientColour(patientNo, newColour) Edit patient colour - quick update. Parameters: Name Type Description patientNo String Number of the patient to update newColour string New colour to be stored. Source: server/lib/query-modules/updater.js, line 150 Returns: &lt;async&gt; changeTestStatus(test, actionUsername) Change the status of the test in the database Parameters: Name Type Description test JSON actionUsername string The user who issued the request. Properties: Name Type Description testId String id of a test to change Source: server/lib/query-modules/updater.js, line 97 Returns: result of the query - {success:true/false response:Array/Error} Type JSON characterCheck(input) Checks if input contains only characters Parameters: Name Type Description input String of some value Source: client/src/lib/inputChecker.js, line 38 Returns: Match with regular expression Type boolean checkMultipleQueriesStatus(queries) Run multiple queries on the database Parameters: Name Type Description queries Array array of queries to run Source: server/lib/query-modules/selector.js, line 277 Returns: result of the query - {success:true/false response:Array/String} Type JSON &lt;async&gt; deleteCarer(carerid, actionUsername) Delete Carer entry from database Parameters: Name Type Description carerid String id of a carer to be deleted actionUsername string The user who issued the request. Source: server/lib/query-modules/deleter.js, line 12 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async&gt; deleteHospital(hospitalid, actionUsername) Delete hospital entry from database Parameters: Name Type Description hospitalid String id of a hospital to be deleted actionUsername string The user who issued the request. Source: server/lib/query-modules/deleter.js, line 23 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async&gt; deletePatient(patientid, actionUsername) Delete Patient from database Parameters: Name Type Description patientid String patient_no of a patient actionUsername string The user who issued the request. Source: server/lib/query-modules/deleter.js, line 34 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async&gt; deleteQueryDatabase(table, id, sql, actionUsername) Run DELETE query on the database Parameters: Name Type Description table String Table to edit id String id to edit sql String SQL query actionUsername string The user who issued the request. Source: server/lib/query-modules/deleter.js, line 58 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async&gt; deleteTest(testid, actionUsername) Delete test entry from database Parameters: Name Type Description testid String id of a test to be deleted actionUsername string The user who issued the request. Source: server/lib/query-modules/deleter.js, line 45 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async&gt; editCarer(newInfo, token, actionUsername) Edit carer query Parameters: Name Type Description newInfo JSON All the information of the carer to update token The token that grants edit privileges actionUsername string The user who issued the request. Properties: Name Type Description carer_id String Source: server/lib/query-modules/updater.js, line 51 &lt;async&gt; editHospital(newInfo, token, actionUsername) Edit hospital query Parameters: Name Type Description newInfo JSON All the information of the hospital to updateObligatory fields in JSON token The token that grants edit privileges actionUsername string The user who issued the request. Properties: Name Type Description hospital_id String Source: server/lib/query-modules/updater.js, line 39 &lt;async&gt; editPatient(newInfo, token, actionUsername) Edit patient query Parameters: Name Type Description newInfo JSON All the information of the patient to updateObligatory fields in JSON token The token that grants edit privileges actionUsername string The user who issued the request. Properties: Name Type Description patient_no String Source: server/lib/query-modules/updater.js, line 26 &lt;async&gt; editTest(testId, newInfo, token, actionUsername) Edit test query Parameters: Name Type Description testId The id of the test to be updated newInfo JSON All the information of the test (new and old) token The token that grants edit privileges actionUsername string The user who issued the request. Source: server/lib/query-modules/updater.js, line 13 &lt;async&gt; editUser(json, actionUsername) Update User in database Parameters: Name Type Description json JSON user actionUsername string The user who issued the request.Obligatory properties: Properties: Name Type Description username String ,One of optional propertiesOptional properties: recovery_email String hashed_password String Source: server/lib/query-modules/updater.js, line 74 Returns: {success:Boolean response:Array or Error} Type JSON emailCheck(input) Checks if input is an email address or emptyThis is not a complete check some invalid emails will still return true Parameters: Name Type Description input String of some value Source: client/src/lib/inputChecker.js, line 49 Returns: Match with regular expression Type boolean emptyCheck(input) Checks if input is empty or undefined Parameters: Name Type Description input Some string value Source: client/src/lib/inputChecker.js, line 20 Returns: Type boolean &lt;async&gt; getAllPatients(isAdult) Get all the patients from the database Parameters: Name Type Description isAdult Boolean If the records should be displayed for adult users Source: server/lib/query-modules/selector.js, line 60 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async&gt; getAllUsers() Get all users from database Source: server/lib/query-modules/selector.js, line 80 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async&gt; getCarer(carerID) Get the carer given its carer id Parameters: Name Type Description carerID string the carer id Source: server/lib/query-modules/selector.js, line 40 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async&gt; getCompletedLateInMonth(data) Get number of completed tests in month Parameters: Name Type Description data String date for data to be retrived Source: server/lib/query-modules/selector.js, line 318 Returns: result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} Type JSON &lt;async&gt; getCompletedOnTimeInMonth(data) Get number of completed tests on time in month Parameters: Name Type Description data String date for data to be retrived Source: server/lib/query-modules/selector.js, line 308 Returns: result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} Type JSON &lt;async&gt; getDueTestsInMonth(data) Get number of test due in month Parameters: Name Type Description data String date for data to be retrived Source: server/lib/query-modules/selector.js, line 298 Returns: result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} Type JSON &lt;async&gt; getFullPatientInfo(patient_no) Get the info of the patient together with the info of eventual carers and hospitals Parameters: Name Type Description patient_no string the patient number Source: server/lib/query-modules/selector.js, line 22 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async&gt; getHospital(hospital_id) Get the hospital given its hospital id Parameters: Name Type Description hospital_id string the hospital id Source: server/lib/query-modules/selector.js, line 50 Returns: {success:Boolean response:Array or Error} Type JSON getLastLineOfFile(fileName) Return the last line of a file.Adapted from https://bit.ly/2Hz2lPO. Parameters: Name Type Description fileName string the path of the file to read Source: server/test/unit/lib/logger_test.js, line 89 getMonthAndYear(date:) Return month and year from the received date as string.(Mon Mar 04 2019 ... = March 2019) Parameters: Name Type Description date: Date date Source: client/src/components/calendarComponents/CalendarHeader.js, line 60 Returns: Month and Year as string Type string getMonthName(date:) Return the full name of the month from the received date Parameters: Name Type Description date: Date date Source: client/src/components/calendarComponents/CalendarHeader.js, line 50 Returns: The name of date's month Type string &lt;async&gt; getNextTestsOfPatient(patientId) Get not completed tests from patient Parameters: Name Type Description patientId String id of patient Source: server/lib/query-modules/selector.js, line 100 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async&gt; getNumberOfRemindersSent(data) Get sum of all reminders send in month Parameters: Name Type Description data String date for data to be retrived Source: server/lib/query-modules/selector.js, line 328 Returns: result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} Type JSON &lt;async&gt; getOverdueReminderGroups(isAdult) Returns overdue tests that are separated into two groups. One group are the tests that haven't beensent a reminder. The other group are the tests that have already been sent a reminder.Response includes some basic info about the test. Parameters: Name Type Description isAdult Boolean If the records should be displayed for adult users Source: server/lib/query-modules/selector.js, line 192 Returns: { success: true|false, response: { notReminded: [{ test_id: due_date: patient_no: patient_name: patient_surname: }, ...] reminded: [{ test_id: due_date: patient_no: patient_name: patient_surname: last_reminder: reminders_sent: }, ...] } } Type JSON &lt;async&gt; getPatient(patient_no) Get the patient given its patient number Parameters: Name Type Description patient_no string the patient number Source: server/lib/query-modules/selector.js, line 12 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async&gt; getPatientsNumber(isAdult) Get number of patients in database Parameters: Name Type Default Description isAdult Boolean true if the number of patients to be retrived should be for adult patients Source: server/lib/query-modules/selector.js, line 338 Returns: result of query {success:Boolean response: if true -&gt; {[{Number}]}} else {Error} Type JSON &lt;async&gt; getTest(test_id) Get test from the database Parameters: Name Type Description test_id String id of test Source: server/lib/query-modules/selector.js, line 90 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async&gt; getTestInfo(test_id) Get test info with patient info from the database Parameters: Name Type Description test_id String id of test Source: server/lib/query-modules/selector.js, line 112 Returns: result of the query - {success:true/false response:Array/Error} Type JSON getTestsDuringTheWeek(date, isAdult) Produce multiple queries on the database to retrieve test within the week Parameters: Name Type Description date String date in the week to retrieve tests (format: \"YYYY-MM-DD\") isAdult Boolean If the records should be displayed for adult users Source: server/lib/query-modules/selector.js, line 247 Returns: array of queries to run Type Array &lt;async&gt; getTestWithinWeek(date, isAdult) Get all tests within the week from the database Parameters: Name Type Description date String any date (from Monday to Friday) within the week to retrieve (format: \"YYYY-MM-DD\") isAdult Boolean If the records should be displayed for adult users Source: server/lib/query-modules/selector.js, line 152 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async&gt; getUser(username) Get user from database Parameters: Name Type Description username String username to retrieve Source: server/lib/query-modules/selector.js, line 71 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async&gt; insertQueryDatabase(sql, tableName, id, actionUsername) Run INSERT query on the database Parameters: Name Type Description sql String SQL query tableName string Name of the table which we are inserting into. id string Specify new entry's ID, unless the ID is auto generated. actionUsername string The user who issued the request. Source: server/lib/query-modules/inserter.js, line 104 Returns: result of the query - {success:Boolean} Type JSON integerCheck(input) Checks if input contains only non-negative numbers Parameters: Name Type Description input String of some value Source: client/src/lib/inputChecker.js, line 29 Returns: Match with regular expression Type boolean prepareDeleteSQL(table, idProperty, id) Prepare DELETE query on the database Parameters: Name Type Description table String Table in which to insert an entry idProperty String property, that the entry can be identified with id String value of idProperty Source: server/lib/query-modules/deleter.js, line 94 Returns: SQL query Type String prepareInsertSQL(table, object) Prepare INSERT query on the database Parameters: Name Type Description table String Table in which to insert an entry object JSON JSON, which is being entered Source: server/lib/query-modules/inserter.js, line 124 Returns: SQL query Type String prepareUpdateSQL(table, object, idProperty) Prepare UPDATE query on the database Parameters: Name Type Description table String Table in which to insert an entry object JSON JSON, which is being entered idProperty String property, that the entry can be identified with Source: server/lib/query-modules/updater.js, line 163 Returns: SQL query Type String &lt;async&gt; requestEditing(table, id, actionUsername) Request editing of an entry in table Parameters: Name Type Description table String Table to edit id String id to edit actionUsername string The user who issued the request. Source: server/lib/query-modules/token-controller.js, line 11 Returns: token Type String &lt;async&gt; returnToken(table, id, token, actionUsername) Cancel editing on an entry Parameters: Name Type Description table String Table of an entry id String id value of an entry token String token to return actionUsername string The user who issued the request. Source: server/lib/query-modules/token-controller.js, line 33 Returns: result - {success:Boolean response:\"Token cancelled\"/Error} Type JSON &lt;async&gt; selectQueryDatabase(sql) Run SELECT query on the database Parameters: Name Type Description sql String SQL query Source: server/lib/query-modules/selector.js, line 227 Returns: result of the query - {success:Boolean response:Array/Error} Type JSON sleep(ms) Await for this function to pause execution for a certain time. Parameters: Name Type Description ms number Time in milliseconds Source: server/test/unit/lib/logger_test.js, line 145 Returns: Type Promise &lt;async&gt; updateLastReminder(testId, token, actionUsername) Update when the last reminder for this test was sent. Parameters: Name Type Description testId string id of a test to change token string The token that grants edit privileges. actionUsername string The user who issued the request. Source: server/lib/query-modules/updater.js, line 131 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async&gt; updateQueryDatabase(table, id, sql, token, actionUsername) Run UPDATE query on the database Parameters: Name Type Description table String Table to edit id String id to edit sql String SQL query token string token to access entry actionUsername string The user who issued the request. Source: server/lib/query-modules/updater.js, line 202 Returns: result of the query - {success:Boolean response:Array/Error} Type JSON Type Definitions getSortedOverdueWeeks Get all the overdue tests from the database plus additional info about time difference Type: SortedWeek Properties: Name Type Description class String monday of the week, format: 'Mon Mar 04 2019 00:00:00 GMT+0000 (GMT)' Source: server/lib/query-modules/selector.js, line 126 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Modules Classes Database Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Classes Classes Database Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase BLOOD TEST DIARYRequirementsFor development, you will only need Node.js and npm installed on your environment. Node and npmNode is really easy to install &amp; now include npm.You should be able to run the following command after the installation procedurebelow. $ node --version v11.6.0 $ npm --version 6.7.0Node installation on OS XYou will need to use a Terminal. On OS X, you can find the default terminal in/Applications/Utilities/Terminal.app. Please install Homebrew if it's not already done with the following command. $ ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\"If everything when fine, you should run $ brew install nodeNode installation on Linux$ sudo apt-get install python-software-properties $ sudo add-apt-repository ppa:chris-lea/node.js $ sudo apt-get update $ sudo apt-get install nodejsNode installation on WindowsJust go on official Node.js website &amp; grab the installer.Also, be sure to have git available in your PATH, npm might need it. How to use code quality and testing toolsESLint:Currently only used for node backend support To check path/to/app.js: $ npm run -s eslint path/to/app.jsIt is advised to install editor extensions which will allow to check for errors automatically.VSCode: vscode-eslintAtom: linter-eslint Mocha, Chai, and InstanbulTo recursively run tests in server/: $ cd server $ npm testTo recursively run tests in client/ $ cd client $ npm test -- --recursive Configure appServer connectionThe configuration file is client/config/app_config.json port : the port on which the local app runsstaticFolder : the static folder containing the frontend appindexFile: the index.html file which is served when the app receives get requests { \"port\" : 4200, \"staticFolder\" : \"/public\", \"indexFile\" : \"index.html\" } Email senderThe configuration file is server/config/email_config.json { \"transporter\": { \"host\": \"smtp.mail.yahoo.com\", \"port\": 465, \"service\": \"yahoo\", \"secure\": false, \"auth\": { \"user\": \"danilodelbusso@yahoo.com\", \"pass\": \"jJ825&amp;j9yBRA\" }, \"logger\": true } }for info on usage and possible additional settings, go to nodemailer.com Languages &amp; tools NodeJS is used for the back-end. React is used for UI Electron is used for deploying the desktop app ESLint is used for linting support Mocha is used for testing Chai is used for assertions Instanbul is used for test branch coverage checks nodemailer is used for sending emails mysql for managing and creating a relational database mocha-sinon used for integration between mocha and sinon, allowing for automatic cleanup of spies proxyquire used to proxy nodejs's require in order to make overriding dependencies Authors Alessandro Amantini Alvaro Rausell Guiard Danilo Del Busso Emilio Pascarelli Jacopo Madaluni Jakub Cerven Luka Kralj Mateusz Nowak Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"Database.html":{"id":"Database.html","title":"Class: Database","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Class: Database Database new Database() Promisify mysql.Adapted from: https://codeburst.io/node-js-mysql-and-promises-4c3be599909b Source: server/lib/db_controller/Database.js, line 1 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-action-logger.html":{"id":"module-action-logger.html","title":"Module: action-logger","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: action-logger This module provides some functions for fasterlogging of different actions on the DB. Version: 1.0 Author: Luka Kralj Source: server/lib/action-logger.js, line 1 Members &lt;inner&gt; showConsoleOutput If true, it will output to the console, otherwise it will not output anything.It's good to turn it off in testing to increase readability. Leave on for debugging. Source: server/lib/action-logger.js, line 29 Methods &lt;inner&gt; log(type, username, tableName, entryID, message, Optional) Helper function to reduce duplication. Parameters: Name Type Description type string Type of action taken: insert, update or delete. username string User that has done that action. tableName string The table that was involved in the action. entryID string The key of the entry from the previous table that was involved in the action. message string Optional message that can provide more details about the action. Optional function action, called with the result of insertQuery. Source: server/lib/action-logger.js, line 105 &lt;inner&gt; logDelete(username, tableName, entryID, message, Optional) Call this to log a delete action. Parameters: Name Type Description username string User that has done that action. tableName string The table that was involved in the action. entryID string The key of the entry from the previous table that was involved in the action. message string Optional message that can provide more details about the action. Optional function action, called with the result of insertQuery. Source: server/lib/action-logger.js, line 74 &lt;inner&gt; logInsert(username, tableName, entryID, message, Optional) Call this to log an insert action. Parameters: Name Type Description username string User that has done that action. tableName string The table that was involved in the action. entryID string The key of the entry from the previous table that was involved in the action. message string Optional message that can provide more details about the action. Optional function action, called with the result of insertQuery. Source: server/lib/action-logger.js, line 48 &lt;inner&gt; logOther(username, tableName, entryID, message, Optional) Call this to log any other action. Say, requested editing, or attempted an invalid login etc. Parameters: Name Type Description username string User that has done that action. tableName string The table that was involved in the action. entryID string The key of the entry from the previous table that was involved in the action. message string Message that provides details about the action. In this case the message is compulsory as it needs to explain what happened. Optional function action, called with the result of insertQuery. Source: server/lib/action-logger.js, line 88 &lt;inner&gt; logUpdate(username, tableName, entryID, message, Optional) Call this to log an update action. Parameters: Name Type Description username string User that has done that action. tableName string The table that was involved in the action. entryID string The key of the entry from the previous table that was involved in the action. message string Optional message that can provide more details about the action. Optional function action, called with the result of insertQuery. Source: server/lib/action-logger.js, line 61 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-action-logger-test.html":{"id":"module-action-logger-test.html","title":"Module: action-logger-test","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: action-logger-test This file contains tests that test the behaviour of action-logger.js Version: 1.0 Author: Luka Kralj Source: server/test/integration/lib/action-logger-test.js, line 1 See: module:action-logger Methods &lt;inner&gt; printSetupError(err) Prints an error that occurred during setting up the testingenvironment in a nice format. Parameters: Name Type Description err Error Error that occurred. Source: server/test/integration/lib/action-logger-test.js, line 389 &lt;inner&gt; sleep(ms) Await for this function to pause execution for a certain time. Parameters: Name Type Description ms number Time in milliseconds Source: server/test/integration/lib/action-logger-test.js, line 401 Returns: Type Promise Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-authenicator.html":{"id":"module-authenicator.html","title":"Module: authenicator","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: authenicator This module contains functions for user authentication and verification. Version: 1.0 Author: Mateusz Nowak, Luka Kralj Source: server/lib/authenticator.js, line 1 Methods &lt;inner&gt; canLogin() Function tha naively checks if userprovided right credentials Source: server/lib/authenticator.js, line 32 &lt;async, inner&gt; initTokens() Retrieves all access tokens (if any) from the database and creates a lookup table forfaster access. Source: server/lib/authenticator.js, line 64 &lt;async, inner&gt; logoutUser(accessToken) Delete access token for this user. Parameters: Name Type Description accessToken string Token used for identification. Source: server/lib/authenticator.js, line 150 Returns: True if token successfully deleted, false if invalid token. Type boolean &lt;async, inner&gt; registerNewUsername(username) Register the given username with a login token that isused in authorisation of the requests. Parameters: Name Type Description username string A valid username. Source: server/lib/authenticator.js, line 125 Returns: A login token for this user. Type string &lt;async, inner&gt; verifyToken(accessToken) Verifies user using the accessToken. Parameters: Name Type Description accessToken string Token used for identification. Source: server/lib/authenticator.js, line 87 Returns: Username of the user or undefined if token is invalid. Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-authenticator-test.html":{"id":"module-authenticator-test.html","title":"Module: authenticator-test","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: authenticator-test This file contains tests that test the behaviour of authenticator.js Version: 1.0 Author: Luka Kralj Source: server/test/unit/authenticator-test.js, line 1 See: module:authenticator Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-calendar-controller.html":{"id":"module-calendar-controller.html","title":"Module: calendar-controller","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: calendar-controller Controller functions to get dates using a frequency format Version: 0.0.1 Author: Danilo Del Busso Source: client/src/lib/calendar-controller.js, line 1 Methods &lt;inner&gt; formatDatabaseDate(dateString) Parameters: Name Type Description dateString a date of the form \"20190323\" Source: client/src/lib/calendar-controller.js, line 21 &lt;inner&gt; getMondayOfWeek(date) Gets the date object of the monday of the relative week Parameters: Name Type Description date Date any day of any week Source: client/src/lib/calendar-controller.js, line 33 Returns: relative monday date Type Date &lt;inner&gt; getNextDate(frequency, startingDate) Get the next date Parameters: Name Type Description frequency string the frequency in the given format startingDate date the starting date from which to calculate the next date Source: client/src/lib/calendar-controller.js, line 131 Example Example usage of getNextDate with X-D notation. // returns Date object of value 2018-01-04T00:00:00.000Z getNextDate('3-D', new Date(2018, 0 , 1)); &lt;inner&gt; getNextDates(frequency, startingDate) Get all the next dates based on the frequency notation.It does NOT return the original date Parameters: Name Type Description frequency string the frequency expressed as frequency notation startingDate Date the starting date (not included in the result) Source: client/src/lib/calendar-controller.js, line 104 Returns: an array containing the next dates but not the given starting date Type array.&lt;Date&gt; &lt;inner&gt; getNextWeek(week) Gets the dates of the next week. Parameters: Name Type Description week Source: client/src/lib/calendar-controller.js, line 60 Returns: &lt;inner&gt; getPreviousWeek(week) Gets the dates of the previous week. Parameters: Name Type Description week Source: client/src/lib/calendar-controller.js, line 81 Returns: &lt;inner&gt; isHoliday(date) Check if a date is a holiday in the UK Parameters: Name Type Description date date the date to check Source: client/src/lib/calendar-controller.js, line 201 &lt;inner&gt; stringIsInteger(str) Check if given string is an integer Parameters: Name Type Description str string Source: client/src/lib/calendar-controller.js, line 210 Returns: true if string is an integer Type boolean &lt;inner&gt; validDate(date) Check if date is valid Parameters: Name Type Description date date the date Source: client/src/lib/calendar-controller.js, line 185 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-calendar-functions.html":{"id":"module-calendar-functions.html","title":"Module: calendar-functions","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: calendar-functions Provides a function that calculates a new due date. NB: this controller differs from the one on the client side! Version: 1.0 Author: Danilo Del Busso, Luka Kralj Source: server/lib/calendar-functions.js, line 1 Methods &lt;inner&gt; convertArrayIntoMatrix(array:, cols:) Given an array and x columns, convert that array into a matrix of x columns Parameters: Name Type Description array: Array.&lt;Object&gt; array of any types cols: integer number of columns in the matrix Source: client/src/lib/calendar-functions.js, line 71 Returns: &lt;inner&gt; generateCalendarArr(daysFromPrevMonth:, prevMonthLastDay:, daysInCurrentMonth:) Take a date as parameter and generate an array of days so that all the days from the current month are contained, plus last (prevMonthLastDay - daysFromPrevMonth) days from the previous month at the beginning of the array, and the first ones from the next at the bottom to make the array size % (#days in a week) = 0. Parameters: Name Type Description daysFromPrevMonth: integer number of days from the previous month to be put at the beginning of the array. prevMonthLastDay: integer last day of the previous month (eg. January last day = 31). daysInCurrentMonth: integer last day of the current month (eg. ) Source: client/src/lib/calendar-functions.js, line 42 &lt;inner&gt; getCalendar(date:) Take a date as parameter and generate an array of arrays of days so that all the days from the specified year and month are contained in the matrix. The index of each array can be considered as the day (0 -&gt; Sunday, 1 -&gt; Monday etc.) and no cell is ever empty, so in case a month starts from Friday and ends on Monday, the remaining cells are filled in with, respectively, the last days from the previous month and the first ones from the next. Parameters: Name Type Description date: Date date to be converted into a matrix Source: client/src/lib/calendar-functions.js, line 95 Returns: &lt;inner&gt; getDateOfFirstDayOf(year:, month:) Given a month and a year return the date of the first day(Sunday = 0, Monday = 1 etc.) Parameters: Name Type Description year: integer year month: integer month Source: client/src/lib/calendar-functions.js, line 28 Returns: The date of the first day Type integer &lt;inner&gt; getDaysInMonth(year:, month:) Given a month and a year, return the number of days. Parameters: Name Type Description year: integer year month: integer month Source: client/src/lib/calendar-functions.js, line 17 Returns: The number of days in that month for that year Type integer &lt;inner&gt; getNextDueDate(frequency, startingDate) Get the next date Parameters: Name Type Description frequency string the frequency in the given format startingDate date the starting date from which to calculate the next date Source: server/lib/calendar-functions.js, line 22 Example Example usage of getNextDate with X-D notation. // returns Date object of value 2018-01-04T00:00:00.000Z getNextDate('3-D', new Date(2018, 0 , 1)); &lt;inner&gt; isHoliday(date) Check if a date is a holiday in the UK Parameters: Name Type Description date date the date to check Source: server/lib/calendar-functions.js, line 69 &lt;inner&gt; isSelected(isFromThisMonth:, selectedDay:, currentDate:, day:) Return True if the day is selected Parameters: Name Type Description isFromThisMonth: boolean the day belongs to the current month. selectedDay: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar day: integer the number of the day contained in this DayCell Source: client/src/lib/calendar-functions.js, line 167 Returns: True if the day is selected, False otherwise Type boolean &lt;inner&gt; isWeekend(date) Check if the date falls on Saturday or Sunday. Parameters: Name Type Description date date The date to check. Source: server/lib/calendar-functions.js, line 79 Returns: True if date is on weekend, false otherwise. Type boolean &lt;inner&gt; selectedDayIsFromCurrentMonth(selectedDate:, currentDate:) Return True if the selected date is in the days of the calendar belonging to the current month Parameters: Name Type Description selectedDate: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar Source: client/src/lib/calendar-functions.js, line 117 Returns: True iff the day appears in the calendar table and belongs to the current month, otherwise False Type boolean &lt;inner&gt; selectedDayIsFromNextMonth(selectedDate:, currentDate:, day:) Return True if the selected date is in the days of the calendar belonging to the next month Parameters: Name Type Description selectedDate: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar day: integer the number of the day contained in this DayCell Source: client/src/lib/calendar-functions.js, line 149 Returns: True iff the day appears in the calendar table and belongs to the next month, otherwise False Type boolean &lt;inner&gt; selectedDayIsFromPreviousMonth(selectedDate:, currentDate:, day:) Return True if the selected date is in the days of the calendar belonging to the previous month Parameters: Name Type Description selectedDate: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar day: integer the number of the day contained in this DayCell Source: client/src/lib/calendar-functions.js, line 131 Returns: True iff the day appears in the calendar table and belongs to the previous month, otherwise False Type boolean &lt;inner&gt; stringIsInteger(str) Check if given string is an integer Parameters: Name Type Description str string Source: server/lib/calendar-functions.js, line 89 Returns: true if string is an integer Type boolean Module: calendar-functions Version: 0.0.2 Author: Alessandro Amantini Source: client/src/lib/calendar-functions.js, line 1 Methods &lt;inner&gt; convertArrayIntoMatrix(array:, cols:) Given an array and x columns, convert that array into a matrix of x columns Parameters: Name Type Description array: Array.&lt;Object&gt; array of any types cols: integer number of columns in the matrix Source: client/src/lib/calendar-functions.js, line 71 Returns: &lt;inner&gt; generateCalendarArr(daysFromPrevMonth:, prevMonthLastDay:, daysInCurrentMonth:) Take a date as parameter and generate an array of days so that all the days from the current month are contained, plus last (prevMonthLastDay - daysFromPrevMonth) days from the previous month at the beginning of the array, and the first ones from the next at the bottom to make the array size % (#days in a week) = 0. Parameters: Name Type Description daysFromPrevMonth: integer number of days from the previous month to be put at the beginning of the array. prevMonthLastDay: integer last day of the previous month (eg. January last day = 31). daysInCurrentMonth: integer last day of the current month (eg. ) Source: client/src/lib/calendar-functions.js, line 42 &lt;inner&gt; getCalendar(date:) Take a date as parameter and generate an array of arrays of days so that all the days from the specified year and month are contained in the matrix. The index of each array can be considered as the day (0 -&gt; Sunday, 1 -&gt; Monday etc.) and no cell is ever empty, so in case a month starts from Friday and ends on Monday, the remaining cells are filled in with, respectively, the last days from the previous month and the first ones from the next. Parameters: Name Type Description date: Date date to be converted into a matrix Source: client/src/lib/calendar-functions.js, line 95 Returns: &lt;inner&gt; getDateOfFirstDayOf(year:, month:) Given a month and a year return the date of the first day(Sunday = 0, Monday = 1 etc.) Parameters: Name Type Description year: integer year month: integer month Source: client/src/lib/calendar-functions.js, line 28 Returns: The date of the first day Type integer &lt;inner&gt; getDaysInMonth(year:, month:) Given a month and a year, return the number of days. Parameters: Name Type Description year: integer year month: integer month Source: client/src/lib/calendar-functions.js, line 17 Returns: The number of days in that month for that year Type integer &lt;inner&gt; getNextDueDate(frequency, startingDate) Get the next date Parameters: Name Type Description frequency string the frequency in the given format startingDate date the starting date from which to calculate the next date Source: server/lib/calendar-functions.js, line 22 Example Example usage of getNextDate with X-D notation. // returns Date object of value 2018-01-04T00:00:00.000Z getNextDate('3-D', new Date(2018, 0 , 1)); &lt;inner&gt; isHoliday(date) Check if a date is a holiday in the UK Parameters: Name Type Description date date the date to check Source: server/lib/calendar-functions.js, line 69 &lt;inner&gt; isSelected(isFromThisMonth:, selectedDay:, currentDate:, day:) Return True if the day is selected Parameters: Name Type Description isFromThisMonth: boolean the day belongs to the current month. selectedDay: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar day: integer the number of the day contained in this DayCell Source: client/src/lib/calendar-functions.js, line 167 Returns: True if the day is selected, False otherwise Type boolean &lt;inner&gt; isWeekend(date) Check if the date falls on Saturday or Sunday. Parameters: Name Type Description date date The date to check. Source: server/lib/calendar-functions.js, line 79 Returns: True if date is on weekend, false otherwise. Type boolean &lt;inner&gt; selectedDayIsFromCurrentMonth(selectedDate:, currentDate:) Return True if the selected date is in the days of the calendar belonging to the current month Parameters: Name Type Description selectedDate: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar Source: client/src/lib/calendar-functions.js, line 117 Returns: True iff the day appears in the calendar table and belongs to the current month, otherwise False Type boolean &lt;inner&gt; selectedDayIsFromNextMonth(selectedDate:, currentDate:, day:) Return True if the selected date is in the days of the calendar belonging to the next month Parameters: Name Type Description selectedDate: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar day: integer the number of the day contained in this DayCell Source: client/src/lib/calendar-functions.js, line 149 Returns: True iff the day appears in the calendar table and belongs to the next month, otherwise False Type boolean &lt;inner&gt; selectedDayIsFromPreviousMonth(selectedDate:, currentDate:, day:) Return True if the selected date is in the days of the calendar belonging to the previous month Parameters: Name Type Description selectedDate: string the selected day in the form yyyy-(m)m-(d)d currentDate: Date the date displayed on the header of the the calendar day: integer the number of the day contained in this DayCell Source: client/src/lib/calendar-functions.js, line 131 Returns: True iff the day appears in the calendar table and belongs to the previous month, otherwise False Type boolean &lt;inner&gt; stringIsInteger(str) Check if given string is an integer Parameters: Name Type Description str string Source: server/lib/calendar-functions.js, line 89 Returns: true if string is an integer Type boolean Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-db-controller.html":{"id":"module-db-controller.html","title":"Module: db-controller","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: db-controller This module enables secure execution of the basic queries. It preventsdeleting any entry that some user might be editing at the moment.It also prevents editing the entry if someone else is already editing it. It does so through token exchange system that gives editing rights to whoeverobtains it. The token only works for a particular entry in the database. Additionally, the functions for critical queries deleteQuery, updateQuery andrequestEditing will never be executed synchronously. This is implemented with anadapted Bakery algorithm. Version: 1.0 Author: Luka Kralj Source: server/lib/db_controller/db-controller.js, line 1 Methods &lt;async, inner&gt; cancelEditing(entryTable, entryID, token) Call this to delete the current token. This will allow other usersto edit this entry. If the token is invalid, an errormessage will be returned. Parameters: Name Type Description entryTable string Name of the table that we are editing. entryID string Key of the entry that we are editing token string Token that is used for verifying the edit permissions. Source: server/lib/db_controller/db-controller.js, line 346 Returns: JSON object that contains response data or error message. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; deleteAccessToken(accessToken) Deletes the access token specified. Parameters: Name Type Description accessToken string Access token we are editing. Source: server/lib/db_controller/db-controller.js, line 399 Returns: JSON object that contains response data or error message. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; deleteQuery(sql, entryTable, entryID) Call this for DELETE queries. Parameters: Name Type Description sql string The SQL query. entryTable string Name of the table involved in the query. entryID string Key of the entry that is being deleted. Source: server/lib/db_controller/db-controller.js, line 86 Returns: JSON object that contains response data or error message, if the query was unsuccessful. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; editTokensEntryExists(database, entryTable, entryID, token) Check if the entry with the given parameters exists in the EditTokens table. Parameters: Name Type Description database Database entryTable string entryID string token string Source: server/lib/db_controller/db-controller.js, line 527 Returns: True if such entry exists, false if not. Type Promise.&lt;boolean&gt; &lt;inner&gt; getErrResponse(cause) Generate a JSON error response. Parameters: Name Type Description cause string Source: server/lib/db_controller/db-controller.js, line 464 Returns: Error response. Type JSON &lt;async, inner&gt; getResult(sql, database, treatResponse) Helper function that executes the query. Parameters: Name Type Description sql string Query to execute. database Database Database object to execute the query on. treatResponse function Decide how the response of a successful query is modified. Source: server/lib/db_controller/db-controller.js, line 445 Returns: Result of the query or error response, if query unsuccessful. Type JSON &lt;inner&gt; getSQLErrorResponse(err) Formats the error response to give some information about the query error(type, code, error number, SQL message). Parameters: Name Type Description err Error Error thrown by the database query function. Source: server/lib/db_controller/db-controller.js, line 481 Returns: Formatted error response. Type JSON &lt;inner&gt; getSuccessfulResponse(response) Formats a successful response. Enables all responses to follow the same format. Parameters: Name Type Description response JSON Preformatted query-specific response. Source: server/lib/db_controller/db-controller.js, line 499 Returns: A formatted response. Type JSON &lt;async, inner&gt; insertQuery(sql) Call this for INSERT queries. Parameters: Name Type Description sql string The SQL query. Source: server/lib/db_controller/db-controller.js, line 68 Returns: JSON object that contains response data or error message, if the query was unsuccessful. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; isValidEntry(database, entryTable, entryID) Checks if the table name and table ID pair actually represent somevalid database entry. Parameters: Name Type Description database Database entryTable string entryID string Source: server/lib/db_controller/db-controller.js, line 591 Returns: True if entry exists, false if not. Type Promise.&lt;boolean&gt; &lt;async, inner&gt; nonCriticalQuery(sql, type, treatResponse) A helper function for insertQuery and selectQuery. Parameters: Name Type Description sql string The SQL query. type string \"select\" or \"insert\" treatResponse function This function is called to format the query response, if the query was successful. Source: server/lib/db_controller/db-controller.js, line 426 Returns: JSON object that contains response data or error message, if the query was unsuccessful. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; refreshToken(entryTable, entryID, token) Call this to refresh the current token. This will generate a new tokenwith a new expiration time. If the token is invalid, an errormessage will be returned. Parameters: Name Type Description entryTable string Name of the table that we are editing. entryID string Key of the entry that we are editing token string Token that is used for verifying the edit permissions. Source: server/lib/db_controller/db-controller.js, line 296 Returns: JSON object that contains response data or error message. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; requestEditing(entryTable, entryID) Request editing for the specific entry. Parameters: Name Type Description entryTable string Table that we want to edit. entryID string ID of the entry in that table that we want to edit. Source: server/lib/db_controller/db-controller.js, line 220 Returns: Response containing the valid token, or error message. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; selectQuery(sql) Call this for SELECT queries. Parameters: Name Type Description sql string The SQL query. Source: server/lib/db_controller/db-controller.js, line 49 Returns: JSON object that contains response data or error message, if the query was unsuccessful. Type Promise.&lt;JSON&gt; &lt;inner&gt; sleep(ms) Await for this function to pause execution for a certain time. Parameters: Name Type Description ms number Time in milliseconds Source: server/lib/db_controller/db-controller.js, line 624 Returns: Type Promise &lt;inner&gt; startsWith(toCheck, compareTo) Shorthand function for comparing the start of a string. Leading spacesand capitalisation are ignored. Parameters: Name Type Description toCheck string A string the start of which we want to check. compareTo string A string that should appear at the start of the toCheck. Source: server/lib/db_controller/db-controller.js, line 514 Returns: True if toCheck starts with compareTo, false otherwise. Type boolean &lt;async, inner&gt; updateAccessToken(accessToken, newExpiration) Updates the expiration of an access token specified. Parameters: Name Type Description accessToken string Access token we are editing. newExpiration Date New expiration for this token. Source: server/lib/db_controller/db-controller.js, line 379 Returns: JSON object that contains response data or error message. Type Promise.&lt;JSON&gt; &lt;async, inner&gt; updateQuery(sql, entryTable, entryID, token) Call this for UPDATE queries. Parameters: Name Type Description sql string The SQL query. entryTable string Name of the table involved in the query. entryID string Key of the entry that is being updated. token string Token that is used for verifying the edit permissions. Source: server/lib/db_controller/db-controller.js, line 145 Returns: JSON object that contains response data or error message, if the query was unsuccessful. Type Promise.&lt;JSON&gt; Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-db_controller_test.html":{"id":"module-db_controller_test.html","title":"Module: db_controller_test","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: db_controller_test This file contains tests that test the behaviour ofmain DB controller. Version: 1.0 Author: Luka Kralj Source: server/test/integration/lib/db_controller/db-controller-test.js, line 1 See: module:db_controller Methods &lt;inner&gt; printSetupError(err) Prints an error that occurred during setting up the testingenvironment in a nice format. Parameters: Name Type Description err Error Error that occurred. Source: server/test/integration/lib/db_controller/db-controller-test.js, line 1575 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-email-controller.html":{"id":"module-email-controller.html","title":"Module: email-controller","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: email-controller This module processes mailing requests and organises the data thatis then used in email sender. It also updates the DB accordingly. Version: 1.0 Author: Luka Kralj Source: server/lib/email/email-controller.js, line 1 Methods &lt;async, inner&gt; recoverPassword(username) Recover password of user Parameters: Name Type Description username String user to recover password Source: server/lib/email/email-controller.js, line 203 &lt;async, inner&gt; send(testIDs, actionUsername) Send reminders for overdue tests. Parameters: Name Type Description testIDs Array List of all the overdue tests' IDs actionUsername string The user who issued the request. Source: server/lib/email/email-controller.js, line 91 Returns: result of the query. success is true only if all the emails were successfully sent. Some emails might fail to be sent for various reasons. It can be that the patient was sent an email but the hospital was not or vice versa, or maybe both emails failed to send. Response format: {success: true, response: \"All emails sent successfully.\"} The three \"failed\" lists are disjoint. {success: false, response: { failedBoth: [] // might be empty failedPatient: [] // might be empty failedHospital: [] // might be empty } } Type JSON &lt;async, inner&gt; sendNormalReminders(testIDs, actionUsername) Send reminders for tests (not overdue). Parameters: Name Type Description testIDs Array List of all the overdue tests' IDs actionUsername string The user who issued the request. Source: server/lib/email/email-controller.js, line 67 Returns: result of the query. success is true only if all the emails were successfully sent. Some emails might fail to be sent for various reasons. It can be that the patient was sent an email but the hospital was not or vice versa, or maybe both emails failed to send. Response format: {success: true, response: \"All emails sent successfully.\"} The three \"failed\" lists are disjoint. {success: false, response: { failedBoth: [] // might be empty failedPatient: [] // might be empty failedHospital: [] // might be empty } } Type JSON &lt;async, inner&gt; sendOverdueReminders(testIDs, actionUsername) Send reminders for overdue tests. Parameters: Name Type Description testIDs Array List of all the overdue tests' IDs actionUsername string The user who issued the request. Source: server/lib/email/email-controller.js, line 43 Returns: result of the query. success is true only if all the emails were successfully sent. Some emails might fail to be sent for various reasons. It can be that the patient was sent an email but the hospital was not or vice versa, or maybe both emails failed to send. Response format: {success: true, response: \"All emails sent successfully.\"} The three \"failed\" lists are disjoint. {success: false, response: { failedBoth: [] // might be empty failedPatient: [] // might be empty failedHospital: [] // might be empty } } Type JSON Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-email-generator.html":{"id":"module-email-generator.html","title":"Module: email-generator","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: email-generator The functions exported from this module generate different types of emails depending on their purpose.They all need information contained in the \"email_info\" JSON objects. Version: 0.0.2 Author: Danilo Del Busso, Luka Kralj Source: server/lib/email/email-generator.js, line 1 Example The email_info JSON needs to reflect this format in order to be properly parsed: { \"patient\": { \"patient_no\": \"P799886\", \"patient_name\": \"Bruce\", \"patient_surname\": \"Wayne\", \"patient_email\": \"imnotbatman@gotham.com\", \"patient_phone\": null, \"hospital_id\": 551, \"carer_id\": null, \"additional_info\": null }, \"test\": { \"test_id\": 1, \"patient_no\": \"P799886\", \"due_date\": date_obj, //a date object \"frequency\": \"4-W\", \"occurrences\": 9, \"completed_status\": \"yes\", \"completed_date\": date_obj, //a date object \"notes\": null }, \"hospital\": { \"hospital_id\": 551, \"hospital_name\": \"Gotham City Hospital\", \"hospital_email\": \"hospital@gotham.com\", \"hospital_phone\": null } \"user\":{ \"username\": \"admin\" \"new_password\": \"newpassword123\" \"recovery_email\": \"admin@admin.com\" } } Methods &lt;inner&gt; beautifyDate(date) Beautify a date object as a readable string of \"1st October 2020\" format Parameters: Name Type Description date date the date object to be beautified Source: server/lib/email/email-generator.js, line 500 Returns: the beautified date Type string &lt;async, inner&gt; generateRecoveryEmailBody(contentConfiguration) Generates the body of the email according to the content configuration. Parameters: Name Type Description contentConfiguration JSON format: { \"subject\": \"\", \"mainBody\": \"\", }, Source: server/lib/email/email-generator.js, line 418 &lt;async, inner&gt; generateReminderBody(contentConfiguration) Generates the body of the email according to the content configuration. Parameters: Name Type Description contentConfiguration JSON format: { \"subject\": { \"title\": \"\", \"appendDate\": true|false }, \"mainBody\": \"\", \"details\": { \"includePatientNo\": true|false, \"includePatientName\": true|false, \"includePatientContact\": true|false, \"includeDueDate\": true|false } }, Source: server/lib/email/email-generator.js, line 319 &lt;inner&gt; getFooter() Get mjml code describing common footer of emails Source: server/lib/email/email-generator.js, line 486 Returns: mjml code describing common footer of emails Type string &lt;inner&gt; getHead(the) Get mjml code describing common head of emails Parameters: Name Type Description the title title of the html document Source: server/lib/email/email-generator.js, line 468 Returns: mjml code describing common head of emails Type string &lt;inner&gt; getLogo() Get mjml code for image at the top of emails Source: server/lib/email/email-generator.js, line 451 Returns: mjml code for image at the top of emails Type string &lt;async, inner&gt; overdueTestReminderForCarer(email_info) Return html for an email containing info about a test which is overdue for a patient. Parameters: Name Type Description email_info JSON the json containing info needed to generate the email. For format info look at the module's documentation. Source: server/lib/email/email-generator.js, line 139 Returns: html for an email containing info about a test which is due for a patient Type string &lt;async, inner&gt; overdueTestReminderForHospital(email_info) Return html for an email containing info about a test which is overdue for a patient. Parameters: Name Type Description email_info JSON the json containing info needed to generate the email. For format info look at the module's documentation. Source: server/lib/email/email-generator.js, line 73 Returns: html for an email containing info about a test which is due for a patient Type string &lt;async, inner&gt; overdueTestReminderForPatient(email_info) Return html for an email containing info about a test which is overdue for a patient. Parameters: Name Type Description email_info JSON the json containing info needed to generate the email. For format info look at the module's documentation. Source: server/lib/email/email-generator.js, line 97 Returns: html for an email containing info about a test which is due for a patient Type string &lt;async, inner&gt; passwordRecoveryEmail(email_info) Return html for an email containing info about a new password which is generated for a User. Parameters: Name Type Description email_info JSON the json containing info needed to generate the email. For format info look at the module's documentation. Source: server/lib/email/email-generator.js, line 177 Returns: html for an email containing info about a test which is due for a patient Type string &lt;async, inner&gt; testReminderForCarer(email_info) Generate an email aimed at carers which reminds of a blood test due for a patient Parameters: Name Type Description email_info JSON the json containing info needed to generate the email. For format info look at the module's documentation. Source: server/lib/email/email-generator.js, line 260 &lt;async, inner&gt; testReminderForHospital(email_info) Generate an email aimed at hospitals which reminds of a blood test due for a patient of theirs Parameters: Name Type Description email_info JSON the json containing info needed to generate the email. For format info look at the module's documentation. Source: server/lib/email/email-generator.js, line 237 &lt;async, inner&gt; testReminderForPatient(email_info) Return html for an email containing info about a test which is due for a patient. Parameters: Name Type Description email_info JSON the json containing info needed to generate the email. For format info look at the module's documentation. Source: server/lib/email/email-generator.js, line 197 Returns: html for an email containing info about a test which is due for a patient Type string Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-email-sender.html":{"id":"module-email-sender.html","title":"Module: email-sender","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: email-sender The email-sender sends email to patients and labs.The module is centered around a specific config file to be created which specifiesthe host email from which emails are being sent, as well as when emails have to be sent and to who. Version: 0.0.3 Author: Danilo Del Busso, Jacopo Madaluni, Luka Kralj Source: server/lib/email/email-sender.js, line 1 Example Example of the config file. { \"transporter\": { \"host\": \"smtp.gotham.mail.com\", //example of SMTP host \"port\": 465, \"secure\": true, //this value true only with port 465 \"auth\": { \"user\": \"imnotbatman@gotham.com\", //example of email \"pass\": \"jokerisajoke42\" //password } } } Methods &lt;async, inner&gt; sendEmail(transporter, receiverOptions) Send a single email based on the options Parameters: Name Type Description transporter transporter the transporter from which emails are being sent receiverOptions JSON the options of the email address to be sent, as well as the content of the mail Source: server/lib/email/email-sender.js, line 167 &lt;async, inner&gt; sendOneEmail(emailInfo, emailGeneratorFunction) Generate and send a single email. Parameters: Name Type Description emailInfo JSON { patient: test: hospital: carer: } emailGeneratorFunction function Function that generates the email from emailInfo. Source: server/lib/email/email-sender.js, line 140 Returns: True if email was successfully sent, false if something went wrong. Type boolean &lt;async, inner&gt; sendOverdueReminderToHospital(emailInfo) Send a single reminder to hospital. Parameters: Name Type Description emailInfo JSON { patient: test: hospital: carer: } Source: server/lib/email/email-sender.js, line 113 Returns: True if email was successfully sent, false if something went wrong. Type boolean &lt;async, inner&gt; sendOverdueReminderToPatient(emailInfo) Send a single reminder to patient. Parameters: Name Type Description emailInfo JSON { patient: test: hospital: carer: } Source: server/lib/email/email-sender.js, line 95 Returns: True if email was successfully sent, false if something went wrong. Type boolean &lt;async, inner&gt; sendReminderToHospital(emailInfo) Send a single reminder to hospital. Parameters: Name Type Description emailInfo JSON { patient: test: hospital: carer: } Source: server/lib/email/email-sender.js, line 80 Returns: True if email was successfully sent, false if something went wrong. Type boolean &lt;async, inner&gt; sendReminderToPatient(emailInfo) Send a single reminder to patient. Parameters: Name Type Description emailInfo JSON { patient: test: hospital: carer: } Source: server/lib/email/email-sender.js, line 65 Returns: True if email was successfully sent, false if something went wrong. Type boolean &lt;inner&gt; sleep(ms) Await for this function to pause execution for a certain time. Parameters: Name Type Description ms number Time in milliseconds Source: server/lib/email/email-sender.js, line 193 Returns: Type Promise Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-json-controller.html":{"id":"module-json-controller.html","title":"Module: json-controller","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: json-controller Controller functions for json files reading and writing Version: 0.0.2 Author: Danilo Del Busso Source: client/lib/json-controller.js, line 1 Methods &lt;inner&gt; getJSON(path) Returns the content of the JSON file Parameters: Name Type Description path string The absolute path of the config file Source: client/lib/json-controller.js, line 28 Returns: The config in JSON format, null if the file doesn't exist or is not a properly formatted JSON object Type json Example Example usage of getJSON. getJSON(__dirname + '/config.json') &lt;inner&gt; isJSON(data) Check if the data is a properly formatted JSON file Parameters: Name Type Description data string Source: client/lib/json-controller.js, line 51 Returns: null if the data was not a properly formatted JSON object, the data in JSON if otherwise Type JSON Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-json-parser.html":{"id":"module-json-parser.html","title":"Module: json-parser","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: json-parser Controller functions for json files reading and writing Version: 0.0.2 Author: Danilo Del Busso Source: server/lib/json-parser.js, line 1 Methods &lt;inner&gt; getJSON(path) Returns the content of the JSON file Parameters: Name Type Description path string The absolute path of the config file Source: server/lib/json-parser.js, line 27 Returns: The config in JSON format, null if the file doesn't exist or is not a properly formatted JSON object Type json Example Example usage of getJSON. getJSON(__dirname + '/config.json') &lt;inner&gt; isJSON(data) Check if the data is a properly formatted JSON file Parameters: Name Type Description data string Source: server/lib/json-parser.js, line 41 Returns: null if the data was not a properly formatted JSON object, the data in JSON if otherwise Type JSON Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-logger.html":{"id":"module-logger.html","title":"Module: logger","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: logger A logger module, it allows for different levels of loggingand to save a log file and/or output the log to console. Version: 0.0.2 Author: Danilo Del Busso Source: server/lib/logger.js, line 1 Methods &lt;inner&gt; append(element) Append an element to the log file. Parameters: Name Type Description element Object the element to be appended to the log file Source: server/lib/logger.js, line 223 &lt;inner&gt; argumentsToArray(args) Convert the JSON file created by calling the \"arguments\" variable inside a function with no parameters, to an array Parameters: Name Type Description args JSON the JSON file created by calling the \"arguments\" variable inside a function with no parameters7 Source: server/lib/logger.js, line 316 Returns: an array containing the values of the JSON file. Empty if the args JSON was not valid. Type array &lt;inner&gt; changeOption(optionName, value) Change an existing option value.If the option does not exist, nothing is changed.If the value does not have the same type as the value that needs to be changed, nothing is changed. Parameters: Name Type Description optionName string the name of the existing options. value Object the new value of the option. Source: server/lib/logger.js, line 270 Returns: the new value of the option. null if the parameters are not valid. Type Object &lt;inner&gt; convertToString(obj) Convert any object to a stringIf the object is a JSON file, use the stringify() function.Else, use the String(obj) Parameters: Name Type Description obj Object the object to be converted to a string Source: server/lib/logger.js, line 288 Returns: the object converted to string Type string &lt;inner&gt; createLog(messages, level) Log all the strings or objects contained using the options configuration. Parameters: Name Type Description messages array the set of objects level string Source: server/lib/logger.js, line 149 &lt;inner&gt; debug() Use to create a debugging log message. It takes any number of parameters Source: server/lib/logger.js, line 90 &lt;inner&gt; deleteAllLogFiles() Flush the content of every log file and delete them. Source: server/lib/logger.js, line 250 &lt;inner&gt; deleteFolderRecursive(path) Recursively and synchronously delete all files inside a path.taken from https://bit.ly/2TqLDWv Parameters: Name Type Description path string Source: server/lib/logger.js, line 333 &lt;inner&gt; deleteLogFile() Flush the content of the log file. And delete it. Source: server/lib/logger.js, line 234 &lt;inner&gt; error() Use to create a error log message. It takes any number of parameters Source: server/lib/logger.js, line 76 &lt;inner&gt; getLogPath(outputPath) Generate the log path for this module Parameters: Name Type Description outputPath string the output path Source: server/lib/logger.js, line 307 &lt;inner&gt; info() Use to create a info log message. It takes any number of parameters Source: server/lib/logger.js, line 69 &lt;inner&gt; initialise(configPath) Generate the options for the use of this module and create a write stream.If the path of the config is not valid, use a set of default options. Parameters: Name Type Description configPath string the path of the config file. Source: server/lib/logger.js, line 117 Returns: the options for logging. Type JSON &lt;inner&gt; log() Use to create a general log message. It takes any number of parameters Source: server/lib/logger.js, line 96 &lt;inner&gt; warning() Use to create a warning log message. It takes any number of parameters Source: server/lib/logger.js, line 83 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-overdue-controller.html":{"id":"module-overdue-controller.html","title":"Module: overdue-controller","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: overdue-controller Controller functions to handle overdue tests Version: 0.0.1 Author: Jacopo Madaluni Source: client/src/lib/overdue-controller.js, line 1 Methods &lt;inner&gt; daysBetweenDates(date1, date2) Parameters: Name Type Description date1 Date date2 Date Source: client/src/lib/overdue-controller.js, line 13 Returns: The number of days in between. Type Int &lt;inner&gt; group(tests) Groups the list of tests based on whether they spent 1 year+, months,or weeks overdue. Parameters: Name Type Description tests Source: client/src/lib/overdue-controller.js, line 77 Returns: &lt;inner&gt; sortByOverdueTime(tests) Returns a sorted list in descending order based onhow much time each test has been overdue for. Parameters: Name Type Description tests List The list of overdue tests Source: client/src/lib/overdue-controller.js, line 40 Returns: A sorted version of the imput list Type List Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-query-controller.html":{"id":"module-query-controller.html","title":"Module: query-controller","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: query-controller This module collects all the queries that are dealing with the core data. Version: 1.0 Author: Mateusz Nowak, Luka Kralj Source: server/lib/query-controller.js, line 1 Methods &lt;async, inner&gt; addCarer(json, actionUsername) Add new carer to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description carer_email Source: server/lib/query-controller.js, line 545 Returns: result of the query - {success:Boolean} Type JSON &lt;async, inner&gt; addHospital(json, actionUsername) Add new Hospital to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description hospital_email Source: server/lib/query-controller.js, line 533 Returns: result of the query - {success:Boolean} Type JSON &lt;async, inner&gt; addPatient(json, actionUsername) Add new patient to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description patient_no Source: server/lib/query-controller.js, line 521 Returns: result of the query - {success:Boolean} Type JSON &lt;async, inner&gt; addPatientExtended(patientInfo, actionUsername) Add new patient entry to the database with optional carer/hospital Parameters: Name Type Description patientInfo JSON entry to add actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 555 Returns: result of the query - {success:Boolean response:{insertedId/problem (+ optional fields)}} Type JSON &lt;async, inner&gt; addTest(json, actionUsername) Add new test to the database Parameters: Name Type Description json JSON entry to add actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description patient_no due_date Source: server/lib/query-controller.js, line 509 Returns: result of the query - {success:Boolean} Type JSON &lt;async, inner&gt; addUser(json, actionUsername) Add new user to the database Parameters: Name Type Description json JSON user actionUsername string The user who issued the request.Obligatory properties within JSON Properties: Name Type Description username String hashed_password String email String isAdmin string \"yes\" | \"no\" Source: server/lib/query-controller.js, line 497 Returns: result of the query - {success:Boolean} Type JSON &lt;async, inner&gt; changePatientColour(patientNo, newColour) Edit patient colour - quick update. Parameters: Name Type Description patientNo String Number of the patient to update newColour string New colour to be stored. Source: server/lib/query-controller.js, line 473 Returns: &lt;async, inner&gt; changeTestColour(testId, newColour) Edit test colour - quick update. Parameters: Name Type Description testId String Id of the test to update newColour string New colour to be stored. Source: server/lib/query-controller.js, line 457 Returns: &lt;async, inner&gt; changeTestDueDate(testId, newDate) Edit test due date - drag &amp; drop method Parameters: Name Type Description testId String Id of the test to update newDate Date new due date Source: server/lib/query-controller.js, line 356 Returns: &lt;async, inner&gt; changeTestStatus(test, actionUsername) Change the status of the test in the database Parameters: Name Type Description test JSON actionUsername string The user who issued the request. Properties: Name Type Description testId String id of a test to change Source: server/lib/query-controller.js, line 408 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; checkIfPatientsTestsAreEdited() Check if test are edited within the EditTokens database Source: server/lib/query-controller.js, line 719 Returns: {false - If no tests are edited (no tokens)} Type Boolean {true - If tests are edited (tokens in table)} Type Boolean {Error response} Type JSON &lt;async, inner&gt; deleteCarer(carerid, actionUsername) Delete Carer entry from database Parameters: Name Type Description carerid String id of a carer to be deleted actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 645 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async, inner&gt; deleteHospital(hospitalid, actionUsername) Delete hospital entry from database Parameters: Name Type Description hospitalid String id of a hospital to be deleted actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 655 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async, inner&gt; deletePatient(patientid, token, actionUsername) Delete Patient and cancel the patient edit token Parameters: Name Type Description patientid String patient_no of a patient token String token to be returned with query actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 666 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async, inner&gt; deleteTest(testid, actionUsername) Delete test entry from database Parameters: Name Type Description testid String id of a test to be deleted actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 690 Returns: result of the query - {success:Boolean response:\"Entry deleted\"/Error} Type JSON &lt;async, inner&gt; editCarer(newInfo, token, actionUsername) Edit carer query Parameters: Name Type Description newInfo JSON All the information of the carer to update token The token that grants edit privileges actionUsername string The user who issued the request. Properties: Name Type Description carer_id String Source: server/lib/query-controller.js, line 346 &lt;async, inner&gt; editHospital(newInfo, token, actionUsername) Edit hospital query Parameters: Name Type Description newInfo JSON All the information of the hospital to updateObligatory fields in JSON token The token that grants edit privileges actionUsername string The user who issued the request. Properties: Name Type Description hospital_id String Source: server/lib/query-controller.js, line 335 &lt;async, inner&gt; editPatient(newInfo, token, actionUsername) Edit patient query Parameters: Name Type Description newInfo JSON All the information of the patient to updateObligatory fields in JSON token The token that grants edit privileges actionUsername string The user who issued the request. Properties: Name Type Description patient_no String Source: server/lib/query-controller.js, line 248 &lt;async, inner&gt; editPatientExtended(newInfo, token) Edit patient with hospital and carer query Parameters: Name Type Description newInfo JSON All the information of the patient/hospital/carer to update token The token that grants edit privileges Source: server/lib/query-controller.js, line 258 Returns: query result {success:Boolean response:{Response of each query as {success:Boolean response:Array/Error/String} or {} }} Type JSON &lt;async, inner&gt; editTest(testId, newInfo, token, actionUsername) Edit test query Parameters: Name Type Description testId The id of the test to be updated newInfo JSON All the information of the test (new and old) token The token that grants edit privileges actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 214 &lt;async, inner&gt; editUser(json, actionUsername) Update User in database Parameters: Name Type Description json JSON user actionUsername string The user who issued the request.Obligatory properties: Properties: Name Type Description username String ,One of optional propertiesOptional properties: recovery_email String hashed_password String Source: server/lib/query-controller.js, line 377 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async, inner&gt; getAllPatients(isAdult) Get all the patients from the database Parameters: Name Type Description isAdult Boolean If the records should be displayed for adult users Source: server/lib/query-controller.js, line 101 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; getAllUsers() Get all users from database Source: server/lib/query-controller.js, line 118 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; getCarer(carerID) Get the carer given its carer id Parameters: Name Type Description carerID string the carer id Source: server/lib/query-controller.js, line 83 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async, inner&gt; getFullPatientInfo(patient_no) Get the info of the patient together with the info of eventual carers and hospitals Parameters: Name Type Description patient_no string the patient number Source: server/lib/query-controller.js, line 74 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async, inner&gt; getHospital(hospital_id) Get the hospital given its hospital id Parameters: Name Type Description hospital_id string the hospital id Source: server/lib/query-controller.js, line 92 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async, inner&gt; getMonthlyReport(date) Collects data from selector queries and returns them. Parameters: Name Type Description date date Source: server/lib/query-controller.js, line 27 Returns: {success:Boolean, response:JSON} Type JSON &lt;inner&gt; getNextDueDate(frequency) Get next due date of a test in \"YYYY-MM-DD\" format; relative to today Parameters: Name Type Description frequency String frequency of the test as stored in database Source: server/lib/query-controller.js, line 735 Returns: next due date in \"YYYY-MM-DD\" format Type String &lt;async, inner&gt; getNextTestsOfPatient(patientId) Get not completed tests from patient Parameters: Name Type Description patientId String id of patient Source: server/lib/query-controller.js, line 136 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; getOverdueReminderGroups(isAdult) Returns overdue tests that are separated into two groups. One group are the tests that haven't beensent a reminder. The other group are the tests that have already been sent a reminder.Response includes some basic info about the test. Parameters: Name Type Description isAdult Boolean If the records should be displayed for adult users Source: server/lib/query-controller.js, line 199 Returns: { success: true|false, response: { notReminded: [{ test_id: due_date: patient_no: patient_name: patient_surname: }, ...] reminded: [{ test_id: due_date: patient_no: patient_name: patient_surname: last_reminder: reminders_sent: }, ...] } } Type JSON &lt;async, inner&gt; getPatient(patient_no) Get the patient given its patient number Parameters: Name Type Description patient_no string the patient number Source: server/lib/query-controller.js, line 65 Returns: {success:Boolean response:Array or Error} Type JSON &lt;async, inner&gt; getTest(test_id) Get test from the database Parameters: Name Type Description test_id String id of test Source: server/lib/query-controller.js, line 127 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; getTestInfo(test_id) Get test info with patient info from the database Parameters: Name Type Description test_id String id of test Source: server/lib/query-controller.js, line 145 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; getTestWithinWeek(date, isAdult) Get all tests within the week from the database Parameters: Name Type Description date String any date (from Monday to Friday) within the week to retrieve (format: \"YYYY-MM-DD\") isAdult Boolean If the records should be displayed for adult users Source: server/lib/query-controller.js, line 167 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; getUser(username) Get user from database Parameters: Name Type Description username String username to retrieve Source: server/lib/query-controller.js, line 110 Returns: result of the query - {success:true/false response:Array/Error} Type JSON &lt;async, inner&gt; requestEditing(table, id, actionUsername) Request editing of an entry in table Parameters: Name Type Description table String Table to edit id String id to edit actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 776 Returns: token Type String &lt;async, inner&gt; returnToken(table, id, token, actionUsername) Cancel editing on an entry Parameters: Name Type Description table String Table of an entry id String id value of an entry token String token to return actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 788 Returns: result - {success:Boolean response:\"Token cancelled\"/Error} Type JSON &lt;async, inner&gt; scheduleNextTest(testId, actionUsername, newInfo) Schedule next blood test based on information in database and/or new information providedNew information have priority over stored in database (new info &gt; database info) Parameters: Name Type Description testId String id of a string from which to take the info actionUsername string The user who issued the request. newInfo JSON (optional) new info to add into database with new test Source: server/lib/query-controller.js, line 748 Returns: result of query {success:true/false reply:(optional;when no new entry inserted due to finished range of tests)} Type JSON &lt;inner&gt; sortPatinetProperties(patientInfo) Sort patient properties into patient,carer and hospital information Parameters: Name Type Description patientInfo JSON information to be sorted Source: server/lib/query-controller.js, line 797 Returns: Sorted information: {patient: hospital: carer:} Type JSON &lt;async, inner&gt; unscheduleTest(testid, token, actionUsername) Unschedule test Parameters: Name Type Description testid String id of the test to delete token String token to realease with the unscheduling actionUsername String username that triggered the action Source: server/lib/query-controller.js, line 700 &lt;async, inner&gt; updateLastReminder(testId, token, actionUsername) Update when the last reminder for this test was sent. Parameters: Name Type Description testId string id of a test to change token string The token that grants edit privileges. actionUsername string The user who issued the request. Source: server/lib/query-controller.js, line 446 Returns: result of the query - {success:true/false response:Array/Error} Type JSON Type Definitions getSortedOverdueWeeks Get all the overdue tests from the database plus additional info about time difference Type: SortedWeek Properties: Name Type Description class String monday of the week, format: 'Mon Mar 04 2019 00:00:00 GMT+0000 (GMT)' Source: server/lib/query-controller.js, line 157 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-report-generator.html":{"id":"module-report-generator.html","title":"Module: report-generator","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: report-generator This module provides function for reports generation. Version: 1.0 Author: Luka Kralj Source: server/lib/report-generator.js, line 1 Methods &lt;inner&gt; getDate(month) Transforms string into a valid date in that month. Parameters: Name Type Description month string Source: server/lib/report-generator.js, line 127 Returns: Type Date &lt;async, inner&gt; getMonthlyReport(month, actionUsername) Generate monthly report for a particular month. Parameters: Name Type Description month string actionUsername string User who requested the report Source: server/lib/report-generator.js, line 24 Returns: {success:Boolean, html: string} Type JSON Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-server.html":{"id":"module-server.html","title":"Module: server","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: server The module responsible for all the queries on the databaseand processing of the data retrieved. Version: 0.0.1 Author: Mateusz Nowak, Jacopo Madaluni, Luka Kralj Source: server/app.js, line 1 Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-serverConnection.html":{"id":"module-serverConnection.html","title":"Module: serverConnection","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: serverConnection This file establishes a socket connection with the server and provides every singleprotocol need by every component of the UIThe socket connection can be created by using the only method available to the public (getServerConnect())which will return a ServerConnect object. That object represent a socket connection and will beunivoque and shared between all client components.Every protocol will be available through this object. Version: 0.0.2 Author: Danilo Del Busso, Mateusz Nowak, Jacopo Madaluni Source: client/src/serverConnection.js, line 2 Methods &lt;inner&gt; getServerConnect() Function to get the unique instance of the server connection Source: client/src/serverConnection.js, line 513 Returns: Type ServerConnect Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-token-functions-test.html":{"id":"module-token-functions-test.html","title":"Module: token-functions-test","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: token-functions-test This file contains tests that test the behaviour of token-generator.js Version: 1.0 Author: Luka Kralj Source: server/test/unit/lib/calendar-functions-test.js, line 1 See: module:token-generator Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-token-generator.html":{"id":"module-token-generator.html","title":"Module: token-generator","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: token-generator Unique token generator. Version: 1.0 Author: Luka Kralj Source: server/lib/db_controller/token-generator.js, line 1 Methods &lt;inner&gt; addLetters(token) Inserts letters into the token so that it is even harder to guess. Parameters: Name Type Description token string Token obtained from the timestamp. Source: server/lib/db_controller/token-generator.js, line 33 Returns: Token with added letters. Type string &lt;inner&gt; generateLoginToken() Generates a unique sequence of numbers and letters that can be used for identification.This generates a longer token than generateToken() which makes it more secure. Source: server/lib/db_controller/token-generator.js, line 116 Returns: A unique token. &lt;inner&gt; generateToken() Generates a unique sequence of numbers and letters that can be used for identification. Source: server/lib/db_controller/token-generator.js, line 74 Returns: A unique sequence of numbers and letters (usually around 40 characters long). Type string &lt;inner&gt; randInt(min, max) Generates a random integer. Parameters: Name Type Description min number Lower bound. max number Upper bound. Source: server/lib/db_controller/token-generator.js, line 21 Returns: Random integer. Type number &lt;inner&gt; randLetter() Returns a random letter from A-Z or a-z. Source: server/lib/db_controller/token-generator.js, line 64 Returns: A random letter. &lt;inner&gt; randSeq(max) Generates a random sequence of letters, possibly empty. Parameters: Name Type Default Description max number 3 Maximum length of the string that we want. Source: server/lib/db_controller/token-generator.js, line 50 Returns: Random sequence, possibly empty. Type string Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "},"module-token-generator-test.html":{"id":"module-token-generator-test.html","title":"Module: token-generator-test","body":" Blood Test Diary Documentation Modules action-loggeraction-logger-testauthenicatorauthenticator-testcalendar-controllercalendar-functionsdb-controllerdb_controller_testemail-controlleremail-generatoremail-senderjson-controllerjson-parserloggeroverdue-controllerquery-controllerreport-generatorserverserverConnectiontoken-functions-testtoken-generatortoken-generator-test Classes Database Global addCareraddHospitaladdPatientaddTestaddUserarraysOfDatesEqualcallCommandchangePatientColourchangeTestStatuscharacterCheckcheckMultipleQueriesStatusdeleteCarerdeleteHospitaldeletePatientdeleteQueryDatabasedeleteTesteditCarereditHospitaleditPatienteditTesteditUseremailCheckemptyCheckgetAllPatientsgetAllUsersgetCarergetCompletedLateInMonthgetCompletedOnTimeInMonthgetDueTestsInMonthgetFullPatientInfogetHospitalgetLastLineOfFilegetMonthAndYeargetMonthNamegetNextTestsOfPatientgetNumberOfRemindersSentgetOverdueReminderGroupsgetPatientgetPatientsNumbergetTestgetTestInfogetTestsDuringTheWeekgetTestWithinWeekgetUserinsertQueryDatabaseintegerCheckintRegexprepareDeleteSQLprepareInsertSQLprepareUpdateSQLrequestEditingreturnTokenselectQueryDatabasesleepupdateLastReminderupdateQueryDatabase Module: token-generator-test This file contains tests that test the behaviour of token-generator.js Version: 1.0 Author: Luka Kralj Source: server/test/unit/lib/db_controller/token-generator-test.js, line 1 See: module:token-generator Methods &lt;inner&gt; testUniqueness() Generates and compares 10000 tokens. Source: server/test/unit/lib/db_controller/token-generator-test.js, line 20 Returns: true if all tokens are unique, false if not. Type boolean Ã— Search results Close Documentation generated by JSDoc 3.5.5 on Wed Mar 27th 2019 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
